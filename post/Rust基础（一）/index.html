<!DOCTYPE html>
<html lang="en">

  <head>
    <!--每个页面都需要 head link等  -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>
  Rust基础（一） - September&#39;s Blog
</title>
<link rel="shortcut icon" href="https://gh.qxxiao.eu.org/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://gh.qxxiao.eu.org/media/css/tailwind.css">
<link rel="stylesheet" href="https://gh.qxxiao.eu.org/media/css/ldbutton.css">
<link rel="stylesheet" href="https://gh.qxxiao.eu.org/media/css/nav-menu.css">

<link rel="stylesheet" href="https://gh.qxxiao.eu.org/styles/main.css">
<script src="https://gh.qxxiao.eu.org/media/scripts/initTheme.js"></script>
<link rel="stylesheet" href="https://gh.qxxiao.eu.org/media/css/light-dark.css">


<link rel="alternate" type="application/atom+xml" title="Rust基础（一） - September&#39;s Blog - Atom Feed"
  href="https://gh.qxxiao.eu.org/atom.xml">


      <meta name="description" content="hello rust.

Rust 快速入门，参考 《Rust程序设计语言》。
类型与变量
基础类型
i8, i16, i32, i64, i128, isize // 有符号整型
u8, u16, u32, u64, u128, usiz..." />
      <meta property="og:title" content="Rust基础（一） - September&#39;s Blog" />
      <meta property="og:description" content="hello rust.

Rust 快速入门，参考 《Rust程序设计语言》。
类型与变量
基础类型
i8, i16, i32, i64, i128, isize // 有符号整型
u8, u16, u32, u64, u128, usiz..." />
      <meta property="og:type" content="articles" />
      <meta property="og:url" content="https://gh.qxxiao.eu.org/post/Rust基础（一）/" />
      <meta property="og:image"
        content="https://pic.qxxiao.cn/20220530212851.png" />
      <meta property="og:image:height" content="630" />
      <meta property="og:image:width" content="1200" />
      <meta name="twitter:title" content="Rust基础（一） - September&#39;s Blog" />
      <meta name="twitter:description" content="hello rust.

Rust 快速入门，参考 《Rust程序设计语言》。
类型与变量
基础类型
i8, i16, i32, i64, i128, isize // 有符号整型
u8, u16, u32, u64, u128, usiz..." />
      <meta name="twitter:card" content="summary_large_image" />
      <link rel="canonical" href="https://gh.qxxiao.eu.org/post/Rust基础（一）/" />

      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css" />

      
        <link rel="stylesheet"
          href="https://gh.qxxiao.eu.org/media/css/prism-vs-dark.css" />
        <link href="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/line-numbers/prism-line-numbers.min.css"
          rel="stylesheet" />
        <link href="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/toolbar/prism-toolbar.min.css"
          rel="stylesheet" />
        <link href=https://cdn.bootcdn.net/ajax/libs/prism/1.29.0/plugins/line-highlight/prism-line-highlight.min.css />
        
          
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" />
            
  </head>

  <body>
    <div class="antialiased flex flex-col min-h-screen" id="app">
      <!-- 标题菜单 -->
<div class="nav py-3 md:py-8 fixed w-full z-10 bg-gray-50 dark:bg-gray-700 transition-all duration-300"
  :class="{ 'scroll': scrolled }">
  <div class="flex justify-end px-4">
    <div class="w-8 h-8 flex justify-center items-center rounded-full md:hidden" @click="showMenu = !showMenu">
      <i class="ri-close-line" v-show="showMenu"></i>
      <i class="ri-menu-3-line" v-show="!showMenu"></i>
    </div>
  </div>
  <nav cloak class="max-w-4xl w-full mx-auto text-right flex flex-col md:flex-row justify-between items-center md:flex"
    :class="`${ showMenu ? 'flex' : 'hidden' }`">
    
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
          <a href="/" target=""
            class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
            首页
          </a>
          
            
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
          <a href="/archives" target=""
            class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
            归档
          </a>
          
            
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
          <a href="/tags" target=""
            class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
            标签
          </a>
          
            
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
          <a href="https://gh.qxxiao.eu.org/nav" target=""
            class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
            导航
          </a>
          
            
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
        <div
          class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold dark:hover:bg-gray-600 hover:bg-gray-200 nav-time1">
          时光
            <div class="transition font-semibold nav-time2">
              
                <a href="https://gh.qxxiao.eu.org/diary/" class="">
                  说说
                </a>
                
                <a href="https://gh.qxxiao.eu.org/gallery/" class="">
                  相册
                </a>
                
                <a href="https://gh.qxxiao.eu.org/post/book/" class="">
                  书单
                </a>
                
            </div>
        </div>
        
            
      <!-- 如果 menu 是 "时光"， 渲染为一个hover显示下拉框组件-->
      
          <a href="/post/about" target=""
            class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
            关于
          </a>
          
            
              <!-- <a href="https://gh.qxxiao.eu.org/atom.xml" target="_blank" class="py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
      RSS
    </a> -->
              <!-- 黑色模式，和亮色模式开关-->
<div class="py-2 md:py-1 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200">
  <label for="night-light-checkbox" class="night-light-label">
    <input type="checkbox" id="night-light-checkbox" @change="toggleDarkMode" />
    <span v-cloak class="night-light-ball" id="night-light-ball"></span>
    <svg viewBox="0 0 512 512" class="sun-svg">
      <path id="sun-svg"
        d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z">
      </path>
    </svg>
    <svg viewBox="0 0 512 512" class="moon-svg">
      <path id="moon-svg"
        d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z">
      </path>
    </svg>
  </label>
</div>
                <form id="gridea-search-form" class="inline-flex mx-4 px-4" action="https://gh.qxxiao.eu.org/search/">
                  <input type="search" autocomplete='off' spellcheck='false' name="q" />
                </form>
  </nav>

</div>
        <a href="https://gh.qxxiao.eu.org"
          class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10">
          September&#39;s Blog
        </a>
        <div class="max-w-4xl w-full mx-auto">
          <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 px-4 md:px-8 pb-8 mb-8">
            <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
              Rust基础（一）
            </h1>
            <!-- 不显示 Post 中的封面图片 -->
            
                <div class="mb-8 flex flex-wrap">
                  <div class="text-gray-400 text-sm mr-4">
                    <i class="ri-calendar-2-line" style="vertical-align: middle;"></i>
                    2022-05-28 ·
                      <i class="ri-file-word-line" style="vertical-align: middle;"></i>
                      9141字 ·
                        <i class="ri-timer-line" style="vertical-align: middle;"></i>
                        38 min read
                  </div>
                  🏷️&nbsp;
                      
                        <a href="https://gh.qxxiao.eu.org/tag/rust/"
                          class="text-indigo-500 text-sm border-b-2 border-solid border-indigo-500 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
                          <i class="ri-hashtag" style="vertical-align: middle;"></i>
                          Rust
                        </a>
                        
                </div>
                <div class="markdown mb-8" v-pre><p>hello rust.</p>
<!-- more -->
<p>Rust 快速入门，参考 《Rust程序设计语言》。</p>
<h2 id="类型与变量">类型与变量</h2>
<h3 id="基础类型">基础类型</h3>
<pre><code class="language-rust">i8, i16, i32, i64, i128, isize // 有符号整型
u8, u16, u32, u64, u128, usize // 无符号整型
f32, f64                     // 浮点型，默认f64
bool                         // 布尔类型，true/false
char                         // 字符类型，4字节，Unicode标量值
// 数组索引 / 容器长度几乎都用 usize(和指针大小相同，64位系统为64位)
</code></pre>
<h3 id="变量">变量</h3>
<p>Rust 变量使用 <code>let</code> 关键字声明，默认是不可变的，但可以使用<code>mut</code>关键字声明可变变量。如果声明的是不可变变量，一旦值被绑定一个名称上，你就<strong>不能改变这个值</strong>。</p>
<ul>
<li>常量总是不可变，使用<code>const</code>关键字声明，必须显式指定类型，且只能绑定到<strong>常量表达式</strong>；</li>
<li>变量的遮蔽（shadowing）：可以使用相同名称重新声明变量（新变量），新的变量会遮蔽掉前面的变量，可以改变类型；（可以利用遮蔽简化命名；或者在局部作用域内对不可变变量进行操作-作用域结束时，内部遮蔽的作用域也结束）</li>
</ul>
<h3 id="复合类型">复合类型</h3>
<h4 id="元组">元组</h4>
<p>固定长度的有序集合，可以包含不同类型的值，常用于函数返回多个值：</p>
<pre><code class="language-rust">let tup: (i32, f64, bool) = (500, 6.4, true);
let (x, y, z) = tup; // 使用模式匹配来解构赋值
let five_hundred = tup.0; // 通过下标访问
</code></pre>
<p>不带任何值的元组叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p>
<h4 id="数组">数组</h4>
<p>固定长度的同类型元素集合，<span style="color:#d44c47">栈分配</span> ，<strong>长度是数组类型的一部分</strong>例如<code>[i32; 5]</code>：</p>
<pre><code class="language-rust">let a: [i32; 5] = [1, 2, 3, 4, 5];
let first = a[0]; // 访问元素
let b = [3; 5]; // 创建含5个3的数组，[初始值; 长度]
</code></pre>
<h4 id="动态数组-vect">动态数组 <code>Vec&lt;T&gt;</code></h4>
<p>动态大小的同类型元素集合，<span style="color:#d44c47">堆分配</span>：</p>
<pre><code class="language-rust">// let v = vec![1, 2, 3]; // 宏创建
let mut v: Vec&lt;i32&gt; = Vec::new();
v.push(1);
v.push(2);
let third = &amp;v[2]; // 访问元素
match v.get(2) {
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; println!(&quot;None&quot;),
}
</code></pre>
<h4 id="字符串和切片">字符串和切片</h4>
<p>经常使用的字符串类型有：<code>String，&amp;String, &amp;str</code>。</p>
<p><code>String</code>动态大小字符串，可以用来声明变量指向堆上分配的数据（使用<strong>起始地值+长度+容量</strong>实现）。<code>&amp;String</code>是其引用类型，借用而不获取所有权。</p>
<p><code>str</code>系统类型，具有动态大小，所以不能直接用来声明变量(只能通过引用或指针访问)。代表的是一段 UTF-8 编码的字节序列。</p>
<p><code>&amp;str</code>字符串切片，可以用来声明变量，也是一种引用类型，指向一块字符串字节数组。（<strong>起始地值+长度</strong>实现，没有所有权）。字符串字面量创建的变量默认声明为<code>&amp;str</code>，即引用分配在静态存储区的常量字符串。必须符合utf-8字符的边界。</p>
<ul>
<li>函数参数如果是字符串类型，尽量使用<code>&amp;str</code>，更加通用(String类型容易转换为切片，&amp;String 可通过解引用强制转换为 &amp;str，或者使用切片)</li>
</ul>
<p>字符串String类型底层就是<code>Vec&lt;u8&gt;</code>字节数组，字符串使用 UTF-8 编码，并提供字节-文本解析方法。String 类型来自标准库而非核心语言，可增长，可修改和获得所有权的类型。</p>
<div class="markdown notion" style="padding: 10px; color: #37352f; background-color: #e7f3f8; border-radius: 6px; border:1px solid #dfdfde">
<div style="width: 28px;height: 28px;margin-left: 0px;margin-right: 10px;position: absolute;"><span style="font-size: 18px;">💡</span></div>
<p style="line-height: 28px; margin: 0px 5px 0px 38px !important">在<strong>核心语言层面</strong>，Rust只有一个字符串类型 str (大小可变的字符串)，通常使用 &str 来表示字符串切片。字符串切片：引用类型，对存储在其它地方的utf-8编码字符串的引用。</p></div>
<p>常用方法：</p>
<pre><code class="language-rust">// 创建String
let s = String::from(&quot;hello&quot;);
let s = String::new();
let s = &quot;hello&quot;.to_string();
// 添加字符串/字符
s.push_str(&quot;, world!&quot;);
s.push('!');
// 拼接字符串
let s3 = s1 + &amp;s2; // fn add(self, s: &amp;str) -&gt; String
let s3 = format!(&quot;{}-{}&quot;, &quot;hello&quot;, s); // format!
</code></pre>
<ul>
<li>
<p>拼接字符串的<code>+</code>操作，注意获取了<code>s1</code>的所有权（后续失效），参数是<code>&amp;str</code>;<strong>解引用强制转换(deref coercion)可以将 &amp;String 转换为 &amp;str 类型。</strong></p>
</li>
<li>
<p>使用<code>format!</code>宏拼接字符串，不会获取所有权，方便于多个字符串的拼接。</p>
</li>
</ul>
<p>内部表示：</p>
<p>String 底部是<code>u8</code>字节数组，使用 UTF-8 编码存储 Unicode 标量值，主要特性：</p>
<ol>
<li>
<p>不支持整形下标索引(保证字符索引安全)；</p>
</li>
<li>
<p>使用 [..] 创建字符串切片时，也必须符合 utf-8 字符边界，否则出现运行时错误；</p>
</li>
</ol>
<h3 id="struct">struct</h3>
<h4 id="结构体-struct">结构体 struct</h4>
<p>自定义类型，封装多个字段。</p>
<ul>
<li>如果定义一个可变的 struct 变量，则其所有的字段都是可变的；</li>
</ul>
<p>构造 struct 时可以使用字段初始化简写语法：</p>
<pre><code class="language-rust">struct User{
    name: String,
    active: bool,
}

let name = String::from(&quot;alice&quot;);

let user1 = User{
    name, // 简写，相当于 name: name, 使用变量 name 的值初始化
    active: true,
};

let user2 = User{
    active = false, // 不同的字段
    // 使用结构体更新语法从其他实例创建实例
    // .. 语法指定了剩余未显式设置值的字段应与给定实例对应字段相同的值
    ..user1
};
</code></pre>
<p>结构体调试打印：</p>
<pre><code class="language-rust">#[derive(Debug)] // 自动实现 Debug trait
struct User{
    name: String,
    active: bool,
}

fn main(){
    let user = User{
        name: String::from(&quot;alice&quot;),
        active: true,
    };
    // 使用 {:?} 或 {:#?} 进行调试打印
    println!(&quot;{:#?}&quot;, user); // println!(&quot;{user:#?}&quot;);
}
</code></pre>
<ul>
<li>使用使用 <code>dbg!</code> 宏打印到标准错误控制台流</li>
<li><code>println!</code> 接收的是引用，不会获取所有权。而 <code>dbg!</code> 宏会获取所有权并返回该值的所有权。</li>
</ul>
<h4 id="元组结构体tuple-struct">元组结构体（tuple struct）</h4>
<p>元组结构体没有具体的字段名，只有字段的类型，但整个类型是具名类型。<br>
使用上与元组类似：</p>
<ul>
<li>可以解构为单独的部分，<strong>但是需要写明结构体的类型</strong>；</li>
<li>可以使用 <code>.</code> 后跟索引来访问单独的值</li>
</ul>
<pre><code class="language-rust">struct Point(i32, i32, i32);
let origin = Point(0, 0, 0);
// 解构
let Point(x, y, z) = origin;
// 访问
let x = origin.0;
</code></pre>
<h4 id="类单元结构体unit-like-struct">类单元结构体(unit-like struct)</h4>
<p>没有任何字段的结构体，类似于单元类型<code>()</code>，主要用于在某个类型上实现 trait 但不需要在类型中存储数据：</p>
<pre><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual; // 只需要使用名称
}
</code></pre>
<h4 id="定义方法和关联函数">定义方法和关联函数</h4>
<p>方法（method）在结构体的上下文中（<strong>impl 块</strong>）被定义（或者是枚举或 trait 对象的上下文），并且第一个参数总是 self，它代表调用该方法的结构体实例。</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: i32,
    height: i32,
}

impl Rectangle {
    //构造函数-关联函数
    // 关键字 Self 在函数的返回类型和函数体中，都是对 impl 关键字后所示类型的别名
    pub fn new(width: i32, height: i32) -&gt; Self {
        Self {
            //同名可以省略
            width,
            height,
        }
    }

    // 方法，&amp;self参数; self: &amp;Self 的缩写
    fn erea(&amp;self) -&gt; i32 {
        self.width * self.height
    }

    //关联函数
    fn erea2(width: i32, height: i32) -&gt; i32 {
        width * height
    }

    fn drop(mut self) {
        println!(&quot;drop myself&quot;);
    }
}
</code></pre>
<ul>
<li>
<p>使用<code>impl</code>块来定义方法和关联函数，每个结构体允许有多个块；</p>
</li>
<li>
<p>如果块中函数第一个参数为<code>self | &amp;self | &amp;mut self</code>，函数类型是该类型的方法；其他就数就是（非方法的）关联函数，使用 <code>structName::funcName()</code> 调用；（非方法的）关联函数经常被用作返回一个结构体新实例的构造函数，例如 new 函数。</p>
</li>
</ul>
<h3 id="enum-和模式匹配">enum 和模式匹配</h3>
<h4 id="枚举-enum">枚举 enum</h4>
<p>枚举类型，定义了同类型的多个变体（同属该类型），<strong>定义的变体名字同时也是构建枚举实例的函数</strong>。</p>
<p>每个枚举变体可以关联一组不同类型的数据，关联的数据可以通过match模式匹配来获取:</p>
<pre><code class="language-rust">enum IpAddrKind {
    V4(u32,u32,u32,u32),
    V6(String),
}
let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</code></pre>
<ul>
<li>可以使用 impl 在枚举上定义方法。</li>
</ul>
<p>标准库枚举 <code>Option&lt;T&gt;</code> 用来解决空值问题(编码存在或不存在):</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

let some_num = Some(5);
let absent_num: Option&lt;i32&gt; = None;
</code></pre>
<ul>
<li><code>Option&lt;T&gt;</code> 枚举以及两个变体被包含在了 prelude 之中，无需将其显式引入作用域</li>
</ul>
<h4 id="match-控制流">match 控制流</h4>
<p>匹配 <code>Option&lt;T&gt;</code> 枚举：</p>
<pre><code class="language-rust">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1), // i 绑定了 Some 中包含的值
    }
}
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>
<ul>
<li>Rust 中的匹配是穷尽的，必须处理所有可能的情况，否则编译器报错</li>
<li>允许使用通配模式（变量）来匹配所有剩余的情况；或者使用 <code>_</code> 通配符来匹配任意值而不绑定到该值。</li>
</ul>
<h4 id="if-let-letelse">if let, let...else</h4>
<p>结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况。</p>
<pre><code class="language-rust">// 工作方式与 match 相同
// if let 模式 = 表达式{...}
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!(&quot;The maximum is configured to be {max}&quot;);
} else {
    // 与 match 表达式中的 _ 分支块中的代码相同
    println!(&quot;The maximum is not configured.&quot;);
}
</code></pre>
<p>let...else 应用的场景：解构+提前返回，如果某个值存在，就对它做一些操作；如果不存在，就返回一个默认值。</p>
<ul>
<li>如果模式匹配，它会将匹配到的值绑定到外层作用域；</li>
<li>模式不匹配，程序流会指向 else 分支，它必须发散（return/break/continue）。</li>
</ul>
<pre><code class="language-rust">fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {
    // 左侧是模式，右侧是要匹配的值
    let Coin::Quarter(state) = coin else {
        return None;
    };

    if state.existed_in(1900) {
        Some(format!(&quot;{state:?} is pretty old, for America!&quot;))
    } else {
        Some(format!(&quot;{state:?} is relatively new.&quot;))
    }
}
</code></pre>
<h2 id="函数与控制流">函数与控制流</h2>
<p>函数只要在模块作用域范围可见就可以使用，不需要先声明后使用。<br>
函数使用 fn 声明，使用尾置形式返回类型：</p>
<pre><code class="language-rust">fn add(a: i32, b: i32) -&gt; i32{
    a+b
}
</code></pre>
<h3 id="ifelse">if/else</h3>
<p>条件表达式必须是 bool 类型，判断条件不需要小括号。<br>
if 表达式可以作为其他语句的一部分，例如赋值：</p>
<pre><code class="language-rust">// 代码块的值是其最后一个表达式的值
let number = if condition { 5 } else { 6 };
</code></pre>
<h3 id="loopwhilefor">loop/while/for</h3>
<pre><code class="language-rust">loop {
    number -= 1;
    if number == 0 {
        break; // break number;  // 可以返回值
    }
}

while number &gt; 0 {
    number -= 1;
}

for i in 0..10{        // 使用 Range 循环特定次数
    println!(&quot;{}&quot;, i);
}
for element in a {    // 遍历集合
    println!(&quot;the value is: {element}&quot;);
}
</code></pre>
<ul>
<li><code>loop</code>无限循环，可以使用<code>break</code>跳出循环，可以带一个值作为循环表达式的值；</li>
</ul>
<h2 id="所有权机制">所有权机制</h2>
<p>Rust 通过所有权机制来管理内存，避免垃圾回收带来的性能开销。每个值在任意时刻都有一个唯一的所有者，当所有者超出作用域时，值会被自动释放。</p>
<ul>
<li>一个值同一时刻只有一个 owner</li>
<li>借用引用 &amp;T 可以有多个，只读</li>
<li>可变引用 &amp;mut T 同时只能有一个</li>
</ul>
<p>Rust 的所有权规则作用在“值”上，不关心它在栈还是堆上分配。类型没有实现 Copy trait 的值在赋值或者作为函数参数传递时会被移动(move)，否则会被复制(copy)。</p>
<p>基础标量类型、原始指针、类型实现了 Copy trait。 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然有效。任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。</p>
<p>Rust 永远也不会自动创建数据的 “深拷贝”；如果确实需要深度复制堆上的数据，可以使用类型的 clone() 方法。</p>
<h3 id="引用与借用">引用与借用</h3>
<p>引用的场景：不转移所有权，可访问储存于该地址的属于其他变量的数据，引用在其生命周期内保证指向某个特定类型的有效值。</p>
<p>创建一个引用的行为称为 借用（borrowing）</p>
<p>创建可变引用（mutable reference）例如 &amp;mut T，才可以修改引用指向的数据。可变引用有一个很大的限制：<strong>如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用</strong>。（避免数据竞争）</p>
<ul>
<li>注意：引用的(实际)作用域<span style="color:#d44c47;font-weight:bold">从创建开始一直持续到最后一次使用它为止</span>，编译器可以在作用域结束之前判断不再使用的引用。
<ul>
<li>技巧：可以使用大括号来创建一个新的作用域（临时作用域），以允许拥有多个可变引用（相当于显式地划分了时间段，非同时拥有），只是不能同时拥有。</li>
</ul>
</li>
<li>编译器确保引用永远也不会变成悬垂引用：引用必须总是有效的，例如返回函数局部变量的引用不被允许。</li>
</ul>
<h3 id="slice">Slice</h3>
<p>切片（slice）引用集合中一段连续的元素序列，它是一种引用，不拥有所有权。<br>
字符串 slice 是 String 中一部分值的引用，字符串切片的类型声明使用 <code>&amp;str</code>:</p>
<pre><code class="language-rust">let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5]; // 可省略起始或结束索引
let world = &amp;s[6..11];
// 索引必须位于有效的 UTF-8 字符边界内
</code></pre>
<p><img
  src="https://kaisery.github.io/trpl-zh-cn/img/trpl04-07.svg"
  alt="ifg"
  style="width: 500px; display: block; margin: auto"
/></p>
<ul>
<li>字符串字面量的变量类型是字符串切片 <code>&amp;str</code>，它是一个指向二进制程序特定位置的 slice。它是不可变引用。</li>
<li><strong>技巧：在设计函数时，优先考虑使用 <code>&amp;str</code> 而不是 <code>&amp;String</code> 作为参数，以提高灵活性和性能。</strong>（<code>&amp;str</code> 参数兼容字符串 slice，也兼容 <code>&amp;String</code>）</li>
</ul>
<h2 id="包-crate-与模块">包、Crate 与模块</h2>
<p>包 package 是一个 Cargo 项目，由 Cargo.toml 描述。一个包可以包含多个二进制 crate 项和<strong>一个可选的库 crate（根文件是 src/lib.rs）</strong>。</p>
<p>crate 是 Rust 编译器的编译单元，可以是二进制 crate 或库 crate。</p>
<p>Module 是 crate 内部的代码组织与命名空间机制，解决命名冲突问题，以及控制代码的可见性（私有/公有）。</p>
<ul>
<li>Cargo 约定：src/main.rs 是一个与包同名的二进制 crate 的 crate 根。同样，如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。</li>
<li>将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。</li>
</ul>
<h3 id="模块">模块</h3>
<p>模块用于将相关代码组织在一起，形成命名空间。一般是内联模块（在同一文件中定义）或者文件模块（在单独的文件中定义）。</p>
<ul>
<li>声明模块使用 <code>mod</code> 关键字，作用是：把一段代码（文件 / 内联模块）挂到 crate 的模块树上(模块树的根模块名叫做 <code>crate</code>，它是一个隐式模块)，编译器会在下列路径中寻找模块代码：
<ul>
<li>内联模块，即在同一文件中使用大括号包含的模块代码；</li>
<li>在文件 src/module_name.rs 中定义的模块（新风格，推荐使用）；</li>
<li>在目录 src/module_name/mod.rs 中定义的模块。</li>
</ul>
</li>
</ul>
<p>可见性：一个模块里的代码默认<strong>对其父模块私有</strong>。为了使一个模块公用，应当在声明时使用 pub mod 替代 mod。为了使一个公用模块内部的成员公用，应当在声明前使用pub。</p>
<p>引入类型/函数等到作用域：使用<code>use</code>关键字，可以将路径引入作用域，简化访问。</p>
<h3 id="引用模块树中的项路径">引用模块树中的项路径</h3>
<p>Rust 使用两种路径类型来引用代码：绝对路径和相对路径。</p>
<ul>
<li>绝对路径：以 crate 根（crate）开始，对于当前 crate 中的代码，使用字面值 <code>crate</code> 开头；对于外部 crate（例如外部库），使用外部 crate 名开头。</li>
<li>相对路径：以当前模块为起点，使用 <code>self</code>（当前模块）、<code>super</code>（父模块）或者当前模块的某个标识符开始（例如子模块名，use 引入的模块名）。</li>
</ul>
<p>引用路径和模块树紧密相关，因为模块树定义了路径的结构。mod 声明不同于 C++ include，只需在模块树中的某处使用一次 mod 声明就可以加载这个文件/模块，然后就可以在模块树中的任何位置使用该模块的路径来引用它。</p>
<p>pub 模块允许其父模块引用它，但是不允许访问内部代码，如果需要访问内部项（结构体、枚举、函数），还需要将这些项声明为 pub。</p>
<p><strong>结构体和枚举的可见性</strong>：结构体定义使用了 pub，该结构体会变成公有的，但是这个结构体的字段仍然是私有的。可以根据情况决定每个字段是否公有。<strong>但是将枚举设为公有，则它的所有变体都将变为公有</strong>。</p>
<h3 id="使用-use-关键字将路径引入作用域">使用 use 关键字将路径引入作用域</h3>
<p>习惯：</p>
<ul>
<li>导入函数时，使用 use 导入父模块路径，可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化；</li>
<li>导入结构体、枚举和其他项时，习惯是指定它们的完整路径</li>
</ul>
<pre><code class="language-rust">// 导入模块
use crate::front_of_house::hosting;

// 导入结构体
use std::collections::HashMap;
</code></pre>
<p>std 标准库是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 Cargo.toml 来引入 std，不过需要通过 use 将标准库中定义的项引入项目包的作用域中来引用它们。</p>
<h4 id="as-的使用">as 的使用</h4>
<p>使用 <code>as</code> 在导入时重命名以避免名称冲突：</p>
<pre><code class="language-rust">use std::fmt::Result;
use std::io::Result as IoResult;
</code></pre>
<h4 id="pub-use-重导出">pub use 重导出</h4>
<p>使用 <code>pub use</code> 语法将导入的项重新导出，使得其他模块可以通过当前模块访问该项。</p>
<p>作用：创建公共 API，简化外部代码对内部复杂模块结构的访问。</p>
<h4 id="使用嵌套路径">使用嵌套路径</h4>
<p>可以使用嵌套路径将相同的项在一行中引入作用域。</p>
<pre><code class="language-rust">use std::{cmp::Ordering, io};

// use std::io;
// use std::io::Write;
// =&gt;
use std::io::{self, Write}; // self 代表 io 模块本身
</code></pre>
<h4 id="glob-导入">glob 导入</h4>
<p>使用 <code>*</code> 通配符将模块中的所有公有项引入作用域，常用于测试模块 tests 中：</p>
<pre><code class="language-rust">use std::collections::*;
</code></pre>
<h2 id="集合">集合</h2>
<p>常用的集合数据类型：<code>Vec&lt;T&gt;</code>，<code>String</code>，<code>HashMap&lt;K, V&gt;</code>（<code>HashSet&lt;K&gt;</code>, <code>LinkedList&lt;T&gt;</code>, <code>VecDeque&lt;T&gt;</code>）。<a href="https://doc.rust-lang.org/std/collections/index.html">https://doc.rust-lang.org/std/collections/index.html</a></p>
<h3 id="vect"><code>Vec&lt;T&gt;</code></h3>
<p><code>Vec&lt;T&gt;</code> (vector) 是一个动态数组，可以存储同类型的多个值，大小可变，存储在堆上。使用：</p>
<pre><code class="language-rust">// 创建一个空的 Vec: 构造函数 new
let mut v1: Vec&lt;i32&gt; = Vec::new();

// 使用宏 vec! 创建并初始化（一系列初始值）
let mut v2 = vec![1, 2, 3]; // 类型推断为 Vec&lt;i32&gt;
</code></pre>
<h4 id="修改">修改</h4>
<pre><code class="language-rust">let mut v = Vec::new();

// 追加元素
v.push(1);
v.push(2);

// 弹出末尾元素
let x = v.pop(); // Some(2)

// 索引赋值
v[0] = 10; // 注意：如果索引越界会 panic

// get_mut 获取可变引用
if let Some(x) = v.get_mut(0) {
    *x = 20;  // 解引用赋值，不会越界
}

// insert 插入元素
v.insert(0, 99) ; // 在索引0位置插入99，后续元素后移

// remove 删除元素并返回
let y = v.remove(0); // 删除索引1位置元素，后续元素前移

// swap_remove 删除元素并返回，但不保持顺序
// 使用末尾元素替换被删除位置
let z = v.swap_remove(0);
</code></pre>
<h4 id="读取元素">读取元素</h4>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];

// 1.通过索引访问，越界会 panic
let third: &amp;i32 = &amp;v[2]; 

// 2.get 方法返回 Option&lt;&amp;T&gt;
// get_mut 返回 Option&lt;&amp;mut T&gt;
let third: Option&lt;&amp;i32&gt; = v.get(2);
    match third {
        Some(third) =&gt; println!(&quot;The third element is {third}&quot;),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
</code></pre>
<h4 id="遍历元素">遍历元素</h4>
<pre><code class="language-rust">let v = vec![100, 32, 57];
for i in &amp;v { // (&amp;v)的不可变引用遍历
    println!(&quot;{i}&quot;);
}

for i in &amp;mut v { // (&amp;mut v)的可变引用遍历
    // i: &amp;mut i32
    *i += 50; // 解引用赋值
}

// 也可以直接遍历元素（模式匹配 let &amp;i = ...）
// &amp;v: 迭代器 Item 类型是 &amp;i32，
// 使用 &amp;i 解构得到 i32 类型的值（必须可复制）
for &amp;i in &amp;v {
    // i: i32
    println!(&quot;{i}&quot;);
}

</code></pre>
<h4 id="使用枚举存储多种类型数据">使用枚举存储多种类型数据</h4>
<p>结合 Vec 和枚举，可以创建储存不同类型值的集合（枚举的成员都被定义为相同的枚举类型，但可以携带不同数据）。</p>
<pre><code class="language-rust">// 表格一行的列包含数字，浮点值，字符串
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
</code></pre>
<p>在编写程序时不能完全知道运行时会储存进 vector 的所有类型时，可以使用 trait 对象。</p>
<p>vector 在其离开作用域时会被释放，所有其内容也会被丢弃。</p>
<h3 id="string">String</h3>
<p>字符串（String）类型由 Rust 标准库提供，是一种可增长的、可修改的、拥有所有权的 UTF-8 编码字符串（字符串是作为字节集合外加一些方法实现）。</p>
<pre><code class="language-rust">// 创建String
let mut s = String::new(); // 同 Vec&lt;T&gt;

// 任何实现了 Display trait 的类型都可以使用 to_string() 方法来创建 String
let s = &quot;initial contents&quot;.to_string(); // 比如字符串字面值

// 使用 String::from() 函数创建
let s = String::from(&quot;initial contents&quot;);
</code></pre>
<h4 id="更新字符串">更新字符串</h4>
<pre><code class="language-rust">let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;); // push_str() 方法追加字符串切片 &amp;str
s.push('!');      // push() 方法追加单个字符
</code></pre>
<p>拼接字符串：</p>
<pre><code class="language-rust">// 使用 + 操作符拼接字符串
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用
</code></pre>
<p>说明：<code>+</code> 运算符的第一个参数是 String 类型，第二个参数是字符串切片 <code>&amp;str</code> 类型（通过解引用强制转换将 &amp;String 转换为 &amp;str，效果就是 <code>&amp;s2</code> 转换为 <code>&amp;s2[..]</code>）。<code>+</code> <strong>运算符会获取第一个参数的所有权</strong>并返回一个新的 String。Add trait 为 <code>+</code> 运算符重载，内部调用 push_str 方法。</p>
<p>级联多个字符串：</p>
<pre><code class="language-rust">let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

// let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
let s = format!(&quot;{s1}-{s2}-{s3}&quot;); // format! 宏拼接字符串，使用引用不获取所有权
</code></pre>
<h4 id="索引字符串">索引字符串</h4>
<p>Rust 的<span style="color:#d44c47">字符串不支持索引</span>。<br>
String 内部实现是一个 <code>Vec&lt;u8&gt;</code> 的封装，字符串中每个 Unicode 标量值使用 utf-8 编码。因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值。(字符串的长度以字节为单位)</p>
<h4 id="字符串-slice">字符串 slice</h4>
<p>字符串不允许索引，但可以使用切片语法来获取部分字符串。</p>
<p>字符串 slice 是对 String 或字符串字面值的一部分的引用，类型是 <code>&amp;str</code>；但是切片的起始和结束索引必须位于有效的 UTF-8 字符边界内，否则会引发运行时错误:</p>
<pre><code class="language-rust">let hello = &quot;Здравствуйте&quot;;
// s类型: &amp;str
let s = &amp;hello[0..4]; // 正确，前四个字节是有效的 UTF-8
</code></pre>
<h4 id="遍历字符串">遍历字符串</h4>
<p>遍历字符串需要明确表示是字符还是字节：</p>
<pre><code class="language-rust">// 遍历字符串的字符
for c in &quot;Зд&quot;.chars() {
    println!(&quot;{c}&quot;);
}

// 遍历字符串的字节
for b in &quot;Зд&quot;.bytes() {
    println!(&quot;{b}&quot;);
}
</code></pre>
<h3 id="hashmap">HashMap</h3>
<p>需要显示导入 <code>use std::collections::HashMap;</code> 使用：</p>
<pre><code class="language-rust">// 创建HashMap，可以 insert 方法中推断 HashMap 范型类型
use std::collections::HashMap;
let mut scores: HashMap&lt;String, i32&gt; = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
println!(&quot;{:#?}&quot;, scores);

// collect 方法从一个迭代器创建一个 HashMap
let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];
let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();

// 或者
let vec = vec![(String::from(&quot;Blue&quot;), 10), (String::from(&quot;Yellow&quot;), 50)];
let scores: HashMap&lt;_, _&gt; = vec.into_iter().collect();
</code></pre>
<h4 id="插入更新键值对">插入/更新键值对</h4>
<ul>
<li>
<p>insert() 默认会替换相同 key 的旧值，即覆盖旧值；</p>
</li>
<li>
<p>只在键不存在时插入键值对，用 <code>map.entry(key).or_insert(0)</code>；entry() 方法根据键返回一个枚举 Entry，表示键在哈希映射中对应的值是否存在；使用 or_insert() 方法在不存在时插入新值，返回值的可变引用（插入后的值或原值）：</p>
</li>
</ul>
<pre><code class="language-rust">use std::collections::HashMap;

let mut scores = HashMap::new(); // 类型推断
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{scores:?}&quot;);
</code></pre>
<ul>
<li>根据旧值更新，获取可变引用后解引用赋值：</li>
</ul>
<pre><code class="language-rust">use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;
let mut map = HashMap::new();

// 返回一个由空格分隔 text 值子 slice 的迭代器
for word in text.split_whitespace() {
    // *map.entry(word).or_insert(0) += 1;
    // =&gt; 
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
println!(&quot;{map:?}&quot;);
</code></pre>
<p>使用 HashMap 计数时常用的标准写法：</p>
<pre><code class="language-rust">for word in text.split_whitespace() {
    // 累加器的标准写法：
    map.entry(word)
        .and_modify(|v| *v += 1)
        .or_insert(1);
}
</code></pre>
<h4 id="访问-hashmap-中的值">访问 HashMap 中的值</h4>
<ul>
<li>get() 方法返回一个 <code>Option&lt;&amp;V&gt;</code> 类型的值；get_mut() 方法返回一个 <code>Option&lt;&amp;mut V&gt;</code> 类型的值。</li>
<li>contains_key() 方法检查是否包含某个 key。</li>
<li><code>map[key]</code> 语法获取值的引用，如果 key 不存在会 panic。</li>
</ul>
<pre><code class="language-rust">let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name).copied().unwrap_or(0);
// copied 方法来获取一个 Option&lt;i32&gt; 而不是 Option&lt;&amp;i32&gt;
</code></pre>
<p>遍历键值对：</p>
<pre><code class="language-rust">for (key, value) in &amp;scores {
    // key: &amp;String, value: &amp;i32
    println!(&quot;{key}: {value}&quot;);
}

// 可变引用遍历
for (key, value) in &amp;mut scores {
    // key: &amp;String, value: &amp;mut i32
    *value += 10;
}
</code></pre>
<h4 id="所有权问题">所有权问题</h4>
<p>插入数据时：</p>
<ul>
<li>
<p>对于实现了 Copy trait类型例如i32，会复制到 HashMap中；对于拥有所有权的类型会被移动；</p>
</li>
<li>
<p>如果将引用插入到HashMap中，值不会移动，但是要保证被引用指向值的有效性；</p>
</li>
</ul>
<h4 id="hash-函数">Hash 函数</h4>
<p>HashMap 默认使用一种叫做 SipHash 的哈希函数，hasher 是一个实现了 BuildHasher trait 的类型。</p>
<h2 id="错误处理">错误处理</h2>
<p>错误分为可恢复错误和不可恢复错误两种情况；可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。不可恢复的错误，比如数组越界访问，通常是程序逻辑中的 bug，程序无法继续运行下去。</p>
<p>Rust 没有异常机制，使用 Result 和 panic! 宏来处理错误。</p>
<ul>
<li><code>Result&lt;T, E&gt;</code> 枚举用于可恢复错误处理；</li>
<li><code>panic!</code> 宏用于不可恢复错误处理。</li>
</ul>
<h3 id="panic-宏"><code>panic!</code> 宏</h3>
<p>实践中有两种方法会造成 panic: 执行会造成代码 panic 的操作（比如访问超过数组结尾的内容）或者自己显式调用 <code>panic!</code> 宏。</p>
<pre><code class="language-rust">panic!(&quot;crash and burn&quot;);
</code></pre>
<p>release 模式中 panic 时直接终止程序，不会展开栈，程序体积更小。在 Cargo.toml 的 <code>[profile]</code> 部分增加：</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
<h3 id="resultt-e-枚举"><code>Result&lt;T, E&gt;</code> 枚举</h3>
<p><code>Result&lt;T, E&gt;</code> 枚举用于可恢复错误处理，定义在标准库中：</p>
<pre><code class="language-rust">// T: 成功时返回的值类型(Ok变体中的数据类型)
// E: 失败时返回的错误类型(Err变体中的数据类型)
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>注意：与 Option 枚举一样，Result 枚举和其变体也被导入到了 prelude 中，所以不需要指定 <code>Result::</code> 模块路径就可以使用。</p>
<p>在处理（嵌套）Result 时，可以使用闭包方式，避免大量 match 语句嵌套：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    // unwrap_or_else 方法接收一个闭包作为参数(解包否则处理错误)
    let greeting_file = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {error:?}&quot;);
            })
        } else {
            panic!(&quot;Problem opening the file: {error:?}&quot;);
        }
    });
}
</code></pre>
<p>Result 常用方法：</p>
<ul>
<li><code>unwrap()</code>：如果是 Ok，返回包含的值；如果是 Err，调用 panic! 宏。</li>
<li><code>expect(msg: &amp;str)</code>：与 unwrap 类似，如果是 Ok， 返回包含的值；但是在 panic 时提供自定义错误消息（通常是期望的上下文消息）。</li>
</ul>
<h4 id="错误传播">错误传播</h4>
<p>Err 值通常需要传播给调用者，让调用者决定如何处理错误。rust 提供了 <code>?</code> 运算符来简化错误传播（简化使用 match 匹配来<strong>提前返回 Err 值</strong>）：</p>
<blockquote>
<p><code>?</code> 运算符被定义为从函数中提早返回一个值，可以理解是提前返回的语法糖。</p>
</blockquote>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    // 直接对 Result 使用 ? 运算符
    let mut username_file = File::open(&quot;hello.txt&quot;)?;
    let mut username = String::new();
    // 
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}

// 上面的读取文件 std 库提供了函数：
// fs::read_to_string(&quot;hello.txt&quot;) // Result&lt;String, io::Error&gt;
</code></pre>
<p>Result 值之后的 <code>?</code> 运算符，等价与同功能的 match 匹配：</p>
<ul>
<li>如果是 <code>Ok&lt;T&gt;</code>，则提取出值并继续执行后续代码（解包）；</li>
<li>如果是 <code>Err&lt;E&gt;</code>，则立即返回该 Err 值，结束函数执行（将错误值传递给调用者）。</li>
</ul>
<p>错误转换：如果底层函数返回不同的错误类型，需要顶层函数返回一个统一的错误类型，可以使用 <code>From</code> trait 来定义不同错误类型之间的转换关系，<code>?</code> 运算符会<strong>自动调用</strong> <code>From::from</code> 方法来进行转换。</p>
<p>类似与：</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num::ParseIntError;

// 自定义错误类型
#[derive(Debug)]
enum AppError {
    Io(io::Error),
    Parse(ParseIntError),
}

// 为不同错误实现 From
impl From&lt;io::Error&gt; for AppError {
    fn from(err: io::Error) -&gt; Self {
        AppError::Io(err)
    }
}

impl From&lt;ParseIntError&gt; for AppError {
    fn from(err: ParseIntError) -&gt; Self {
        AppError::Parse(err)
    }
}

// 只返回一种错误类型
fn read_and_parse_number(path: &amp;str) -&gt; Result&lt;i32, AppError&gt; {
    let mut file = File::open(path)?;      // io::Error → AppError
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;   // io::Error → AppError
    let number: i32 = contents.trim().parse()?; // ParseIntError → AppError
    Ok(number)
}
</code></pre>
<ul>
<li>
<p><code>?</code> 之后允许直接使用链式调用，其中遇到错误会自动转换并返回（<code>File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut username)?;）</code>；</p>
</li>
<li>
<p><code>?</code> 使用条件：能用 <code>?</code> 的返回类型，必须实现了 <code>std::ops::FromResidual</code> trait，例如 <code>Result&lt;T,E&gt;</code>，<code>Option&lt;T&gt;</code> 类型。注意提前返回时：是把失败值变形返回，例如自动调用 <code>From::from</code> 方法进行转换。</p>
<ul>
<li>在返回 Result 的函数中对 Result 使用 ? 运算符，会提前返回 Err(E)；或者在返回 Option 的函数中对 Option 使用 ? 运算符，会提前返回 None。</li>
</ul>
</li>
</ul>
<h2 id="泛型">泛型</h2>
<p>对于 struct，enum，方法/普通函数都可以定义为泛型：</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
 x: T,
 y: T,
}
impl&lt;T&gt; Point&lt;T&gt; {
 fn x(&amp;self) -&gt; &amp;T {
  &amp;self.x
 }
}

impl Point&lt;i32&gt; {
 fn origin() -&gt; Point&lt;i32&gt; {
  Point { x: 0, y: 0 }
 }
}
</code></pre>
<ol>
<li>
<p>Rust泛型实现与 C++类型，编译时都会进行具体类型替换-单态化;</p>
</li>
<li>
<p>struct 方法可以定义其他的类型参数，与struct是否为泛型无关;</p>
</li>
<li>
<p>对泛型struct的某个具体类型，例如<code>Point&lt;i32&gt;</code>定义方法是对该类型添加的，其他类型参数的Point不具有（与C++偏特化/特化不同）</p>
</li>
</ol>
<p>泛型可以扩展代码的通用性，常见类型都定义为泛型，<code>Option&lt;T&gt;, Result&lt;T, E&gt;</code>等</p>
<h2 id="trait">Trait</h2>
<p>类似与接口概念，告诉编译器某种类型具有哪些特定行为/功能，用来抽象地<strong>定义共享/公共行为</strong>。</p>
<p>一个主要作用就是为泛型类型参数进行约束Trait bounds，指定为实现特定行为的类型。</p>
<p>定义与为类型实现Trait：</p>
<pre><code class="language-rust">pub trait Summary {
 fn summarize(&amp;self) -&gt; String;
}
pub struct Tweet {
 pub username: String,
 pub content: String,
}
// impl
impl Summary for Tweet {
 fn summarize(&amp;self) -&gt; String {
  format!(&quot;{}: {}&quot;, self.username, self.content)
 }
}
</code></pre>
<p>Trait可以定义默认实现。</p>
<p>类型实现Trait必须实现 trait 定义的<strong>所有没有默认实现的方法</strong>，对于有默认实现的，可以<strong>选择重写</strong>该方法；<strong>trait 定义中，(默认)方法可以调用没有默认实现的方法，类型会保证实现这些方法</strong>。</p>
<p>类型实现Trait的条件：</p>
<ol>
<li>
<p>类型或者该 Trait 是在<strong>本地 crate</strong>定义的;</p>
</li>
<li>
<p>即无法为外部类型实现外部的 trait（孤儿规则）</p>
</li>
</ol>
<h3 id="trait作为参数">Trait作为参数</h3>
<p>使用<code>impl Trait</code>或者<code>Trait bound</code>语法：</p>
<pre><code class="language-rust">// impl Trait 修饰参数
pub fn notify(item: impl Summary+Display) {
 println!(&quot;Breaking news! {}&quot;, item.summarize());
}
// 使用泛型 + trait约束
pub fn notify&lt;T: Summary+Display&gt;(item: T) {
 println!(&quot;Breaking news! {}&quot;, item.summarize());
}
// where
pub fn notify2&lt;T, U&gt;(a: T, b: U)
where
 T: Summary + Display,
 U: Clone + Debug,
{
 println!(&quot;Breaking news! {}&quot;, a.summarize());
}
</code></pre>
<h3 id="trait作为返回类型">Trait作为返回类型</h3>
<p>使用<code>impl trait</code>语法：</p>
<pre><code class="language-rust">pub fn news() -&gt; impl Summary {
 Tweet {
  username: String::from(&quot;ebooks&quot;),
  content: String::from(&quot;people&quot;),
 }
}
</code></pre>
<p>限制：</p>
<ul>
<li>需要保证函数返回的类型需要一致，返回确定的同一种类型；</li>
</ul>
<div class="markdown notion" style="padding: 10px; color: #37352f; background-color: #e7f3f8; border-radius: 6px; border:1px solid #dfdfde">
<div style="width: 28px;height: 28px;margin-left: 0px;margin-right: 10px;position: absolute;"><span style="font-size: 18px;">💡</span></div>
<p style="line-height: 28px; margin: 0px 5px 0px 38px !important">Trait 主要用来表示类型约束，其他用法：
在泛型类型的 impl 块上使用 Trait bound，可以为类型参数实现了特定 Trait 的<strong>泛型类型有条件地实现某些方法</strong>；
为实现特定 Trait 的任意类型<strong>有条件地实现另一个 Trait (覆盖实现)</strong></p></div>
<details class="markdown">
<summary><b>示例代码</b></summary>
<pre><code class="language-rust">// 1. 有条件地实现某些方法
impl&lt;T: Display+PartialOrd&gt; Pair&lt;T&gt;{
 fn cmp_display(&amp;self){
  ...
 }
}
// 2. 有条件实现另一个 Trait
impl&lt;T: fmt::Display+?Sized&gt; ToString for T{
 ...
}
</code></pre>
</details>
<h2 id="生命周期">生命周期</h2>
<p>生命周期目的：避免悬垂引用 dangling reference.</p>
<p>Rust中<strong>每个引用都有自己的生命周期</strong>（保持有效的作用域），当生命周期以不同的方式互相关联，需要手动标注生命周期，<strong>使用泛型声明来规范生命周期的名称。</strong></p>
<p>例如函数签名中使用泛型生命周期参数：</p>
<p>可以理解为返回引用的生命周期至少是<code>x,y</code>中较短的生命周期（交集）</p>
<pre><code class="language-rust">fn long_str&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
 if x.len() &gt; y.len() {
  x
 } else {
  y
 }
}
</code></pre>
<ul>
<li>
<p>生命周期标注<strong>不会实际改变引用的生命周期长度</strong>；</p>
</li>
<li>
<p>只是描述了多个引用的生命周期的关系，不影响其生命周期；因此单个生命周期的标注没有意义；</p>
</li>
<li>
<p><code>'static</code>特殊生命周期标识，整个程序的运行时间（例如字符串字面量）</p>
</li>
</ul>
<div class="markdown notion" style="padding: 10px; color: #37352f; background-color: #e7f3f8; border-radius: 6px; border:1px solid #dfdfde">
<div style="width: 28px;height: 28px;margin-left: 0px;margin-right: 10px;position: absolute;"><span style="font-size: 18px;">💡</span></div>
<p style="line-height: 28px; margin: 0px 5px 0px 38px !important">注意：函数返回引用类型，返回类型的生命周期参数需要与一个参数的生命周期匹配（即跟输入参数相关，否则就是悬垂引用）</p></div>
<h3 id="省略规则">省略规则</h3>
<p>Rust<strong>引用分析</strong>中考虑了一些特定模式/生命周期省略规则，符合该模式的代码无需显示标注生命周期。（输入生命周期: 参数为引用的生命周期；输出生命周期：返回值是引用的生命周期）</p>
<p>规则如下：</p>
<ol>
<li>
<p>每个输入**参数(引用类型)**如果省略生命周期，则具有不同的生命周期参数（例如<code>'a,'b,'c</code>）；</p>
</li>
<li>
<p>如果只有一个输入生命周期参数，该生命周期被赋给所有的输出生命周期参数；</p>
</li>
<li>
<p>如果有多个输入生命周期参数，但是其中有一个是<code>&amp;self，&amp;mut self</code>（适用于方法中），那么 self 的生命周期被赋给所有的输出生命周期参数。</p>
</li>
</ol>
<p>应用上述规则后如果不能确定签名中所有引用的生命周期编译器会报错。或者出现不匹配，例如返回值的生命周期与返回类型生命周期不同（示例见<strong>impl块和方法</strong>）。</p>
<h3 id="struct-2">struct</h3>
<p>struct 定义中字段除了基本类型和自拥有类型，其引用类型需要使用生命周期标注：</p>
<pre><code class="language-rust">struct Stu&lt;'a&gt; {
 name: &amp;'a str, // 至少比Stu实例生命周期长
 age: u8,
}
// main
fn main(){
 let name = String::from(&quot;xiaoming&quot;);
 let stu = Stu {
  name: name.as_str(),
  age: 18,
 };
 println!(&quot;{:#?}&quot;, stu);
}
</code></pre>
<h3 id="impl块和方法">impl块和方法</h3>
<p>对于字段的生命周期需要在 imp 块中显示标注：</p>
<pre><code class="language-rust">struct Stu&lt;'a&gt; {
 name: &amp;'a str,
 age: u8,
}
// 对于struct 字段的生命周期标注显示指明/语法类似泛型
// 方法中的生命周期参数可以使用字段声明的，也可以自定义
// &amp;self 方法可以有默认规则
impl&lt;'a&gt; Stu&lt;'a&gt; {
 fn get_age(&amp;self) -&gt; u8 {
  self.age
 }

 fn get_name(&amp;self) -&gt; &amp;str {
  self.name
 }

//fn get_name2(&amp;self, other: &amp;str) -&gt; &amp;str{
// other  // error 引用规则3返回类型的声明周期与 self相同
//}
}
</code></pre>
<h2 id="阅读">阅读</h2>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/title-page.html">https://kaisery.github.io/trpl-zh-cn/title-page.html</a></li>
<li><a href="https://course.rs/rustt.html">https://course.rs/rustt.html</a></li>
<li><a href="https://cheats.rs">https://cheats.rs</a></li>
</ul>
</div>

                <!-- 新加的模块的，应该使用模版-->
                <!-- 版权声明 -->
                
                  <div class="jumbotron">
                    <div class="container">
                      <p>
                        <i class="ri-article-line"></i>
                        <b>本文链接:</b>
                        <a href="https://gh.qxxiao.eu.org/post/Rust基础（一）/" target="_blank">
                          Rust基础（一）
                        </a>
                      </p>
                      <p>
                        <i class="ri-creative-commons-line"></i>
                        <b>版权声明:</b>
                        本博客所有文章除特别声明外，均采用
                        <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">CC
                          BY-NC-SA
                          4.0</a>
                        许可协议，转载请注明出处。
                      </p>
                      <p>
                        <i class="ri-time-line"></i>
                        <b>发布日期:</b>
                        2022-05-28
                      </p>
                      <p>
                        <i class="ri-time-line"></i>
                        <b>最新构建:</b>
                        2026-01-13
                          <!-- 使用 themeConfig.dateFormat 格式对日期格式化，例如YY-MM-DD -->
                          <!-- {
  &#34;content&#34;: &#34;&lt;!-- more --&gt;\n&lt;h2 id=\&#34;2024-10-02\&#34;&gt;2024-10-02&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;添加了代码高亮行的显示，语法：&lt;code&gt;cpp{1,4,7-10}&lt;/code&gt;, 不要有空格&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2024-06-10\&#34;&gt;2024-06-10&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;添加了相册的时间线样式&lt;/li&gt;\n&lt;li&gt;添加了书单页面&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2024-06-09\&#34;&gt;2024-06-09&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;修改了部分样式，去除了多个页面中的 css class: animated fadeIn，避免页面刷新时抖动&lt;/li&gt;\n&lt;li&gt;修改了文章 TOC 目录的宽度样式, 只限制最小/最大宽度，使其能够自适应内容宽度&lt;/li&gt;\n&lt;li&gt;统一 post 文章和 diary/gallary 页面的回到顶部/底部按钮样式和位置&lt;/li&gt;\n&lt;li&gt;简化了 明亮/黑暗模式切换代码，删除了 &lt;code&gt;ldbutton.js&lt;/code&gt;，使用 Vue 来控制样式切换。但刷新会导致页面闪屏，因为 Vue 执行完 mounted 后才会正确计算当前模式；解决：使用 js 函数来提前完成模式的初始化，避免闪屏&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2023-12-20\&#34;&gt;2023-12-20&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;添加&lt;code&gt;时光/说说&lt;/code&gt;功能，数据来源于 Memos\n&lt;ul&gt;\n&lt;li&gt;由于评论部署在 vercel，加载慢，说说评论需要在&lt;a href=\&#34;https://memos.qxxiao.eu.org\&#34;&gt;原始 Memos 页面&lt;/a&gt;打开评论 (更新：添加了页面评论，可以直接在当前页面访问)&lt;/li&gt;\n&lt;li&gt;说说服务器部署在 Azure，可能需要代理才能正常访问&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;将仓库同步到 github，利用 github actions 进行博客同步\n&lt;ul&gt;\n&lt;li&gt;之前使用 Mac 监控脚本同步博客，gridea 每次预览可能会触发导致站点 url 是 localhost，并且有时任务触发不及时&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;添加 &lt;a href=\&#34;https://github.com/kytrun/gridea-search\&#34;&gt;gridea-search 插件&lt;/a&gt;，对应添加了搜索框，调整了一下菜单界面&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2023-12-12\&#34;&gt;2023-12-12&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;更新评论系统 twikoo 版本到 1.6.27&lt;/li&gt;\n&lt;li&gt;更新样式，删除友链菜单，直接在&lt;a href=\&#34;/post/about\&#34;&gt;关于页面&lt;/a&gt;添加，保留了部分 css 样式&lt;/li&gt;\n&lt;li&gt;优化，使用 &lt;code&gt;v-cloak&lt;/code&gt; 避免出现 post 页面的文章目录闪烁问题&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-07-06\&#34;&gt;2022-07-06&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;修改样式，添加暗亮模式切换&lt;/li&gt;\n&lt;li&gt;修改默认样式查询方式，简单样式适配&lt;/li&gt;\n&lt;li&gt;修改代码主题为 &lt;code&gt;vs-dark&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-03-20\&#34;&gt;2022-03-20&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;添加文章列表中的标签的显示，设置标签样式(默认没有 border-indigo-500 等样式)&lt;/li&gt;\n&lt;li&gt;优化布局&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-02-27\&#34;&gt;2022-02-27&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;添加代码样式，增加行号和复制选项&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-02-25\&#34;&gt;2022-02-25&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;修改主题配置，添加友链菜单，优化了页面效果&lt;/li&gt;\n&lt;li&gt;添加导航菜单&lt;/li&gt;\n&lt;li&gt;页面样式移动和修改&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-02-20\&#34;&gt;2022-02-20&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;更新页面样式，添加版权和说明（改变字体可能会导致中文目录不能正确跳转）&lt;/li&gt;\n&lt;li&gt;更新归档页面，添加日期信息和每篇文章的相关描述&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;2022-02-10\&#34;&gt;2022-02-10&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;简单使用 Rocky 主题&lt;/li&gt;\n&lt;li&gt;修改主页信息的描述以及 footer 信息&lt;/li&gt;\n&lt;li&gt;使用 Twikoo 评论&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,
  &#34;fileName&#34;: &#34;log&#34;,
  &#34;abstract&#34;: &#34;&#34;,
  &#34;title&#34;: &#34;更新日志&#34;,
  &#34;tags&#34;: [],
  &#34;date&#34;: &#34;2020-01-05 00:37:45&#34;,
  &#34;dateFormat&#34;: &#34;2020-01-05&#34;,
  &#34;feature&#34;: &#34;&#34;,
  &#34;link&#34;: &#34;https://gh.qxxiao.eu.org/post/log/&#34;,
  &#34;hideInList&#34;: true,
  &#34;isTop&#34;: false,
  &#34;stats&#34;: {
    &#34;text&#34;: &#34;3 min read&#34;,
    &#34;time&#34;: 146000,
    &#34;words&#34;: 662,
    &#34;minutes&#34;: 3
  },
  &#34;description&#34;: &#34;\n2024-10-02\n\n添加了代码高亮行的显示，语法：cpp{1,4,7-10}, 不要有空格\n\n2024-06-10\n\n添加了相册的时间线样式\n添加了书单页面\n\n2024-06-09\n\n修改了部分样式，去除了多个页面中的 css cla...&#34;,
  &#34;toc&#34;: &#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#2024-10-02\&#34;&gt;2024-10-02&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2024-06-10\&#34;&gt;2024-06-10&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2024-06-09\&#34;&gt;2024-06-09&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2023-12-20\&#34;&gt;2023-12-20&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2023-12-12\&#34;&gt;2023-12-12&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-07-06\&#34;&gt;2022-07-06&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-03-20\&#34;&gt;2022-03-20&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-02-27\&#34;&gt;2022-02-27&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-02-25\&#34;&gt;2022-02-25&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-02-20\&#34;&gt;2022-02-20&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2022-02-10\&#34;&gt;2022-02-10&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;
}
                            
                                  2022-05-28
                                     -->
                      </p>
                    </div>
                  </div>
                  
                    <!-- 新加的模块的，应该使用模版-->
                    <!--阅读次数-->
                    
                    <div class="text-center text-gray-400">
                      <i class="ri-eye-line"></i>
                      本文已被阅读
                      <span id="twikoo_visitors">0</span>
                      次，该数据仅供参考
                    </div>
                    

                    <!-- Share to Twitter, Weibo, Telegram -->
                    <div class="flex items-center">
                      <div class="mr-4 flex items-center">
                        <i class="ri-share-forward-line text-gray-500"></i>
                      </div>
                      <div
                        class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex"
                        @click="shareToTwitter">
                        <i class="ri-twitter-line"></i>
                      </div>
                      <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex"
                        @click="shareToWeibo">
                        <i class="ri-weibo-line"></i>
                      </div>
                      <div
                        class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex"
                        @click="shareToTelegram">
                        <i class="ri-telegram-line"></i>
                      </div>
                    </div>
          </div>

          <!-- 新加的模块的，应该使用模版-->
          <!-- 评论说明-->
          <div class="jumbotron-comment">
            <div class="container">
              <p>
                <i class="ri-message-3-line"></i>
                欢迎任何与文章内容相关并保持尊重的评论😊 !
              </p>
            </div>
          </div>

          
                        
                            
                              <div id="tcomment"></div>
                               <footer class="py-12 text-center px-4 md:px-0" v-pre>
  共 44 篇文章 | Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <i class="ri-rss-line"></i><a href="https://gh.qxxiao.eu.org/atom.xml" target="_blank" target="_blank">RSS</a></br>
©2020-2025 <a href="https://gh.qxxiao.eu.org/index.html" target="_blank">September</a>. All rights reserved.
</footer>

<!--没有添加/用到app 中的主题footer配置消息，如果使用，将上面的 href 替换为原地址-->
<!--2020-2025-->

        </div>

        <!-- TOC Container -->
        <div
          class="fixed right-0 bottom-0 mb-40 mr-4 shadow w-10 h-10 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all"
          @click="showToc = true">
          <i class="ri-file-list-line"></i>
        </div>

        <div v-cloak
          class="fixed right-0 top-0 bottom-0 overflow-y-auto w-16-24 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast"
          :class="{ '-mr-64': !showToc }">
          <div class="flex mb-4 justify-end">
            <div
              class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast"
              @click="showToc = false">
              <i class="ri-close-line text-lg"></i>
            </div>
          </div>
          <div class="post-toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F">类型与变量</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B">基础类型</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">复合类型</a>
<ul>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-vect">动态数组 <code>Vec&lt;T&gt;</code></a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%87%E7%89%87">字符串和切片</a></li>
</ul>
</li>
<li><a href="#struct">struct</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93-struct">结构体 struct</a></li>
<li><a href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93tuple-struct">元组结构体（tuple struct）</a></li>
<li><a href="#%E7%B1%BB%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93unit-like-struct">类单元结构体(unit-like struct)</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0">定义方法和关联函数</a></li>
</ul>
</li>
<li><a href="#enum-%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">enum 和模式匹配</a>
<ul>
<li><a href="#%E6%9E%9A%E4%B8%BE-enum">枚举 enum</a></li>
<li><a href="#match-%E6%8E%A7%E5%88%B6%E6%B5%81">match 控制流</a></li>
<li><a href="#if-let-letelse">if let, let...else</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%B5%81">函数与控制流</a>
<ul>
<li><a href="#ifelse">if/else</a></li>
<li><a href="#loopwhilefor">loop/while/for</a></li>
</ul>
</li>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6">所有权机制</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8">引用与借用</a></li>
<li><a href="#slice">Slice</a></li>
</ul>
</li>
<li><a href="#%E5%8C%85-crate-%E4%B8%8E%E6%A8%A1%E5%9D%97">包、Crate 与模块</a>
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E6%A0%91%E4%B8%AD%E7%9A%84%E9%A1%B9%E8%B7%AF%E5%BE%84">引用模块树中的项路径</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-use-%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E8%B7%AF%E5%BE%84%E5%BC%95%E5%85%A5%E4%BD%9C%E7%94%A8%E5%9F%9F">使用 use 关键字将路径引入作用域</a>
<ul>
<li><a href="#as-%E7%9A%84%E4%BD%BF%E7%94%A8">as 的使用</a></li>
<li><a href="#pub-use-%E9%87%8D%E5%AF%BC%E5%87%BA">pub use 重导出</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E8%B7%AF%E5%BE%84">使用嵌套路径</a></li>
<li><a href="#glob-%E5%AF%BC%E5%85%A5">glob 导入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a>
<ul>
<li><a href="#vect"><code>Vec&lt;T&gt;</code></a>
<ul>
<li><a href="#%E4%BF%AE%E6%94%B9">修改</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E5%85%83%E7%B4%A0">读取元素</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0">遍历元素</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%AD%98%E5%82%A8%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE">使用枚举存储多种类型数据</a></li>
</ul>
</li>
<li><a href="#string">String</a>
<ul>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">更新字符串</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AD%97%E7%AC%A6%E4%B8%B2">索引字符串</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice">字符串 slice</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2">遍历字符串</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E6%9B%B4%E6%96%B0%E9%94%AE%E5%80%BC%E5%AF%B9">插入/更新键值对</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE-hashmap-%E4%B8%AD%E7%9A%84%E5%80%BC">访问 HashMap 中的值</a></li>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83%E9%97%AE%E9%A2%98">所有权问题</a></li>
<li><a href="#hash-%E5%87%BD%E6%95%B0">Hash 函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>
<ul>
<li><a href="#panic-%E5%AE%8F"><code>panic!</code> 宏</a></li>
<li><a href="#resultt-e-%E6%9E%9A%E4%B8%BE"><code>Result&lt;T, E&gt;</code> 枚举</a>
<ul>
<li><a href="#%E9%94%99%E8%AF%AF%E4%BC%A0%E6%92%AD">错误传播</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li>
<li><a href="#trait">Trait</a>
<ul>
<li><a href="#trait%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">Trait作为参数</a></li>
<li><a href="#trait%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B">Trait作为返回类型</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a>
<ul>
<li><a href="#%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99">省略规则</a></li>
<li><a href="#struct-2">struct</a></li>
<li><a href="#impl%E5%9D%97%E5%92%8C%E6%96%B9%E6%B3%95">impl块和方法</a></li>
</ul>
</li>
<li><a href="#%E9%98%85%E8%AF%BB">阅读</a></li>
</ul>
</li>
</ul>
</div>
        </div>

        <!-- Back to top -->
        <div v-cloak
          class="fixed right-0 bottom-0 mb-20 mr-4 shadow w-10 h-10 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg dark:bg-gray-500 dark:text-gray-200"
          @click="backToUp" v-show="scrolled">
          <i class="ri-arrow-up-line"></i>
        </div>
        <!-- Back to bottom -->
        <div v-cloak
          class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-10 h-10 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg dark:bg-gray-500 dark:text-gray-200"
          @click="backToBottom" v-show="!atBottom">
          <i class="ri-arrow-down-line"></i>
        </div>
    </div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

      <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
      <script src="https://gh.qxxiao.eu.org/media/scripts/main.js"></script>

      <!-- Code Highlight -->
      
        <script src="https://gh.qxxiao.eu.org/media/prism.js"></script>
        <script>
          Prism.highlightAll();
        </script>
        <script src="https://gh.qxxiao.eu.org/media/scripts/fixcode.js"></script>
        <script defer
          src="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
        <script defer
          src="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/toolbar/prism-toolbar.min.js"></script>
        <script defer
          src="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/show-language/prism-show-language.min.js"></script>
        <script defer
          src="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
        <script defer
          src="https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
        

          <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
          <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
          <script>
            //拿到预览框架，也就是上面的html代码
            var pswpElement = document.querySelectorAll('.pswp')[0]
            //定义图片数组变量
            var imgitems
            /**
             * 用于显示预览界面
             * @param index 图片数组下标
             */
            function viewImg(index) {
              var pswpoptions = {
                index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
                bgOpacity: 0.7, // 背景透明度，0-1
                maxSpreadZoom: 3, // 缩放级别，不要太大
              }
              //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
              var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions)
              gallery.init()
            }
            /**
             * 用于添加图片点击事件
             * @param img 图片元素
             * @param index 所属下标（在imgitems中的位置）
             */
            function addImgClick(img, index) {
              img.onclick = function () {
                viewImg(index)
              }
            }
            /**
             * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
             * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
             * 异步加载图片可在图片元素创建完成后调用此方法
             */
            function initImg() {
              //重置图片数组
              imgitems = []
              //查找class:markdown 下的所有img元素并遍历
              var imgs = document.querySelectorAll('.markdown img')
              for (var i = 0; i < imgs.length; i++) {
                var img = imgs[i]
                //本站相册初始为loading图片，真实图片放在data-src
                var ds = img.getAttribute('data-src')
                //创建image对象，用于获取图片宽高
                var imgtemp = new Image()
                //判断是否存在data-src
                if (ds != null && ds.length > 0) {
                  imgtemp.src = ds
                } else {
                  imgtemp.src = img.src
                }
                //判断是否存在缓存
                if (imgtemp.complete) {
                  var imgobj = {
                    src: imgtemp.src,
                    w: imgtemp.width,
                    h: imgtemp.height,
                  }
                  imgitems[i] = imgobj
                  addImgClick(img, i)
                } else {
                  imgtemp.index = i
                  imgtemp.img = img
                  imgtemp.onload = function () {
                    var imgobj = {
                      src: this.src,
                      w: this.width,
                      h: this.height,
                    }
                    //不要使用push，因为onload前后顺序会不同
                    imgitems[this.index] = imgobj
                    //添加点击事件
                    addImgClick(this.img, this.index)
                  }
                }
              }
            }
            //初始化
            initImg();
          </script>
          
                
                          
                            <script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.36/dist/twikoo.all.min.js"></script>
                            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
                              integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X"
                              crossorigin="anonymous" />
                            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
                              integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
                              crossorigin="anonymous"></script>
                            <script defer
                              src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
                              integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"
                              crossorigin="anonymous"></script>
                            <script>
                              twikoo.init({
                                envId: 'https://twikoo.qxxiao.eu.org/.netlify/functions/twikoo',
                                el: '#tcomment',
                                katex: {
                                  delimiters: [
                                    { left: '$$', right: '$$', display: true },
                                    { left: '$', right: '$', display: false },
                                    { left: '\\(', right: '\\)', display: false },
                                    { left: '\\[', right: '\\]', display: true },
                                  ],
                                  throwOnError: false,
                                },
                                // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数
                                // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数
                              });
                            </script>
                            

                              <!-- line number for code block -->
                              <script>
                                var pres = document.getElementsByTagName('pre')
                                for (var i = 0; i < pres.length; i++) {
                                  var pre = pres[i]
                                  if (pre.childNodes[0].nodeName == 'CODE') {
                                    pre.setAttribute('class', 'line-numbers')
                                  }
                                }
                              </script>
                              

  </body>

</html>