{"themeConfig":{"themeName":"rocky","postPageSize":12,"archivesPageSize":60,"siteName":"Unique's Blog","siteDescription":"温故而知新 <h1>console.log(😊);</h1>","footerInfo":"","showFeatureImage":true,"domain":"https://blog.qxxiao.eu.org","postUrlFormat":"SLUG","tagUrlFormat":"SLUG","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":200,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"content":"内容：简单总结 x86 汇编基础和函数调用的过程，但只涉及可用指令和汇编指令的一小部分，但非常有用。主要采用 GNU 汇编器(GAS) 的 AT&amp;T 语法进行说明。 补充的资料： x86 and amd64 instruction reference CMPT 295 Lecture Notes CS107 Computer Organization &amp; Systems CSAPP CS107 reader 补充阅读 CMU 15-213/15-513 Introduction to Computer Systems CSAPP Compiler Explorer - godbolt.org 1.寄存器 x86 寄存器 x86 处理器有 8 个通用寄存器，如下图，其中 EAX 过去被称为累加器，因为它被许多算术运算使用；ECX 被称为计数器，因为它被用来保存循环索引，然而现在基本上失去了其专有目的，成为通用寄存器。但是 EBP 通常用于栈基指针，ESP 用于栈顶指针。 x86 处理器，通用寄存器是 32 位的，寄存器 EAX、EBX、ECX、EDX 还可以分别访问其低地址的 16 位，和其中的高低字节。如下图中所示。 汇编语言中，寄存器名称是不区分大小写的。 32 位系统中，调用者需要保存的寄存器 caller-saved 有 EAX、ECX、EDX，被调用者 callee-saved 需要保存的寄存器有 EBP、EBX、EDI、ESI。 x86-64 寄存器 x86-64 处理器扩展了上述通用寄存器到 64 位，并增加了一些新的寄存器，如 R8～R15，所以有 16 个 64 位寄存器。但是，为了向后兼容，32 位寄存器仍然可以使用。 所有的 64 位寄存器使用 R 前缀访问，如 RAX、RBX、RCX、RDX 如上图。 如图，寄存器 %rbp, %rbx, 和 %r12-%r15 是被调用者 callee 需要保存的（换句话说，它们属于调用者 caller，调用者假定它们的值不会被修改）。当然，是按照实际使用情况进行保存，如果被调用者使用了这些寄存器，那么需要在函数序幕保存这些寄存器的值，然后在函数结束时恢复这些寄存器的值。 剩余的寄存器，调用者负责保存。 SIMD: MMX, SSE, AVX, AVX-512 此外，还提供了 16 个 SSE 寄存器（xmm0~xmm15），每个寄存器宽度 128 位，以及 8 个 x87 指令浮点寄存器（st(0)~st(7)），每个寄存器宽度 80 位（主要用于早期的浮点计算, 以及 MMX 指令会共享该寄存器）。 Intel AVX(高级向量扩展)提供了 16 个 256 位的 YMM 寄存器（ymm0~ymm15），其低 128 位即对应的 128 位 SSE 寄存器（别名）；AVX-512 扩展提供了 32 个 512 位的 ZMM 寄存器（zmm0~zmm31），其低 256 位对应于 256 位 YMM 寄存器，低 128 位对于 128 位 XMM 寄存器。（因此 xmm16 - %xmm31 / ymm16 - ymm31 只在 AVX-512 扩展中有效） 我们将使用这些寄存器和 SIMD 指令进行浮点运算： 2.汇编语法 https://sourceware.org/binutils/docs/as/index.html GNU 汇编快速入门 这里主要使用 AT&amp;T 语法，它是 GNU 汇编器(GAS) 的默认语法。AT&amp;T 语法的特点是源操作数在前，目的操作数在后，操作数之间用逗号分隔。如下所示： pushq %rbp movq %rsp, %rbp movl %edi, -20(%rbp) movl %esi, -24(%rbp) movl %edx, -28(%rbp) movl -20(%rbp), %eax movl %eax, -4(%rbp) ...... popq %rbp ret 与 Intel 汇编语法的主要区别有：全面的差异 差异 AT&amp;T 语法 说明 Intel 语法 说明 操作数顺序 movq %rsp, %rbp 源操作数在前，目的操作数在后 mov rbp, rsp 目的操作数在前，源操作数在后 指令后缀 movq %rsp, %rbp 指令后缀表示操作数大小，如 q 表示四字操作 mov rbp, rsp 不用后缀，通过寄存器操作数推断大小；内存寻址大小歧义时用 BYTE PTR 等显示标注 寄存器 %rsp 寄存器名称前加 % rsp 寄存器名称不加 % 操作数中的立即数 movq $0x2, %rax 操作数中的立即数前加 $ mov rax, 0x2 不加 $ 内存引用 movq 8(%rsp), %rax 立即数在 () 外面 mov rax, [rsp+8] 立即数在 [] 里面 跳转/call 操作数 je *%rax, callq *%rax 操作数前加 * je rax, call rax 不加 * 注释 # comment 注释符号为 # ; comment 注释符号为 ; 指令后缀 多数指令使用后缀来表示操作数的大小，如： b：byte 表示字节操作，如 movb、addb。 w：word(2 bytes) 表示字操作，如 movw、addw。 l：long/doubleword(4 bytes) 表示双字操作，如 movl、addl。 q：quadword(8 bytes) 表示四字操作，如 movq、addq。 如果可以从操作数中推断出操作数的大小，可省略后缀。如 movq %rsp, %rbp 可以写成 mov %rsp, %rbp，操作数 %rsp 暗示 q，%eax 暗示 l，以此类推。 少数指令例如 movs（符号扩展）、movz（零填充）有两个后缀，第一个表示源操作数位宽，第二个表示目的操作数位宽，例如 movzbl 移动一个字节长度源操作数到一个双字长度目的操作数，高位用 0 填充。 Note: 当目标寄存器是子寄存器时，只有子寄存器范围的字节会被写入更新，但有一个例外：32 位的指令写入时，会将目标寄存器的高 32 位清零，例如 mov $ebx, %ebx 这种看似冗余的指令会进行将 rbx 的高 32 位清零。这里等效 movzlq %ebx, %rbx。 内存寻址（访问） 指令中访问内存的一般形式是： displacement(base,index,scale)displacement(base, index, scale)displacement(base,index,scale) displacement：立即数，表示偏移量。 base：基址寄存器，表示基址。 index：索引寄存器，表示索引。 scale：比例因子，表示索引寄存器的倍数。 例如，−16(%rbp,%rdx,8)=%rbp+(%rdx∗8)−16-16(\\%rbp, \\%rdx, 8) = \\%rbp + (\\%rdx * 8) -16−16(%rbp,%rdx,8)=%rbp+(%rdx∗8)−16。 以写立即数 1 为例说明多种寻址模式： movl $1, 0x604892 # 直接寻址，地址 0x604892 movl $1, (%rax) # 间接寻址，地址为 rax 寄存器的值 movl $1, -24(%rbp) # 基址+偏移，地址为 rbp 寄存器的值减去 24 movl $1, 8(%rsp, %rdi, 4) # 基址+索引*比例+偏移，地址为 rsp + rdi * 4 + 8 movl $1, 0x8(, $rdx, 4) # 索引*比例+偏移，地址为 rdx * 4 + 8 movl $1, 0x4(%rax, %rcx) # 比例假定为1，地址为 rax + rcx + 4 常用指令 常用的指令和寻址方式可以参考：Common instructions and Addressing modes - cheatsheet 主要有数据移动、算术运算/逻辑运算、控制流等。 数据移动 mov：数据传送指令，如 movl %eax, %ebx。 movz: 0 填充(小位宽赋值到大位宽)，如 movzbl (%rdi), %eax, 其中后缀 b 表示字节操作，l 表示双字（双指令后缀）。 movs: 符号扩展(小位宽赋值到大位宽)，如 movsbl (%rdi), %eax, 其中后缀 b 表示字节操作，l 表示双字。 cltq: movs 指令对 rax 寄存器特化指令，将其低 32 位符号扩展到 64 位。 push：将数据压入栈，如 pushq %rbp。具体操作：栈顶指针减去 8，然后将数据写入栈顶。 pop：将数据弹出栈，如 popq %rbp。具体操作：读取栈顶数据，然后栈顶指针加 8。 lea: 取操作数的有效地址，不进行地址解引用，如 lea 8(%rsp), %rax。 算术运算/逻辑运算 许多算术指令同时适用于有符号和无符号类型。例如 add、sub 等。通过操作后设置的标志位可以检测不同类型的溢出。 add：加法，如 addl %eax, %ebx。 sub：减法，如 subl %eax, %ebx。 inc/dec: 自增/自减，如 incl %eax。 neg：取负数，如 negl %eax。 imul：整型有符号乘法，如 imull %eax, %ebx。结果保存在 [EDX:EAX] 中，高 32 位在 EDX 中，低 32 位在 EAX 中。 idiv：整型有符号除法，如 idivl %eax。使用 idiv 之前，需要将被除数放在 EDX:EAX 中。结果的商保存在 EAX 中，余数保存在 EDX 中。 mulss/divss: 标量单精度浮点数乘法/除法 scalar single-precision，如 mulss %xmm1, %xmm2。 mulsd/divsd: 标量多精度浮点数乘法/除法 scalar double-precision，如 mulsd %xmm1, %xmm2。 and/or/xor：按位与/或/异或，如 andl %eax, %ebx。 not：按位取反，如 notl %eax。 shl/shr：逻辑左移/右移,省略源操作数则默认为 1，如 shll $2, %eax。 sal/sar：算术左移/右移，省略源操作数则默认为 1，如 sarl $2, %eax。 控制流指令 eflags 标志寄存器用于存储条件码，条件码是由上一条指令设置的，并且大多数算数指令会更新这些标志。条件码用于控制条件跳转指令。常用的标志位有：ZF（零标志位）、SF（符号标志位）、OF（溢出标志位）、CF（进位标志位）。 OF：溢出标志位，针对有符号数，当结果超出有符号数的表示范围时设置。包括正溢出和负溢出。 CF：进位/借位标志位，针对无符号数，当结果超出无符号数的表示范围时设置。包括无符号加法进位和无符号减法借位。 条件跳转指令和使用的标志位对应如下： TEST 指令：与 AND 指令类似，但是不保存结果，只设置标志寄存器，如 testl %eax, %eax。 CMP 指令：与 SUB 指令类似，但是不保存结果，只设置标志寄存器，如 cmpl %eax, %ebx。与分支指令配合使用。 jmp：无条件跳转，如 jmp label。 call 指令：调用函数，如 call func, 其操作是：将下一条指令的地址压入栈，然后跳转到函数的入口地址。 ret 指令：返回，如 ret。其操作是：将弹出的返回地址加载到指令指针寄存器（RIP）中，从而跳转到函数调用后的下一条指令，继续执行。 leave 指令：恢复栈帧，如 leave。其操作是：将栈帧指针 rbp 的值赋给栈顶指针 rsp(清空当前栈帧)，然后弹出栈帧指针 rbp(恢复原始 rbp, 还原上一个栈帧)。 和标志寄存器相关的指令：有两种常见指令可以读取/响应当前标志寄存器的值 setx：x 是条件占位符，根据条件(x)设置一个字节寄存器为 0 或 1，如 sete %al。 cmovx：条件移动指令，x 是条件占位符，根据条件(x)将源寄存器复制到目的寄存器，如 cmovle %eax, %ebx。 上面命令中的 x 是条件占位符，值及其含义与上图中的条件跳转指令相同。 3.函数调用 为了允许共享代码并简化子程序的使用，程序员通常采用一种通用的调用约定。调用约定是一种关于如何调用和返回例程的协议。例如，给定一组调用约定规则，程序员不需要检查子程序的定义来确定如何将参数传递给该子程序。此外，给定一组调用约定规则，高级语言编译器可以按照这些规则进行编译，从而允许手动编写的汇编语言例程和高级语言例程相互调用。 MacOSX 和 Linux 的 x86-64 调用协议都遵循 SystemV ABI (见参考资料)。 函数参数 ABI 将参数/返回值定义了多种类别，依据寄存器的种类定义为：INTEGER(整型，能够适应于通用寄存器 8B)、SSE(能够适应于单个向量寄存器 8B)、SSEUP（继续利用上次使用的向量寄存器中的高字节部分&gt;8B）、MEMORY（通过栈传递的类型）和其他类型。 函数调用的前 6 个（整型，包括指针）参数通过寄存器传递，传递顺序为 %rdi,%rsi,%rdx,%rcx,%r8,%r9（如图所示 arg1~arg6）。超出部分的参数通过函数栈帧传递。 如果函数有返回值（整型），%rax 用作第一个函数返回值，%rdx 用作第二个函数返回值。浮点数使用 xmm0 作为返回值。 其他一些规则： 如果参数大于 64 字节对象，对应于 MEMORY 类型，通过栈传递。 注意如果返回值是 MEMORY 类型，调用者会自己为返回值分配空间，并使用 %rdi 隐式传递该内存指针作为第一个参数。被调用函数对该内存赋值后，直接返回该指针。 函数栈帧 每个函数在运行时堆栈上都有一个帧。函数栈帧从高地址往低地址方向增长，System V ABI 使用两个寄存器访问函数栈帧：帧指针 %rbp 和栈指针 %rsp。 帧指针 %rbp 指向当前函数栈帧基址(栈底)，栈指针 %rsp 指向当前函数栈帧栈顶。 函数调用的栈帧结构图如下所示： 帧指针 %rbp 用来存取函数栈帧上的数据，例如传递进来的函数参数，或者函数的本地局部变量。 System V ABI 要求最后一个压入栈的函数参数（argument 0）地址需要 16 字节边界对齐，如果有 __m256 类型的参数使用栈传递，则需要 32 字节边界对齐。 可以看出，通过栈传递的其他参数，第一个参数的位置在 %rbp+16, 中间隔着 8 字节的返回地址。在 32 位系统中，第一个参数的位置在 %ebp+8。(只是 32 位系统在参数传递和寄存器保存上有所不同) 栈红区（red zone）优化：红区是栈上 rsp 指向位置之后的 128 字节区域。该区域在函数调用时被认为是保留的，期间不被信号处理程序和中断处理程序修改，从而保护了函数栈的完整性。所以函数可以安全地使用这个区域来存储临时数据。 可用于优化函数调用：叶函数（即不调用其他函数的函数）可以利用红区作为整个栈帧的一部分，而不必在函数入口/序言和退出/结尾时调整栈指针（直接使用 rsp 寻址，并且不显示地调用 subq $N, %rsp 分配空间，直接使用栈红区作为整个栈帧）。这可以减少栈操作的开销，提高函数调用的性能。 函数调用协议 函数调用协议分为 caller 端和 callee 端，每端各有两个重要步骤： 1）caller 调用者： 【保存 caller-save 寄存器到函数栈上（按需保存）】； 将函数参数存储到规定的寄存器中，并将超出约定的参数按顺序压入栈中；(32 位系统中，通常仅用栈传递参数，参数按照从右到左的顺序依次压栈) 调用 call 指令。（先压入返回地址，再跳转执行） 2）callee 被调用者，函数序言： pushq %rbp 压入 rbp 寄存器，用来保存前一个栈帧基址； movq %rsp, %rbp 初始化 rbp 寄存器，用来指向当前栈帧基址；（新的 rbp 常用于寻址参数/局部变量） 为局部变量分配空间，subq $N, %rsp； 【保存 callee-save 寄存器到函数栈上（按需保存）】 3） callee 被调用者，函数尾声： 函数体执行完毕后，需要执行以下步骤： 将函数返回值置入 rax 中（浮点数置入 xmm0）； 【如果保存了 callee-save 寄存器，使用 popq 倒序从栈帧中恢复寄存器 】； 释放当前函数的栈帧空间，movq %rbp %rsp 先回退栈顶指针 %rsp，popq %rbp 再恢复原基址指针 %rbp。（两个操作，合并等效为 leave 指令）； ret 指令，弹出返回地址，执行流回到 caller 。 4）caller 调用者： 如果为函数参数额外分配了栈空间，则在此时需要释放这些空间。 【如果保存了 caller-save 寄存器，popq 倒序从栈帧中恢复，释放这些空间】； 至此，一个完整的函数调用过程完成。函数执行的结果一般位于寄存器 rax 中，如果是浮点数，位于在 xmm0 中。 说明： 浮点数，使用浮点寄存器 xmm0~xmm7 传递参数，返回值使用 xmm0~xmm1。 如果是对象作为返回值(对应为 MEMORY 类型时)，会隐式传递其指针作为第一个参数。函数内直接修改这个指针指向的内存。 4.GDB GDB Quick Reference - cheatsheet GDB 常用基础命令 参考资料 x86 Assembly Guide Guide to x86-64 System V Application Binary Interface #PDF 在线编译器 GodBot MIPS MIPS（Microprocessor without Interlocked Pipeline Stages）是一种精简指令集计算（RISC）架构，广泛应用于嵌入式系统、网络设备以及教育领域。它的设计强调简洁性和高效性，所有指令的长度固定为 32 位（部分版本支持 16 位压缩指令）。 MIPS 有32个通用寄存器： 函数调用： 参数传递：通过 $a0-$a3（MIPS32）或 $a0-$a7（MIPS64）传递前 4 或 8 个参数，更多参数通过栈传递。 返回值：通过 $v0 和 $v1 返回函数结果。 调用者 Caller 保存寄存器：$t0-$t9 被调用者 Callee 保存寄存器：$s0-$s7 mips assembly lecture - by nju RISCV RISC-V 是一种基于精简指令集（RISC）的开源指令集架构（ISA），其设计具有模块化、灵活性和跨平台支持的特点。基础指令集（如 RV32I、RV64I）只提供最基本的操作，其他功能通过扩展模块实现，例如： M 扩展（整数乘除法）：支持整数的乘法和除法操作。 F 扩展（单精度浮点数）：支持浮点运算。 D 扩展（双精度浮点数）：扩展浮点运算到双精度。 C 扩展（压缩指令集）：减少指令长度，提高代码密度。 V 扩展（向量处理）：支持高效的数据并行计算。 RV32I 有32个通用寄存器: 由调用者 Caller 负责保存和恢复，临时寄存器：t0-t6 由被调用者 Callee 负责保存和恢复，保存寄存器：s0-s11 参数寄存器: a0-a7 riscv progrmming book ","tags":[{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"汇编基础和函数调用ABI","feature":"https://pic.qxxiao.cn/cpp-logo.png","link":"https://blog.qxxiao.eu.org/post/汇编基础和函数调用ABI/","stats":{"text":"18 min read","time":1022000,"words":4491,"minutes":18},"date":"2024-07-23 10:57:00","dateFormat":"2024-07-23","isTop":false},{"content":"常见的网络命令 1. 网络配置管理 ip 命令 说明：是 net-tools 包中的 ifconfig(网卡信息管理), arp(arp 缓存表的管理), route(路由表的管理) 等命令的替代品。但该软件包在 2001 年已经停止维护，取而代之的是 iproute2 包。 帮助命令：ip help 或 ip addr help ... ip addr [subcommand]：显示和配置网络设备的 IP 地址。 ip addr show: 显示网络设备的 IP 地址。 ip addr add: 添加 IP 地址。 ip addr del: 删除 IP 地址。 ip addr flush: 清空所有网络接口的 IP 地址。 ip link [subcommand]：显示和配置网络设备/接口的状态。 ip link show: 显示网络设备的状态。 ip link set: 设置网络设备的状态。 ip link add: 添加网络设备。 ip link del: 删除网络设备。 ip route [subcommand]：显示和配置路由表。 ip route show: 显示路由表。 ip route add: 添加路由。格式：ip route add &lt;目标网络&gt; via &lt;网关地址&gt; dev &lt;接口&gt;，添加默认路由：ip route add default via &lt;网关地址&gt; dev &lt;接口&gt;。 ip route del: 删除路由。格式：ip route del &lt;目标网络&gt;。 ip route change: 修改路由。格式：ip route change &lt;目标网络&gt; via &lt;网关地址&gt; dev &lt;接口&gt;。 ip route flush: 清空路由表。 2. 连通性探测 ping: 发送 ICMP 报文到目标主机，测试网络连通性。 如果服务器禁用了 ICMP 协议，可以使用 telnet 或 nc 命令测试端口连通性。 telnet: 连接到远程主机的指定端口，进行远程登录和交互操作。 语法：telnet &lt;主机名/IP&gt; &lt;端口号&gt;。注意，该协议是明文传输。 traceroute：跟踪数据包到达目标主机的路径。 语法：traceroute &lt;主机名/IP&gt;。 3. 网络连接情况 ss 命令 查看网络连接情况，包括 TCP、UDP、RAW(直接访问网络层)、UNIX 等连接，是 netstat 命令的替代命令。 语法：ss [options]，常用 ss -npatu。 -t：只显示 TCP 连接。 -u：只显示 UDP 连接。 -x：只显示 UNIX 域套接字连接。 -a：显示所有连接。 -n：显示数字形式的 IP 地址和端口号。 -l：显示监听状态的连接。 -p：显示进程信息。 -4：只显示 IPv4 地址。 -6：只显示 IPv6 地址。 lsof 命令 查看系统打开的文件，包括网络连接、文件描述符等。 lsof -i：显示网络连接情况。 lsof -i:&lt;端口号&gt;：显示指定端口的网络连接情况（打开的文件）。 lsof -U：显示 UNIX 域套接字连接情况。 lsof -p &lt;进程ID&gt;：显示指定进程打开的文件。 4. 流量统计 ifstat 命令 用于显示网络接口的流量统计信息。 iftop 命令 用于实时监控每个连接网络流量和速率。 5. 域名相关 host 命令 查询 DNS 服务器，获取域名对应的 IP 地址等等。 语法：host &lt;域名&gt;。 dig 命令 类似 nslookup 命令，用于查询 DNS 服务器，获取域名对应的 IP 地址等等。 dig google.com # 查询域名对应的 IP 地址 dig -x 8.8.8.8 # 查询 IP 地址对应的域名 dig example.com TXT # 查询域名的 TXT 记录 dig example.com NS # 查询域名的 NS 记录 dig example.com MX # 查询域名的 MX 记录 dig @8.8.8.8 example.com # 指定 DNS 服务器查询域名 dig +trace example.com # 追踪 DNS 解析过程 6. 抓包工具 tcpdump 命令 参考：https://www.comparitech.com/net-admin/tcpdump-cheat-sheet/ 其它命令 Linux 常用命令 Linux 常用单行命令/简单脚本 netcat 是一个网络工具，用于连接 TCP/UDP 端口，发送文件，扫描端口等。 nmap 是一个网络扫描工具，用于扫描主机开放的端口，检测主机的操作系统等。 ","tags":[{"name":"Linux","slug":"linux","used":true,"link":"https://blog.qxxiao.eu.org/tag/linux/"}],"title":"Linux网络命令","feature":"","link":"https://blog.qxxiao.eu.org/post/Linux网络命令/","stats":{"text":"4 min read","time":234000,"words":966,"minutes":4},"date":"2024-06-06 19:44:59","dateFormat":"2024-06-06","isTop":false},{"content":"译：https://hashnode.com/post/delta-compression-a-practical-guide-to-diff-algorithms-and-delta-file-formats-ckcbslwu9001281s1acm2fhz2 Diff 算法（差分算法） 目的和用途 差分算法的输出称为 patch 或 delta。delta 格式可能是人类可读文本格式，也可能是机器可读二进制格式。人可读格式通常用于跟踪和调节对源代码等人可读文本的修改。二进制格式通常经过空间优化，用于节省带宽。与传输所有新数据相比，它只传输对接收方已有数据旧版本的一系列更改。这种格式的正式术语是 delta 编码。 二进制 vs. 文本？ 差分算法可以处理任何输入，只要输入可以被简单地视为一串字节。这个字符串可以是英文字母，也可以是不透明的二进制数据。 diff/merge 工具产生的文本 diff 输出有基于行、基于字和基于字符的分类。基于行/字/字符并不是差分算法本身的特征；相反，它是在输入到实际差分算法之前对输入进行的优化。由于新行和空格在人类可读文本中具有分隔符的意义，因此差分工具可以根据文本中行或词的哈希值分割字符串。这种哈希字符串比原始文本短得多，因此可以节省时间，但代价是降低了差异的粒度。此外，在某些情况下，基于行的粒度甚至会提高差异的可读性。 如果已知输入是不透明的二进制数据，则既没有有意义的分隔符，也没有人类可读的差值可显示，因此无法应用这种优化。因此，能够在输入之前优化人类可读数据的算法很容易被误认为完全无法处理二进制数据。但事实仍然是：除了预处理优化，二进制数据和人类可读数据都可以被视为字节字符串输入，并很容易处理。 三代 diff 差分算法 字符串到字符串的更正或插入/删除 第一代 diff 算法解决了字符串到字符串的校正问题，出现于上世纪六七十年代。两个输入中的每一个都被解释为由某个字母表中的字符组成的字符串。输出是字符编辑序列，最常见的是插入/删除操作，可应用于其中一个输入，将其转换为另一个输入。因此，这类算法特别适合在人类可读的输入上生成人类可读的差异，例如，随着时间的推移进行实际编辑而产生的同一文本/源代码的不同版本。理论上，通常在实践中，完成任务的最小长度编辑操作序列不止一个。可以使用各种启发式方法来选择最接近实际人工编辑的编辑序列。 Wagner-Fischer 算法为这一代差异算法奠定了基础。Myers Algorithm 是这一代算法的最新改进和事实上的标准，目前被包括 GNU diff 工具在内的多种 diff 工具所采用。这一代算法通常会找到最长公共子序列或最小编辑距离（通常是 Levenshtein 距离），并利用它们生成将一个输入转化为另一个输入所需的编辑序列。 块移动或复制/插入 单纯的块移动 与上一代相比，下一代差异算法进行了看似微小的优化。字符编辑升级为字符块编辑。也就是说，差异不再用对单个字符的操作来表示，而是用对字符块的操作来表示。这种操作通常是复制和插入，即在两个输入中都出现的数据块被记录在 delta 中，从一个输入复制到另一个输入。其中一个输入中独有的数据块被记录为插入。这种方法最早由 Walter Tichy 提出。 基于压缩的区块移动 从复制数据块的角度来考虑差异生成，并注意同一数据块是否重复多次，这就为使用压缩算法生成 diff 和 delta 文件打开了大门。 压缩算法就是这样做的：找出尽可能大的重复数据块，并将每个连续出现的数据块替换为第一次出现的数据块。从不重复的数据块则直接复制到输出端。压缩算法本质上是数据块移动算法。 如果对差分算法的两个输入数据都进行压缩算法的数据块移动分析，就能很容易地找出两个输入数据的共同部分。它还会指出哪些数据块是唯一的，即在两个输入中都是不同的。有了这些数据后，就可以直接提出一个数据块复制/删除操作序列，将其中一个输入转换为另一个输入。 使用压缩算法的主要好处是大大减少了 delta 的大小。一个数据块在 delta 中出现的次数绝不会超过一次。它可能会被多次引用，但数据块的实际数据只会在 delta 中出现一次。这是与前面几种方法的主要区别。还应该提到的是，delta 大小的减少是以降低人类可读性为代价的。 xDelta、zDelta、Bentley/McIlroy 是这一代差分算法广泛使用的事实上的标准实现。 最新升级 这是最新一代的差分算法。它的大多数成员只存在于研究论文中，还没有任何商业实现。它们在很大程度上基于分块移动方法，但在实现上进行了大量优化，与上一代相比，速度据称提高了两位数。 这些优化主要侧重于在两个输入中高效地找到匹配的数据块。为实现这一目的，使用了各种增量散列或类似压缩的技术（如后缀树）。 edelta、ddelta、bsdiff 可以归类到这一代的差异算法中。 目前使用的 Delta 生成算法 截至 2019 年 6 月可用的、专注于高效生成 delta/patch 文件的工具和库。 Myers Algorithm Myers 算法属于字符串校正系列，广泛应用于各种工具，这些工具经过微调，可以从人类可读的输入中生成人类可读的 delta/patch 文件。Git Diff 和 GNU Diff 等工具就使用了这种算法。 算法最初的时间和空间复杂度为 O(ND)O(ND)O(ND)，其中 N 是两个输入的长度之和，D 是将一个输入转换为另一个输入的最小编辑脚本的大小。当差异数较少时，如编辑相同的代码/文本文件，该算法速度很快。对迈尔斯算法进行了各种优化后，时间和空间分别提高到 O(NlgN+D2)O(NlgN + D^2)O(NlgN+D2) 和 O(N)O(N)O(N)。 Bentley-McIlroy Bentley-McIlroy 算法属于块移动系列，主要用于生成最佳大小的 delta/patch 文件。该算法在不同的平台和语言上有不同的实现方式，因此可以被认为是 delta 大小重要的情况下的一种事实上的标准。谷歌的 Open VCDiff 是 Bentley-McIlroy 最突出的应用之一，它能够生成 VCDiff 格式的 delta/patch 文件。 算法的时间复杂度为 O(sqrt(N)×N)O(sqrt(N)\\times N)O(sqrt(N)×N)，尽管作者声称在平均情况下是线性复杂度。内存复杂度为线性。 XDelta XDelta 算法属于分块移动算法系列，主要关注 delta 生成的速度。为了提高速度，该算法牺牲了 delta 的大小。xdelta delta 生成工具是 XDelta 的最主要用途，也能生成 VCDiff 格式的 delta/patch。 XDelta 算法具有线性时间和空间复杂性。 BSDiff BSDiff 算法属于块移动系列，主要用于实现最小的 delta/patch 大小。它还专门针对可执行文件进行了优化。bsdiff 工具是 BSDiff 算法最主要的应用。bsdiff 工具使用自己定制的 delta/patch 文件格式。 BSDiff 的时间复杂度为 O((n+m)log(n))O((n+m)log(n))O((n+m)log(n))，其中 n 和 m 是两个输入的大小。其内存复杂度为 max⁡(17n,9n+m)+O(1)\\max(17n,9n+m)+O(1)max(17n,9n+m)+O(1)。 Delta 文件格式 就 delta/patch 文件而言，问题更多在于缺乏标准。许多差异工具和库都以各自的自定义格式生成 delta/patch 文件，因此只有补丁的制作者才能应用它。 在这种情况下，历史上出现了两种主要的 delta/patch 格式标准化尝试。 Unix .patch 这是由 GNU diff 工具生成的 delta/patch 格式系列，旨在提高人类的可读性。GNU diff 工具存在已久，这些补丁格式被各种文本处理工具和源码控制系统广泛接受/使用，无论是否经过修改。 VCDiff VCDiff 是在创建数据无关、算法无关的 delta/patch 格式方面最突出的尝试，旨在实现应用的紧凑性和速度。VCDiff 因谷歌的 SDCH（Shared Dictionary Compression for HTTP，HTTP 共享字典压缩）而获得广泛采用。如今，多种差异算法实现都能生成 VCDiff 格式的 delta/patch 文件。VCDiff delta 应用程序库的成熟度各不相同，适用于大多数流行语言和平台。 参考 https://github.com/jmacd/xdelta https://github.com/google/open-vcdiff ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"Delta 压缩","feature":"","link":"https://blog.qxxiao.eu.org/post/Delta 压缩/","stats":{"text":"9 min read","time":529000,"words":2456,"minutes":9},"date":"2024-05-26 13:00:00","dateFormat":"2024-05-26","isTop":false},{"content":"通过保留相似性实现外包存储系统的加密增量压缩 摘要：将存储外包到云端可以减轻存储容量的压力，其中加密重复数据删除常用于对加密数据进行重复数据删除，以确保存储效率和安全性。然而，加密重复数据删除只去除重复的加密数据，而没有考虑非重复但非常相似的数据。在本文中，我们提出了 EDelta，这是第一个能够在加密重复数据删除之上，通过保留加密后相似性来实现加密增量压缩，从而进一步减少相似加密数据冗余的方法。我们还提出了两种方法来加速加密增量压缩的加密过程。我们在云环境中原型化了 EDelta，并基于真实世界数据集的实验结果表明，EDelta 可以在加密重复数据删除的基础上实现高达 45.0%的额外数据减少率。 引言 加密重复数据删除可以使用从相同内容中生成的相同密钥对重复的明文块进行加密，这样它们对应的密文块也是相同的，因此可以进行重复数据删除。 尽管重复数据删除加密技术已得到广泛应用，但它只能删除重复的密文块，而不能删除相似的密文块，而相似的密文块在实际存储系统中占很大比例 [12-14]。Delta 增量压缩的补充技术可以在重复数据删除技术之上使用，该技术首先检测数据块的相似性，然后通过存储相似数据块的差异来消除数据冗余，以进一步减少相似数据块的冗余。然而，现有的研究只考虑了在常规重复数据删除之上的增量压缩，而没有考虑加密的重复数据删除。因此，我们提出以下问题：在已经部署了加密重复数据删除的外包存储系统（OSS）中，我们能否继续使用增量压缩以提高存储效率？ 发现增量压缩不能直接应用于加密的重复数据删除。主要原因是，由于客户端上的内容不同，两个相似的明文数据块很可能会有完全不同的密钥，因此它们对应的密文数据块也变得完全不同，并在加密后破坏了相似性（详见§II-B），因此无法在云端启用增量压缩。 提出了 EDelta，它可以在加密重复数据删除的基础上实现 delta 增量压缩（称之为加密 delta 增量压缩），其方法是利用基于按位异或的加密重复数据删除操作和基于最大哈希值的密钥来在加密过程中保持相似性。贡献在于： 提出了外包存储系统的**加密增量压缩（称为 EDC）**问题 提出了 EDelta，它通过基于两个提出的定理来保持相似性，实现了加密的增量压缩，并通过两种提出的方法来提高加密性能 实验表明，EDelta 在现有的加密重复数据删除方法基础上，将数据减少率提高了最多 45.0% 背景与挑战 重复数据删除 重复数据删除比传统压缩方法的扩展性更好[16]，特别适用于具有高冗余度的备份/存档应用[17]，而这正是 OSS 典型应用场景。 加密重复数据删除 加密重复数据删除是在加密块上执行重复数据删除，为了提高存储效率和安全性，OSS 对加密重复数据删除进行了广泛研究[6-11]。 基于 MLE 加密去重的的加密过程（如 Convergent Dispersal [20]）： Delta 增量压缩 Delta 增量压缩是备份/归档应用中的另一种流行数据压缩技术【12-14, 21, 22】。它通过消除非重复但高度相似的数据块之间的冗余来实现压缩。 例如，如果两个数据块 P1 和 P2 相似，Delta 压缩只存储 P1（基础块）、它们之间的差异（Δ2,1 = P2 − P1）以及它们之间的映射信息。 对于 Delta 压缩，识别相似数据块的相似性检测是关键步骤。通常基于计算每个数据块的超级特征（super-features，SF）[21, 23, 24]，它由基于 Rabin 指纹计算的多个特征组成。例如，用一个滑动窗口来计算块的特征 Featurei\\text{Feature}_iFeaturei​ 为： Featurei=Maxj=1L{(mi⋅Rabinj+ai) mod 232}\\text{Feature}_i=\\text{Max}_{j=1}^L\\left\\{\\left(m_i \\cdot \\text {Rabin}_j+a_i\\right) \\bmod 2^{32}\\right\\} Featurei​=Maxj=1L​{(mi​⋅Rabinj​+ai​)mod232} 基于 Broder 定理[23, 25]，可以利用数据块的超级特征 SF 来检测高度相似的数据块，该定理暗示了两个集合具有相同最大（或最小）哈希元素的概率与它们的相似度相同[26]。基于这个定理，具有共同的超级特征（即多个特征组成的组）的两个数据块 P1 和 P2 很可能是非常相似的。Delta 增量压缩例子： 挑战 消息锁定加密 MLE 从相似的数据块中生成不同的密钥。 加密哈希函数表现出雪崩效应，这意味着即使输入数据发生微小变化，例如修改一个比特或字节，都会导致输出哈希值大不相同。因此，相似的明文块将以极高的概率产生两个完全不同的加密哈希值。 按位异或加密使用不相似的密钥会破坏相似性。 如果两个相似的明文块生成了两个不相似的密钥，那么当前者与后者进行按位异或加密时，相应的密文块显然不相似，这意味着 MLE 加密后相似性未得到保留。 基于上述两个原因，通过在加密后保留相似性来解决实现 EDC 过程中的挑战。 设计 设计了 EDelta 外包存储系统，实现了加密增量压缩（称为 EDC），在加密去重之上进一步减少了冗余，具有以下设计目标： 保留相似性，以实现 EDC 证明：如果存在从多个相似的明文块中生成一个相同的哈希密钥，那么相似的明文块会加密成相似的密文块。 证明：相似的明文块很可能具有相同的最大哈希值，这可以作为它们的相同密钥，在 EDC 中保留其相似性。 加速 EDC 的加密过程 A. 通过最大哈希密钥保留相似性 主要思想：基于按位异或的加密提供了保持相似块之间相似性的潜力，这意味着如果我们使用相同的哈希值来加密两个相似的块，那么相似明文块的相同部分将在密文块中保持一致，这得益于按位异或的帮助。例如： 定理 1：通过相同密钥，对相似明文块 P1,P2,…,PnP_1,P_2,\\dots, P_nP1​,P2​,…,Pn​ 进行按位异或加密得到的密文块 C1,C2,…,CnC_1,C_2, \\dots, C_nC1​,C2​,…,Cn​ 仍然相似。 定理 1 通过相同密钥加密后可以保持 n 个相似明文块的相似性，从而解决原因 2 带来的挑战。由于原因 1，从 n 个相似块生成相同密钥仍然具有挑战性。 Broder 定理暗示了两个块的相似性与它们的最大哈希值高度相关，这激励我们将 Broder 定理从 2 个相似块扩展到 n 个相似块。自然地问：n（n &gt; 2）个相似块的相似性是否也与它们的最大哈希值高度相关？ 定理 2：考虑 nnn 个集合 A,B,…,NA,B,\\dots,NA,B,…,N，其中 H(A),H(B),…,H(N)H(A),H(B),\\dots,H(N)H(A),H(B),…,H(N) 是分别从 A,B,…,NA,B,\\dots,NA,B,…,N 集合元素生成的哈希值的集合，其中 HHH 是从一个最小值独立排列族中均匀随机选择的。令 max(S)max(S)max(S) 表示集合 SSS 的最大元素。那么： Pr⁡[max⁡{H(A)∪…∪H(N)}∈H(A)∩…∩H(N)]=∣A∩…∩N∣∣A∪…∪N∣\\operatorname{Pr}[\\max \\{H(A) \\cup \\ldots \\cup H(N)\\} \\in H(A) \\cap \\ldots \\cap H(N)]=\\frac{|A \\cap \\ldots \\cap N|}{|A \\cup \\ldots \\cup N|} Pr[max{H(A)∪…∪H(N)}∈H(A)∩…∩H(N)]=∣A∪…∪N∣∣A∩…∩N∣​ ","tags":[{"name":"ED","slug":"ed","used":true,"link":"https://blog.qxxiao.eu.org/tag/ed/"},{"name":"Paper","slug":"paper","used":true,"link":"https://blog.qxxiao.eu.org/tag/paper/"}],"title":"Enabling Encrypted Delta Compression for Outsourced Storage Systems via Preserving Similarity","feature":"","link":"https://blog.qxxiao.eu.org/post/Enabling Encrypted Delta Compression for Outsourced Storage Systems via Preserving Similarity/","stats":{"text":"8 min read","time":476000,"words":2171,"minutes":8},"date":"2024-05-25 13:14:00","dateFormat":"2024-05-25","isTop":false},{"content":"Leetcode 算法题分析 数组和字符串 Leetcode 189. 轮转数组 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 解法 1，利用多次翻转实现 容易理解的做法。使用一个具体数组进行模拟，关注最后 (k mod n)(k \\bmod n)(kmodn) 个元素的位置移动后的位置，利用数组翻转来改变元素的位置关系。 先将所有元素翻转，这样尾部的 (k mod n)(k \\bmod n)(kmodn) 个元素就被移至数组头部 然后再翻转区间 [0,(k mod n)−1][0, (k \\bmod n) - 1][0,(kmodn)−1] 和区间 [k mod n,n−1][k \\bmod n, n-1][kmodn,n−1] 即可 Code示例 class Solution { public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k = k%n; // 翻转一次 for(int i=0, j=n-1; i&lt;j; i++, j--) swap(nums[i], nums[j]); // 再次翻转，调整局部顺序 for(int i=0, j=k-1; i&lt;j; i++, j--) swap(nums[i], nums[j]); for(int i=k, j=n-1; i&lt;j; i++, j--) swap(nums[i], nums[j]); } }; 解法 2，环形替换 将每个数字放至它最后的位置，为了避免放置位置的元素被覆盖，使用临时变量 temptemptemp 来保存。例如从位置 0 开始，最初令 temp=nums[0]temp=nums[0]temp=nums[0]。根据规则，位置 0 的元素会放至 (0+k) mod n(0+k) \\mod n(0+k) mod n 的位置，令 j=(0+k) mod nj=(0+k) \\mod nj=(0+k) mod n，此时交换 temptemptemp 和 nums[j]nums[j]nums[j]，完成位置 j 的更新。然后，我们考察位置 j，并交换 temp 和 nums[(j+k)mod n]nums[(j+k) \\mod n]nums[(j+k)modn]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。 注意：一次循环，可能没有遍历完数组中的所有的元素，为了求出需要遍历的次数，需要先考虑这样一个问题：从索引 0 开始不断遍历，最终回到起点 0 的过程中，(即一次循环)遍历了多少个元素？ 由于最终回到了起点，该过程恰好走了整数数量的圈，设为 a 圈，再设该过程总共遍历了 b 个元素。因此，得到 an=bkan=bkan=bk，即 ananan 一定是 n,kn,kn,k 的公倍数，又因为是第一次回到起点就结束，所有 a 尽可能小，故 ananan 就是 n,kn,kn,k 的最小公倍数 lcm(n,k)lcm(n,k)lcm(n,k)，因此 b=lcm(n,k)kb=\\frac{lcm(n,k)}{k}b=klcm(n,k)​ 单次遍历只能访问 b 个元素，为了访问到所有元素，因此需要遍历的次数为： nb=nklcm(n,k)=gcd(n,k)\\frac{n}{b} = \\frac{nk}{lcm(n,k)} = gcd(n,k) bn​=lcm(n,k)nk​=gcd(n,k) 结果就是，需要遍历 n,kn,kn,k 最大公约数 gcd(n,k)gcd(n,k)gcd(n,k) 次。 以元素 n=6,arr=[1,2,3,4,5,6],k=4n=6, arr = [1,2,3,4,5,6], k=4n=6,arr=[1,2,3,4,5,6],k=4 为例，两次遍历的过程为： Code示例 class Solution { public: void rotate(vector&lt;int&gt; &amp;nums, int k) { int n = nums.size(); k = k % n; int count = gcd(k, n); for (int start = 0; start &lt; count; ++start) { int current = start; int prev = nums[start]; do { int next = (current + k) % n; swap(nums[next], prev); current = next; } while (start != current); } } int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } }; 总结： 如果(n,k)互质，从一个初始位置开始，遍历时每次向后移动 k 个位置，可以通过一次循环遍历完整个数组元素。（例如，通过算法生成元素场景中，每次可以生成间隔为 k 的元素，那么最终可以均匀地生成所有 n 个元素） Leetcode 45. 跳跃游戏 Ⅱ #贪心 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例保证可以到达 nums[n - 1]。 如果用 f[i]f[i]f[i] 表示从位置 0 跳到位置 iii 需要的最小跳跃次数，有性质： f[i]f[i]f[i] 是分段（连续）递增的，反证法：如果存在相邻 i&lt;j,j=i+1i&lt;j, j=i+1i&lt;j,j=i+1，有 f[i]&gt;f[j]f[i]&gt;f[j]f[i]&gt;f[j]，那么存在 l&lt;il&lt;il&lt;i 可到达 jjj，因此 lll 达到 iii 最小次数为 f[j]f[j]f[j]，与假设矛盾。其他情况，f[i]&lt;f[j]−1f[i]&lt;f[j]-1f[i]&lt;f[j]−1 也类似。所以 f[i]f[i]f[i] 只能是 [0,1...1,2...2,3...3,...][0,1...1,2...2,3...3,...][0,1...1,2...2,3...3,...] 在遍历所有元素过程中，根据分段性，更新每一步的最远位置，并记录当前元素需要的最小次数。 Code示例 class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { int max_far = 0;// 目前能跳到的最远位置 int step = 0; // 跳跃次数 int end = 0; // 跳跃可达范围右边界 for (int i = 0; i &lt; nums.size() - 1; i++) { max_far = std::max(max_far, i + nums[i]); // 到达上次跳跃能到达的右边界了 if (i == end) { end = max_far; // 目前能跳到的最远位置变成了下次起跳位置的右边界 step++; // 进入下一次跳跃 } } return step; } }; 代码优化，可以边遍历 iii 的同时，同时找到前一段中位置 jjj 可以更新/一步跳到 iii (其过程类似双指针问题)。 事实： 后面一段(需要 n+1 步走到)的所有位置必定能够在前面一段(需要 n 步)的某个位置 (可能不都是同一个下标)跳一步更新到。 Code示例 class Solution { public: int jump(vector&lt;int&gt; &amp;nums) { int n = nums.size(); vector&lt;int&gt; f(n); for (int i = 1, j = 0; i &lt; n; i++) { while (j + nums[j] &lt; i) j++; f[i] = f[j] + 1; } return f[n - 1]; } }; Leetcode 134. 加油站 #贪心｜#单调队列 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。 解法 1，枚举+贪心优化 思路：先枚举所有的起点，然后每次遍历后续的所有点。优化：如下图所示，假设从起点位置 iii 开始出发，可以行驶到位置 jjj，但是无法到达下一个位置 j+1j+1j+1，根据要求发现： 如果以中间的位置 [i+1,j][i+1,j][i+1,j] 作为起点，同样无法到达位置 j+1j+1j+1（即无法转完一圈），反证法。因此如果从 iii 可以到达 jjj，但是无法到达 j+1j+1j+1，则下一次起点直接可以从位置 j+1j+1j+1 开始。 边界，起点位置只位于 [0,n−1][0,n-1][0,n−1] Code示例 class Solution { public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int n = gas.size(); for (int i = 0, j; i &lt; n;) { // 枚举起点 int left = 0; for (j = 0; j &lt; n; j++) { // 枚举当前的终点 int t = (i + j) % n; left = left + gas[t] - cost[t]; if (left &lt; 0) break; } if (j == n) return i; i = i + j + 1; // 跳过 } return -1; } }; 解法 2，通用做法，单调队列优化 直接看这一道题：提高课 DP-1088. 旅行问题 思路：将每一个点 iii 的油量与接下来的消耗量的差值 p[i]−d[i]p[i] - d[i]p[i]−d[i] 作为该点的值，判断该点顺时针能够回到该点，等价于长度为 nnn 的(处理后的数组)所有前缀和 &gt;=0&gt;=0&gt;=0。求解该数组的前缀和数组 SSS 后，等价于 S[j]−S[i−1]&gt;=0,j∈[i,i+n−1]S[j]-S[i-1]&gt;=0, j\\in[i,i+n-1]S[j]−S[i−1]&gt;=0,j∈[i,i+n−1]，即固定位置 iii 后，判断其后连续的 nnn 个前缀和的最小值 S[j′]S[j&#x27;]S[j′] 是否满足该条件即可。归结于，求解滑动窗口中的最值问题 总结： 如果需要枚举环形上的点，并且长度范围是循环的，可以先展开为线性，做法是将元素复制一遍到末尾； 对于逆时针，就是改变求和的方向，等价于固定前缀和窗口的右边界； Code示例 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; using LL = long long; const int N = 2e6 + 10; int n, p[N], d[N]; LL s[N]; // 前缀和 int q[N], hh, tt; // 单调队列 bool st[N]; // 答案数组 int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i] &gt;&gt; d[i]; // 顺时针, 固定左端点，求右窗口中的最小值 for (int i = 1; i &lt;= n; i++) s[i] = s[i + n] = p[i] - d[i]; // 展开为2*n的数组 for (int i = 1; i &lt;= 2 * n; i++) s[i] += s[i - 1]; // 前缀和 hh = 0, tt = -1; for (int i = 2 * n; i; i--) { // 从左往右也可以 if (hh &lt;= tt &amp;&amp; q[hh] - i &gt;= n) hh++; while (hh &lt;= tt &amp;&amp; s[i] &lt;= s[q[tt]]) tt--; q[++tt] = i; // 添加i共n个 if (i &lt;= n &amp;&amp; s[q[hh]] &gt;= s[i - 1]) st[i] = true; } // 逆时针, 固定右端点，求左窗口中的最大值 d[0] = d[n]; for (int i = 1; i &lt;= n; i++) s[i] = s[i + n] = p[i] - d[i - 1]; for (int i = 1; i &lt;= 2 * n; i++) s[i] += s[i - 1]; hh = 0, tt = -1; for (int i = 1; i &lt;= 2 * n; i++) { // 注意未加入i之前，窗口最多有n个值 if (hh &lt;= tt &amp;&amp; i - q[hh] &gt; n) hh++; // 当 i=[n+1...2n] 判断结果 // 这里需要判断 a[i],先判断后加入i if (i &gt; n &amp;&amp; s[i] &gt;= s[q[hh]]) st[i - n] = true; while (hh &lt;= tt &amp;&amp; s[i] &gt;= s[q[tt]]) tt--; q[++tt] = i; } for (int i = 1; i &lt;= n; i++) if (st[i]) cout &lt;&lt; &quot;TAK&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NIE&quot; &lt;&lt; endl; } 链表 排序： Leetcode 148. 排序链表 链表的归并排序，从底向上写法。代码示例 二叉树/树 遍历 Leetcode 144. 二叉树前序遍历 二叉树前序遍历迭代写法。代码示例 Leetcode 94. 二叉树中序遍历 二叉树中序遍历迭代写法。代码示例 Leetcode 145. 二叉树后序遍历 二叉树后序遍历迭代写法。代码示例 思路 1 使用常规方法和标志位，思路 2 转化为前序遍历方式。 Leetcode 102. 二叉树的层序遍历 使用队列广度优先遍历。代码示例 对于递归改迭代，具有机械化的改法，例如中序遍历，添加节点的状态来辅助遍历：https://www.acwing.com/solution/content/176/ 使用遍历的扩展题目 Leetcode 513. 找树左下角的值 深度优先遍历/广度优先遍历 序列化 Leetcode 652. 寻找重复的子树 二叉树自定义唯一值序列化。代码示例 动态规划 数字三角形 DP Leetcode 119. 杨辉三角 Ⅱ 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 对动态规划中空间优化的总结： 如果可以使用滚动数组来优化存储空间时，使用 row &amp; 1 来确定当前行位置（利用 2 行的数组进行滚动计算），其中 &amp; 运算符优先级低于 +, - 算法题中，可以先使用常规二维数组进行解题和计算，最后将原状态数组改成 2 行的滚动数组，并机械化地将使用到的状态行 row 全部用 row &amp; 1 替换即可 Code示例 class Solution { public: //* 这里倒序计算，可以直接使用一维数组 // vector&lt;int&gt; getRow(int rowIndex) { // // 倒序不会覆盖元素 // vector&lt;int&gt; f(rowIndex + 1); // for (int i = 0; i &lt;= rowIndex; i++) { // f[0] = f[i] = 1; // for (int j = i - 1; j &gt; 0; j--) // f[j] = f[j - 1] + f[j]; // } // return f; // } //* 一般的滚动数组优化方法 vector&lt;int&gt; getRow(int rowIndex) { vector &lt; vector &gt;&gt; f(2, vector&lt;int&gt;(rowIndex + 1)); for (int i = 0; i &lt;= rowIndex; i++) { f[i &amp; 1][0] = f[i &amp; 1][i] = 1; for (int j = 1; j &lt; i; j++) f[i &amp; 1][j] = f[i - 1 &amp; 1][j - 1] + f[i - 1 &amp; 1][j]; } return f[rowIndex &amp; 1]; } }; 字符串匹配 剑指Offer 18 正则表达式匹配 实现一个函数用来匹配包括'.'和'*'的正则表达式。 DP 分析： 注意，在状态计算中，第3种情况其实是 1/2 中的子分类，但是单独拿出来进行计算可以减少分类讨论情形。结果只需要计算出是否匹配，分类能完全覆盖 f[i][j] 的状态即可。 class Solution { // f[i][j] 表示 s[i...] 与 p[j...] 的匹配状态 vector&lt;vector&lt;bool&gt;&gt; f; public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); f=vector&lt;vector&lt;bool&gt;&gt;(n+1, vector&lt;bool&gt;(m+1, false)); f[n][m] = true; // f[n][j] 需要计算 for(int i=n; i&gt;=0; i--){ for(int j=m-1; j&gt;=0; j--){ // i&lt;n 排除 s 是空串的情况，避免出现访问 s[i]/f[i][j]越界 bool first_match = i&lt;n &amp;&amp; (s[i] == p[j] || p[j] == '.'); f[i][j] = first_match &amp;&amp; f[i+1][j+1]; // 不考虑 * // 考虑 * if(j+1&lt;m &amp;&amp; p[j+1]=='*'){ f[i][j] = f[i][j+2] || (first_match &amp;&amp; f[i+1][j]); // 0 次 || 至少1次 } } } return f[0][0]; } }; /** * 写法2 * 递归形式计算 f[0][0] 并计算状态 */ class Solution { // f[i][j] 表示 s[i...] 与 p[j...] 的匹配状态 vector&lt;vector&lt;int&gt;&gt; f; // int: 单独使用 -1 表示还未计算 string s, p; int n, m; public: bool isMatch(string _s, string _p) { s = _s, p = _p; n = s.size(), m = p.size(); f=vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(m+1, -1)); return dp(0, 0); } bool dp(int i, int j){ if(f[i][j]!=-1) return f[i][j]; if(j == m) return f[i][j] = i ==n; bool first_match = i&lt;n &amp;&amp; (s[i]==p[j] || p[j] == '.'); f[i][j] = first_match &amp;&amp; dp(i+1, j+1); if(j+1&lt;m &amp;&amp; p[j+1] == '*') f[i][j] = dp(i, j+2) || (first_match &amp;&amp; dp(i+1, j)); return f[i][j]; } }; 类似的题目： 创意标题匹配 ","tags":[{"name":"Algorithm","slug":"algorithm","used":true,"link":"https://blog.qxxiao.eu.org/tag/algorithm/"}],"title":"Leetcode","feature":"https://pic.qxxiao.cn/algorithm.png","link":"https://blog.qxxiao.eu.org/post/Leetcode/","stats":{"text":"17 min read","time":994000,"words":3653,"minutes":17},"date":"2024-05-19 16:30:22","dateFormat":"2024-05-19","isTop":false},{"content":"pcb密码学库的简单介绍和示例使用 官网： https://crypto.stanford.edu/pbc/ https://crysp.uwaterloo.ca/software/PBCWrapper/ 安装和介绍 参考这两篇文章 https://jeza-chen.com/2020/06/04/PBC-Library/ https://jeza-chen.com/2020/06/05/PBC-Cpp-Wrapper/ 示例 BLS签名和验证 //* BLS签名: https://crypto.stanford.edu/pbc/manual/ch02.html #include &quot;PBC.h&quot; int main() { //初始化配对变量e char param[1024]; FILE* file = fopen(&quot;a.param&quot;, &quot;r&quot;); size_t count = fread(param, 1, 1024, file); fclose(file); if (!count) pbc_die(&quot;input error&quot;); // 初始化配对变量e Pairing e(param, count); // 生成系统参数g G2 g(e, false); // TODO 随机初始化一个系统参数g(论文中通常使用生成元) g.dump(stdout, &quot;system parameter g&quot;, 16); // 生成私钥和公钥 Zr secret_key(e, true); // 生成一个Zr类型的secret_key secret_key.dump(stdout, &quot;secret key&quot;); G2 public_key = g ^ secret_key; // 指数运算 public_key.dump(stdout, &quot;public key&quot;); // 假设消息m的hash值为 &quot;hashofmessage&quot; G1 h(e, (void*)&quot;hashofmessage&quot;, 13); // 将消息hash值映射到G1元素h h.dump(stdout, &quot;message hash&quot;); // 对消息m进行签名(对元素h签名) G1 sig = h ^ secret_key; sig.dump(stdout, &quot;signature&quot;); // 实际中，可以只输出第一个坐标(但是x坐标对应2个元素-椭圆曲线对称性，配对测试需要2次) // 验证签名 GT temp1 = e(sig, g); // 配对运算 GT temp2 = e(h, public_key); cout &lt;&lt; endl; temp1.dump(stdout, &quot;e(sig, g)&quot;); temp2.dump(stdout, &quot;e(h, public_key)&quot;); if (temp1 == temp2) cout &lt;&lt; &quot;signature verifies&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;signature does not verify&quot; &lt;&lt; endl; } https://crypto.stanford.edu/pbc/manual/ch02s02.html部分还介绍了如何将签名进行压缩(或只存储签名的x坐标)便于存储和传输。 备注 Python、Java和Go也有对应的包装版本 ","tags":[{"name":"Crypto","slug":"crypto","used":true,"link":"https://blog.qxxiao.eu.org/tag/crypto/"},{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"PBC｜PBCWrapper 密码学库","feature":"","link":"https://blog.qxxiao.eu.org/post/PBC｜PBCWrapper 密码学库/","stats":{"text":"3 min read","time":125000,"words":434,"minutes":3},"date":"2024-03-06 14:23:23","dateFormat":"2024-03-06","isTop":false},{"content":"更新一些技术博客链接，如果有 RSS 链接也会附在后面。 博客 阮一峰的博客 http://feeds.feedburner.com/ruanyifeng Eli Bendersky's website github (Go by Example 作者) Thoughts and links about programming, by Russ Cox (Go 语言作者 Russ Cox) laike9m's blog http://laike9m.com/blog/rss TonyBai's blog http://tonybai.com/feed/ (Go 语言) Julia Evans https://jvns.ca/feed.xml (blog&amp;comic) Tw93's blog/weekly https://tw93.fun/feed.xml (前端) Switch-Router's blog Morven's Life 程序员的自我修养 CodingLabs C++/Rust C++进阶学习指南 Notion 笔记 - C++ 系列 Notion 笔记 - Mac 下的 C++工具链 Notion 命令和配置 Josuttis C++标准委员会成员（C++20/17/14, C++ template） C++ Templates 2nd modern C++ Preshing on Programming (C++ Concurrency) 🌟 Atomic vs. Non-Atomic Operations The Happens-Before Relation The Synchronizes-With Relation Acquire and Release Fences Double-Checked Locking is Fixed In C++11 SF-Zhou's Blog 🌟 Mrcroxx's blog szza's blog IPFS https://share.ipfs.io https://webui.ipfs.io https://cid.ipfs.tech https://explore.ipld.io https://dag.ipfs.tech https://car.ipfs.io https://pl-diagnose.on.fleek.co https://ipfs.github.io/public-gateway-checker CheatSheet QuickRef.ME Vim Cheat Sheet Rust Language Cheat Sheet 资源 Web: Networking 101 https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/ PDF: C++17 in detail PDF: openssl cookbook 文章 X86 Assembly 计算机系统基础-袁春风 http://arthurchiao.art/blog/x86-asm-guide-zh/ http://arthurchiao.art/blog/system-call-definitive-guide-zh/ 技术扫盲-quic 协议 Unicode 编码 JS 中的文件和二进制数据的操作 RPC 详解 详解微服务架构 内存映射 mmap 函数的原理 使用 ACME 申请证书（证书自动续期） RSA 加密 RSA 算法原理（一） RSA 算法原理（二） GPG 入门教程 LSH 局部敏感哈希 Merkle Tree（默克尔树）算法解析 ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"博客链接","feature":"","link":"https://blog.qxxiao.eu.org/post/博客链接/","stats":{"text":"3 min read","time":123000,"words":408,"minutes":3},"date":"2023-06-10 09:37:44","dateFormat":"2023-06-10","isTop":true},{"content":"可能会遇到想要执行定时任务或者监测任务，使用 launchd，可以很方便地执行。 [man launchd.plist] scheduling timed jobs-Apple 监测文件夹变动 对文件夹进行监测，如果更新了文件夹，执行对应的脚本任务，简单步骤： 创建一个plist 服务配置文件，例如名称为 com.example.watchfolder.plist，内容可以根据下面的示例更改； 将该文件移动到 /Library/LaunchAgents 下，该目录为用户级别的服务配置文件夹； 加载该服务 launchctl load /Library/LaunchAgents/com.example.watchfolder.plist # sudo launchctl bootstrap system /Library/LaunchAgents/com.example.watchfolder.plist 如果想要卸载该服务，执行： # launchctl list | grep watchfolder # 查询服务 launchctl stop com.example.watchfolder launchctl unload /Library/LaunchAgents/com.example.watchfolder.plist 注意，如果不能停止对应的异常的服务，使用 sudo 执行一次。 一个简单的监测示例： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.example.watchfolder&lt;/string&gt; &lt;key&gt;EnvironmentVariables&lt;/key&gt; &lt;dict&gt; &lt;key&gt;PATH&lt;/key&gt; &lt;string&gt;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/slt&lt;/string&gt; &lt;string&gt;deploy&lt;/string&gt; &lt;/array&gt; &lt;key&gt;WatchPaths&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Users/xiao/.gridea/output/&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;false/&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/dev/null&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/tmp/watchfolder.log&lt;/string&gt; &lt;key&gt;StartInterval&lt;/key&gt; &lt;integer&gt;-1&lt;/integer&gt; &lt;key&gt;ThrottleInterval&lt;/key&gt; &lt;integer&gt;10&lt;/integer&gt; &lt;key&gt;WorkingDirectory&lt;/key&gt; &lt;string&gt;/Users/xiao/.gridea/&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt; 说明： Label 值自定义该服务的名称 ProgramArguments 用来指定执行的脚本和参数，名称和参数单独使用一个字符串表示，可以添加多个需要的参数 WatchPaths 如果列出的路径中的任何一条被修改，将导致作业启动 RunAtLoad 指定加载时是否执行；KeepAlive 指定任务是否保持活动状态，即完成后自动重启任务，通常情况下设置false StartInterval 指定重启任务的间隔时间，每隔 N 秒重启执行一次，-1表示不执行；ThrottleInterval 指定节流间隔，N秒内不会重新启动执行，保证了两次任务的最小间隔时间； WorkingDirectory 指定任务的工作目录；PATH 指定环境变量； 注意事项： 监测的文件夹，是指其中的子文件/文件夹添加/删除/名称修改，如果只是修改子文件的内容是不会影响的文件夹监测的(LMT)。 解决：变动的时候整体覆盖文件夹(删除再创建)；或者向其中添加一个空文件然后删除也可以； ","tags":[{"name":"Mac","slug":"mac","used":true,"link":"https://blog.qxxiao.eu.org/tag/mac/"}],"title":"Mac 定时任务和脚本","feature":"","link":"https://blog.qxxiao.eu.org/post/mac定时任务和脚本/","stats":{"text":"4 min read","time":207000,"words":759,"minutes":4},"date":"2023-06-03 21:42:32","dateFormat":"2023-06-03","isTop":false},{"content":" 内容：解释和理解伽罗华域和基础的 RS 编码理论，和编码实践。 1. Cauchy or Vandermonde? 2. 写一个Reed-Solomon code引擎 3. 高性能纠删码编码 4. 有限域内的四则运算 5. 分布式系统系列教程之: Erasure-Code 1. 伽罗华域 有关 群、环、域 在之前总结过，这里也有用到的代数基础 范德蒙码和柯西码的译码过程、范德蒙系统码的生成矩阵的构造都需要矩阵求逆运算，柯西码的构造中涉及到求乘法逆元的运算，这些运算在实数域内存在无法整除的情况，因此需要将运算限定在伽罗华域内进行。 构造 本原多项式 P(x)P(x)P(x) 是 GF(2)GF(2)GF(2) 上的 m 次多项式，具有性质：(x2m−1+1)/P(x)(x^{2^m-1}+1)/P(x)(x2m−1+1)/P(x) 的余式为 0，并且 P(x)P(x)P(x) 不能被 GF(2)GF(2)GF(2) 上任意次数小于 m 大于 0 的多项式整除。 举例说明 GF(23)GF(2^3)GF(23) 构造方法，选择本原多项式 P(x)=x3+x+1P(x)=x^3+x+1P(x)=x3+x+1 ，令 P(x)=0P(x)=0P(x)=0 的根为 α\\alphaα ，即 α3+α+1=0\\alpha^{3}+\\alpha +1=0α3+α+1=0，伽罗华域加法运算为异或，所以 α3=α+1\\alpha^{3}= \\alpha+1α3=α+1。利用本原元 α\\alphaα 的幂次可以生成该域下所有的元素(除 0 外)，如下表： 如果 (xn+1)(x^{n}+1)(xn+1) 能整除 P(x)P(x)P(x) 【次数为 mmm 】，其最小次数(正整数) n=2m−1n=2^m-1n=2m−1 ，所以有 α2m−1=1=α0\\alpha^{2^m-1}=1=\\alpha^0α2m−1=1=α0 ，即幂次达到 n=2m−1n=2^m-1n=2m−1 重新回到 α0\\alpha^0α0 即等于 1，所以扩域 GF(2w)GF(2^w)GF(2w) 共有 2w2^w2w 个元素(包括元素0). 2. 矩阵 Vandermonde 矩阵 实数域 m×nm \\times nm×n 的 Vandermonde 矩阵形式如下，Vij=αj−1V_{ij}=\\alpha^{j-1}Vij​=αj−1，（常见取 x1,x2,⋯ ,xmx_1,x_2,\\cdots,x_mx1​,x2​,⋯,xm​ 为 1,2,⋯ ,m1,2,\\cdots,m1,2,⋯,m） [1α1α12⋯α1n−11α2α22⋯α2n−11α3α32⋯α3n−1⋮⋮⋮⋱⋮1αmαm2⋯αmn−1]\\begin{bmatrix} 1 &amp; \\alpha_1 &amp; \\alpha_1^2 &amp; \\cdots &amp; \\alpha_1^{n-1} \\\\ 1 &amp; \\alpha_2 &amp; \\alpha_2^2 &amp; \\cdots &amp; \\alpha_2^{n-1} \\\\ 1 &amp; \\alpha_3 &amp; \\alpha_3^2 &amp; \\cdots &amp; \\alpha_3^{n-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; \\alpha_m &amp; \\alpha_m^2 &amp; \\cdots &amp; \\alpha_m^{n-1} \\end{bmatrix}⎣⎢⎢⎢⎢⎢⎡​111⋮1​α1​α2​α3​⋮αm​​α12​α22​α32​⋮αm2​​⋯⋯⋯⋱⋯​α1n−1​α2n−1​α3n−1​⋮αmn−1​​⎦⎥⎥⎥⎥⎥⎤​ 实数下的不同元素的 Vandermonde 矩阵 (n×n)(n \\times n)(n×n) 是一定可逆的，但它的任意 m 行 m 列(m&lt;n)组成的子矩阵不一定是可逆的. 【参考mathoverflow】 对于实数下的 vandermonde 矩阵，元素为 不同正数时 任意的子方阵是可逆的(*) 由于 n∗nn*nn∗n 的 Vandermonde 方阵是可逆的，若 m&gt;nm&gt;nm&gt;n 则任意的 n∗nn*nn∗n 的子方阵是可逆（也是范德蒙矩阵）【可逆证明提示：n 次多项式最多有 n 个根；其行列式不等于0】 【实数域下的可逆性】 互不相等的实数构成的范德蒙矩阵是可逆的，这里考虑它的任意子方阵。 【有限域下的可逆性】 实数域下可能不可逆，有限域下更可能如此。 注意： 根据【Note: Correction to the 1997 Tutorial on Reed-Solomon Coding】来构造 VRS 的生成矩阵。 Cauthy 矩阵 m×nm \\times nm×n 的 Cauthy 矩阵形式如下： X={x1,x2,…,xm}X=\\{ x_1,x_2,\\dots , x_m\\}X={x1​,x2​,…,xm​}，Y={y1,y2,…,yn}Y=\\{ y_1,y_2,\\dots , y_n\\}Y={y1​,y2​,…,yn​}，【都是 GF(2w)GF(2^w)GF(2w) 元素】 满足 X∩Y=∅X \\cap Y = \\emptysetX∩Y=∅，即任意 xi≠yj,xi≠xj,yi≠yjx_i \\neq y_j,x_i \\neq x_j, y_i \\neq y_jxi​​=yj​,xi​​=xj​,yi​​=yj​ (都不相同) [1x1+y11x1+y21x1+y3⋯1x1+yn1x2+y11x2+y21x2+y3⋯1x2+yn1x3+y11x3+y21x3+y3⋯1x3+yn⋮⋮⋮⋱⋮1xm+y11xm+y21xm+y3⋯1xm+yn]\\begin{bmatrix} \\frac{1}{x_1+y_1} &amp; \\frac{1}{x_1+y_2} &amp; \\frac{1}{x_1+y_3} &amp; \\cdots &amp; \\frac{1}{x_1+y_n} \\\\ \\frac{1}{x_2+y_1} &amp; \\frac{1}{x_2+y_2} &amp; \\frac{1}{x_2+y_3} &amp; \\cdots &amp; \\frac{1}{x_2+y_n} \\\\ \\frac{1}{x_3+y_1} &amp; \\frac{1}{x_3+y_2} &amp; \\frac{1}{x_3+y_3} &amp; \\cdots &amp; \\frac{1}{x_3+y_n} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\frac{1}{x_m+y_1} &amp; \\frac{1}{x_m+y_2} &amp; \\frac{1}{x_m+y_3} &amp; \\cdots &amp; \\frac{1}{x_m+y_n} \\end{bmatrix}⎣⎢⎢⎢⎢⎢⎢⎡​x1​+y1​1​x2​+y1​1​x3​+y1​1​⋮xm​+y1​1​​x1​+y2​1​x2​+y2​1​x3​+y2​1​⋮xm​+y2​1​​x1​+y3​1​x2​+y3​1​x3​+y3​1​⋮xm​+y3​1​​⋯⋯⋯⋱⋯​x1​+yn​1​x2​+yn​1​x3​+yn​1​⋮xm​+yn​1​​⎦⎥⎥⎥⎥⎥⎥⎤​ 对应的行列式的值为证明： Dn=∏1≤i≤j≤n(aj−ai)(bj−bi)∏i=1n∏j=1n(ai+bj)D_n=\\frac{\\prod\\limits_{1\\leq i \\leq j \\leq n} (a_j-a_i)(b_j-b_i)}{\\prod\\limits_{i=1}^{n} \\prod\\limits_{j=1}^{n} (a_i+b_j)} Dn​=i=1∏n​j=1∏n​(ai​+bj​)1≤i≤j≤n∏​(aj​−ai​)(bj​−bi​)​ Cauchy 矩阵的任意 n 行 n 列组成的矩阵都是可逆的, 因为任意子矩阵还是 Cauchy 矩阵. 【实数域下的可逆性】 在上述条件下，Cauthy 矩阵是非奇异矩阵，可逆矩阵。 【有限域下的可逆性】 矩阵也是非奇异矩阵 矩阵编码 利用单位矩阵扩展 Vandermonde 后的 n×kn \\times kn×k 矩阵，可能任意 kkk 行的子矩阵不可逆，在有限域中也是如此。 通常使用 Vandermonde 矩阵，做矩阵的初等变换使得前 k×kk \\times kk×k 是单位矩阵。 可以直接使用单位矩阵扩展 Cauthy 矩阵，任意的子方阵仍然可逆。 Cauchy Reed-Solomon 的优化 使用 Cauthy 矩阵 可逆性更好，构造更加简单；可以在 O(n2)O(n^2)O(n2) 完成矩阵的逆运算 投影到 GF(2)GF(2)GF(2) 方法：每个 GF(2w)GF(2^w)GF(2w) 中的元素 eee 可以表示为一个 www 维的列向量 V(e)V(e)V(e)（多项式系数或二进制表示）；每个元素 eee 同样可以表示为一个 w×ww \\times ww×w 的二进制矩阵 M(e)M(e)M(e)，其第 iii 列是 e∗2i−1e*2^{i-1}e∗2i−1 的二进制表示即 V(e∗2i−1)V(e*2^{i-1})V(e∗2i−1)。例如在 GF(23)GF(2^3)GF(23) 下元素的表示为： 得到结论： 根据映射关系，不同元素对应的 M(e)M(e)M(e) 是不同的 基于标准的位运算 M(e1)∗V(e2)=V(e1e2)M(e_1) * V(e_2) = V(e_1e_2)M(e1​)∗V(e2​)=V(e1​e2​) 基于标准的位运算 M(e1)∗M(e2)=M(e1e2)M(e_1) * M(e_2)=M(e_1e_2)M(e1​)∗M(e2​)=M(e1​e2​) 根据结论，可以将 GF(2w)GF(2^w)GF(2w) 的运算转化为 GF(2)GF(2)GF(2) 下标准的位运算（异或，按位与），降低了运算的复杂度。 (2)的理解 用 ei,je_{i,j}ei,j​ 表示元素 eie_iei​ 二进制的第 jjj 位： e1e2=e1(e2,020+e2,121+⋯+e2,w−12w−1)=e120∗e2,0+e121∗e2,1+⋯+e12w−1∗e2,w−1=[e120e121⋯e12w−1]⋅[e2,0e2,1⋮e2,w−1]\\begin{aligned} e_1e_2 &amp;= e_1(e_{2,0}2^{0}+e_{2,1}2^{1}+\\dots+e_{2,w-1}2^{w-1}) \\\\ &amp;= e_12^0*e_{2,0}+e_12^1*e_{2,1}+ \\dots +e_12^{w-1}*e_{2,w-1} \\\\ &amp;= \\begin{bmatrix} e_12^0 &amp; e_12^1 &amp; \\cdots &amp; e_12^{w-1}\\end{bmatrix} \\cdot \\begin{bmatrix} e_{2,0} \\\\ e_{2,1} \\\\ \\vdots \\\\ e_{2,w-1} \\end{bmatrix} \\end{aligned}e1​e2​​=e1​(e2,0​20+e2,1​21+⋯+e2,w−1​2w−1)=e1​20∗e2,0​+e1​21∗e2,1​+⋯+e1​2w−1∗e2,w−1​=[e1​20​e1​21​⋯​e1​2w−1​]⋅⎣⎢⎢⎢⎡​e2,0​e2,1​⋮e2,w−1​​⎦⎥⎥⎥⎤​​ 将对应的元素映射为 www 向量，即可： V(e1e2)=M(e1)∗V(e2)V(e_1e_2)=M(e_1) * V(e_2) V(e1​e2​)=M(e1​)∗V(e2​) (3)的理解 M(e1)∗M(e2)=M(e1)⋅[V(e220)V(e221)⋯V(e22w−1)]=[V(e1e220)V(e1e221)⋯V(e1e22w−1)]=M(e1e2)\\begin{aligned} M(e_1)*M(e_2) &amp;= M(e_1) \\cdot \\begin{bmatrix} V(e_22^0) &amp; V(e_22^1) &amp; \\cdots &amp; V(e_22^{w-1}) \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix} V(e_1e_22^0) &amp; V(e_1e_22^1) &amp; \\cdots &amp; V(e_1e_22^{w-1}) \\end{bmatrix} \\\\ &amp;= M(e_1e_2) \\end{aligned}M(e1​)∗M(e2​)​=M(e1​)⋅[V(e2​20)​V(e2​21)​⋯​V(e2​2w−1)​]=[V(e1​e2​20)​V(e1​e2​21)​⋯​V(e1​e2​2w−1)​]=M(e1​e2​)​ 链接 工具 有限域的计算工具 快速乘法 问答 Linear independence of Vandermonde matrix in systematic Reed-Solomon code 论文 A Tutorial on Reed-Solomon Coding for Fault-Tolerance in RAID-like Systems Note: Correction to the 1997 Tutorial on Reed-Solomon Coding Optimizing Cauchy Reed-Solomon Codes for Fault-Tolerant Storage Applications An XOR-Based Erasure-Resilient Coding Scheme Tutorial: Erasure Coding for Storage Applications ","tags":[{"name":"EC","slug":"ec","used":true,"link":"https://blog.qxxiao.eu.org/tag/ec/"}],"title":"纠删码基础","feature":"","link":"https://blog.qxxiao.eu.org/post/纠删码基础/","stats":{"text":"11 min read","time":607000,"words":2057,"minutes":11},"date":"2023-05-13 20:37:15","dateFormat":"2023-05-13","isTop":false},{"content":"参考链接：MinHash-WiKi 问题 MinHash 算法和 Bloom Filter 一样，利用哈希函数的随机性从概率上快速地解决问题，它试图解决的问题是：集合的相似性，给定两个含有元素的集合，它们有多相似。相似性度量使用 Jaccard similarity coefficient ： Jaccard similarity(A,B)=∣A∩B∣∣A∪B∣\\mathbf{Jaccard\\ similarity}(A,B)=\\frac{\\mid A \\cap B \\mid}{\\mid A \\cup B \\mid} Jaccard similarity(A,B)=∣A∪B∣∣A∩B∣​ 当两个集合不相交时，此值为 0；当它们相等时，此值为 1；否则严格在 0 和 1 之间。当 Jaccard 指数接近于 1 时，两个集合更相似（即具有较多共同成员）。MinHash 的目标是快速估计 J(A,B)，而无需显式计算交集和并集。 将 hmin(S)h_{min}(S)hmin​(S) 定义为集合 S 中具有最小哈希值的成员 xxx. 将 hminh_{min}hmin​ 应用于集合 A 和 B，并假设没有哈希冲突，我们可以看到，当且仅当 A∪BA\\cup BA∪B 中具有最小哈希值的元素位于交集 A∩BA \\cap BA∩B 中时，有hmin(A)=hmin(B)h_{min}(A) = h_{min}(B)hmin​(A)=hmin​(B)。这种情况成立的概率正好是 Jaccard 系数，因此： Pr⁡[hmin⁡(A)=hmin⁡(B)]=J(A,B)\\operatorname{Pr}\\left[h_{\\min }(A)=h_{\\min }(B)\\right]=J(A, B) Pr[hmin​(A)=hmin​(B)]=J(A,B) k-hash MinHash 使用 k 个 hash 函数的 MinHash 是经典表示，也很优雅。其做法是：对 A 和 B 中的每个元素进行哈希，并查看每个集合中最小哈希值。事实证明，这两个哈希相等的概率恰好是这两个集合的 Jaccard 相似度。注意，为了从一个概率样本中近似估计该概率，需要大量的样本。因此，在这个版本的 MinHash 中，需要使用 k 个哈希函数得到 k 组 (hmin(A),hmin(B))(h_{min}(A), h_{min}(B))(hmin​(A),hmin​(B))，如果其中有 y 组表示的最小哈希值相等，用 y/ky/ky/k 来估计集合的相似度。 举例子说明，如果 A 和 B 是相同的，那么它们的最小哈希显然是相同的。如果它们是不相交的，并且假设没有哈希冲突，那么它们的最小哈希显然会不同。以 A 包含 B 并且大小为其两倍为例。那么很容易理解 B 的最小哈希有 50% 的机会成为 A 的最小哈希。 这个版本中，需要计算每个元素的 k 个不同哈希值，并且最后计算出概率。此外，该技术的误差为 1/(k)1/\\sqrt(k)1/(​k) （级别），达到 10%误差水平需要 100 个哈希函数，1%误差需要 10000 个哈希函数。 one-hash MinHash 做法是：计算每个元素的哈希值，并将集合中的最小的 k 个哈希值存储起来，集合中最小的 k 个哈希值也用做该集合的签名，对应的 k 个元素记作 h(k)(S)h_{(k)}(S)h(k)​(S)。然后根据两个签名对应集合来计算 Jaccard 相似度，期望误差界限与上面的版本相同。时间复杂度为 O(nlog⁡k)O(n\\log k)O(nlogk) ，空间复杂度为 O(k)O(k)O(k) 。 对于两个集合 A,B 来说： X=h(k)(h(k)(A)∪h(k)(B))=h(k)(A∪B)Y=X∩h(k)(A)∩h(k)(B)J≈∣Y∣k\\begin{aligned} X &amp;=h_{(k)}\\left(h_{(k)}(A) \\cup h_{(k)}(B)\\right)=h_{(k)}(A \\cup B)\\\\ Y &amp;=X \\cap h_{(k)}(A) \\cap h_{(k)}(B) \\\\ J &amp;\\approx \\frac{ |Y| }{k} \\end{aligned} XYJ​=h(k)​(h(k)​(A)∪h(k)​(B))=h(k)​(A∪B)=X∩h(k)​(A)∩h(k)​(B)≈k∣Y∣​​ 其中集合 ∣Y∣|Y|∣Y∣ 就是：两个签名集合并集中最小的 k 个元素，位于其交集中的元素个数 (有的版本实现中，简单地直接计算两个签名集合的 Jaccard 系数作为原始集合 Jaccard 系数的估计值) 说明：Min-wise independent hash functions 对于上述的哈希函数，需要具有最小值独立性，即对于任意集合 S，集合 S 中的元素经过哈希后得到的最小值是随机的，与集合 S 的具体元素无关。如通过随机置换实现，或者假设其具有伪随机性。 链接 On the resemblance and containment of documents, Broder, 1997.pdf Dealing with Massive Data, Lecture1: Duplicate Detection.pdf CS494 Lecture Notes - MinHash ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"MinHash","feature":"","link":"https://blog.qxxiao.eu.org/post/minhash/","stats":{"text":"5 min read","time":276000,"words":1100,"minutes":5},"date":"2023-05-10 17:21:20","dateFormat":"2023-05-10","isTop":false},{"content":" http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html#ch6 说明 CRC（循环冗余校验）是一种检测数据不一致性的校验算法，例如在数据传输过程中出现的位错误。由 CRC 计算得出的校验和附加到数据上，以帮助接收方检测此类错误。 CRC 基于除法。实际输入数据被解释为一个长的二进制位流（被除数），它被另一个固定的二进制数（除数）所除。这个除法的余数就是校验和。二进制数字（被除数和除数）不像普通整型值那样处理，而是作为二元多项式来处理，其中实际位用作系数。 例如输入数据 0x25 = 0010 0101 被视为 0∗x7 +0∗x6 +1∗x5 +0∗x4 +0∗x3 +1∗x2 +0∗x1 +1∗x00*x^7 + 0*x^6 + 1*x^5 + 0*x^4 + 0*x^3 + 1*x^2 + 0*x^1 + 1*x^00∗x7 +0∗x6 +1∗x5 +0∗x4 +0∗x3 +1∗x2 +0∗x1 +1∗x0 . 被除数是完整的输入数据（解释为二进制流） 除数，也称为生成多项式，由使用的 CRC 算法定义。CRC-n 使用具有 (n+1) 位的固定定义生成多项式 CRC 校验和的值被定义为被除数 % 除数，对生成多项式的余数 举例 // 输出数据是 byte 0xC2 = b1100 0010 // 生成多项式，即除数为 b10001 1101(除数9位，因此是CRC-8,添加8个 0bits 到输入数据末尾) // 将除数的前导“1”与被除数的第一个“1”对齐，逐步进行除法运算，但是对每个位使用XOR操作： 1100001000000000 100011101 --------- 010011001 100011101 --------- 000101111 100011101 (*) --------- 001100101 100011101 --------- 010001001 100011101 --------- 000001111 = 0x0F 在每一步中，除数的前导“1”始终与被除数的第一个“1”对齐。这意味着，在每一步中，除数不仅向右移动 1 位，有时还会移动几个步骤（例如像 (*) 行）。 算法会在除数将实际输入数据（不包括填充字节）的每个位都清零时停止。或者说最后的有效位全部位于填充字节(这里 n=8)，也即最终的余数在 n-bit 范围内。 每一步中只有余数是感兴趣的，因此实际除法结果（商）可以不关心。 最后只取 n-bit 的余数 CRC 验证 余数是 CRC 值，它与输入数据一起传输到接收器。常见的做法是，直接将 CRC 值附加到实际数据末尾。然后接收器在整个数据上（包括已附加了 CRC 值的输入）计算 CRC：如果 CRC 值为 0，则很可能在传输过程中没有发生位错误。 实现细节 通过手动模拟的过程，可以很容易地通过移位寄存器的方式逐步计算出最后的余数。 初始化固定大小(n-bit)的移位寄存器为 0; 逐位移动输入流。如果弹出的 MSB 是 1，则使用生成多项式对寄存器值进行异或操作; 如果所有输入位都被处理，则 CRC 移位寄存器内容就是 CRC 值。 CRC-8 实现 生成多项式的最高位是 1，并且在除法过程中会将生成多项式的最高位 1 与被除数的下一个最高位 1 对齐，异或为 0，所以运算过程可以忽略生成多项式的最高位 1，例如 9 位的 b100011101 只需要使用 0x1D 进行运算。 注意，可以每个字节单独处理，处理完一个字节后的余数与下一个字节异或后继续处理 类似这样处理 // 按照手动除法的模拟 b1 0 b2 0 b3 0 ...... #include &lt;cstdint&gt; uint8_t Compute_CRC8_Simple(const unsigned char* bytes, size_t length) { const uint8_t generator = 0x1D; // b100011101 = 0x1D uint8_t crc = 0; /* first byte can be 'xored' in */ for (size_t j = 0; j &lt; length; j++) { crc ^= bytes[j]; /* XOR-in the next input byte */ for (int i = 0; i &lt; 8; i++) { if ((crc &amp; 0x80) != 0) crc = (crc &lt;&lt; 1) ^ generator; else crc &lt;&lt;= 1; } } return crc; } CRC-32 实现 生成多项式取 33-bit，这里使用 0x04C11DB7(省略最高位的 1)。 类似，可以逐个字节进行计算 #include &lt;cstdint&gt; uint32_t Compute_CRC32_Simple(const unsigned char* bytes, size_t length){ const uint32_t polynomial = 0x04C11DB7; /* divisor is 32bit */ uint32_t crc = 0; /* CRC value is 32bit */ for (size_t j = 0; j &lt; length; j++){ crc ^= (uint32_t)(bytes[j] &lt;&lt; 24); /* move byte into MSB of 32bit CRC */ for (int i = 0; i &lt; 8; i++){ if ((crc &amp; 0x80000000) != 0) /* test for MSB = bit 31 */ crc = (uint32_t)((crc &lt;&lt; 1) ^ polynomial); else crc &lt;&lt;= 1; } } return crc; } 附录 http://www.sunshine2k.de/coding/javascript/crc/crc_js.html ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"Understanding and implementing CRC","feature":"","link":"https://blog.qxxiao.eu.org/post/understanding-and-implementing-crc/","stats":{"text":"5 min read","time":277000,"words":1119,"minutes":5},"date":"2023-05-01 16:29:24","dateFormat":"2023-05-01","isTop":false},{"content":"熵 Entropy 的定义 离散型随机变量 XXX (字母表为 X\\mathcal{X}X，概率函数 p(x)=Pr(X=x),x∈Xp(x) = Pr(X=x), x\\in \\mathcal{X}p(x)=Pr(X=x),x∈X)，entropy 熵定义为： H(X)=−∑x∈Xp(x)log⁡p(x)=−Elog⁡p(x)H(X) = - \\sum\\limits_{x\\in \\mathcal{X}} p(x)\\log p(x) = -E\\log p(x) H(X)=−x∈X∑​p(x)logp(x)=−Elogp(x) 0log⁡0→00\\log 0 \\rightarrow 00log0→0 (xxx 趋近于 0，xlog⁡xx\\log xxlogx 趋近于 0 ) H(X)≥0H(X)\\ge 0H(X)≥0 当 XXX 是在 X\\mathcal{X}X 服从均匀分布时，H(X)=log⁡∣X∣H(X) = \\log |\\mathcal{X}|H(X)=log∣X∣ Hb(X)=log⁡baHa(X)H_b(X)= \\log_{b}a H_a(X)Hb​(X)=logb​aHa​(X) - 算法/定义中的对数如果以 bbb 为底，熵记作 Hb(X)H_b(X)Hb​(X) - 以 2 为底，单位为 bits - 以自然常数 e 为底，单位为 nats （衡量信息量大小，不确定性大小） 例子 二进制熵函数 Let X={1with probablity pxwith probability 1−p\\text{Let }X = \\begin{cases} 1 &amp; \\text{with probablity }p\\\\ x &amp; \\text{with probability }1-p \\end{cases} Let X={1x​with probablity pwith probability 1−p​ 系统的熵： H(x)=−plog⁡p−(1−p)log⁡(1−p)H(x)=-p\\log p - (1-p)\\log(1-p)H(x)=−plogp−(1−p)log(1−p) ，关系如下： 性质 说明： 凹函数(凹向下)的性质 [1] 这里的 λ1,λ2,⋯\\lambda_{1},\\lambda_{2},\\cdotsλ1​,λ2​,⋯ 取值都是 1∣X∣\\frac{1}{|\\mathcal{X}|}∣X∣1​ 当且仅当，均匀分布取到最大熵 (均匀分布最大化离散熵) 根据熵的定义，它只由概率分布确定，根据概率分布，可以得到联合熵、条件熵，链式法则。 概率统计中的法则 链式法则：p(x1,x2,⋯ ,xn)=p(xn)p(xn−1∣xn)⋯p(x1∣x2,⋯ ,xn−1)p(x_1,x_2,\\cdots,x_{n)}=p(x_n)p(x_{n-1}|x_{n})\\cdots p(x_1|x_2,\\cdots,x_{n-1})p(x1​,x2​,⋯,xn)​=p(xn​)p(xn−1​∣xn​)⋯p(x1​∣x2​,⋯,xn−1​) 贝叶斯规则：p(y)p(x∣y)=p(x)p(y∣x)p(y)p(x|y)=p(x)p(y|x)p(y)p(x∣y)=p(x)p(y∣x) 联合熵 Joint Entropy 条件熵 Conditional Entropy 条件熵 H(Y∣X)H(Y|X)H(Y∣X) 是，在 p(Y∣X=x)p(Y|X=x)p(Y∣X=x) 上定义的熵，对 x 取加权平均；或者直接根据期望计算。 根据期望计算时，使用的是 p(x,y)p(x,y)p(x,y) 例子 条件熵不可交换变量的位置 H(X∣Y)+H(Y)=H(Y∣X)+H(X)=H(X,Y)\\boldsymbol{H}(\\boldsymbol{X} \\mid \\boldsymbol{Y})+\\boldsymbol{H}(\\boldsymbol{Y})=\\boldsymbol{H}(\\boldsymbol{Y} \\mid \\boldsymbol{X})+\\boldsymbol{H}(\\boldsymbol{X})=\\boldsymbol{H}(\\boldsymbol{X}, \\boldsymbol{Y})H(X∣Y)+H(Y)=H(Y∣X)+H(X)=H(X,Y) 可以根据定义的期望公式证明，参考下面的链式法则 可以从信息的不确定性来理解 链式法则 零熵 Zero Entropy 说明：如果熵 H(X)=0H(X)=0H(X)=0 ，对于离散变量 XXX，其概率分布只有一个取值 Pr(X=x0)=1Pr(X=x_0)=1Pr(X=x0​)=1 由 H(Y∣X)=0⟹H(Y∣X=x)=0H(Y|X)=0 \\Longrightarrow H(Y|X=x)=0H(Y∣X)=0⟹H(Y∣X=x)=0 ，根据它的定义容易得到； 由 H(Y∣X=x)=0H(Y|X=x)=0H(Y∣X=x)=0，容易知道 Y 在 X=xX=xX=x 下只有一个确定的取值； Y 是 X 的函数。 相对熵 Relative Entropy 相对熵：用来度量两个概率分布的距离 相对熵 (Kullback-Leibler(KL)距离) ，在字母表 X\\mathcal{X}X 上的两个概率分布函数 p(x),q(x)p(x),q(x)p(x),q(x) 的 KL 距离定义为： D(p∥q)=∑x∈Xp(x)log⁡p(x)q(x)=Eplog⁡p(X)q(X)\\begin{aligned} D(p \\| q)= &amp; \\sum_{x \\in X} p(x) \\log \\frac{p(x)}{q(x)} \\\\ &amp; =E_p \\log \\frac{p(X)}{q(X)} \\end{aligned} D(p∥q)=​x∈X∑​p(x)logq(x)p(x)​=Ep​logq(X)p(X)​​ 说明： Not Metric 相对熵不是一种 Metric 测度 互信息 Mutual Information 互信息，用来衡量两个随机变量的关联程度（相互拥有的信息量），使用相对熵【p(x,y) 与 p(x)p(y)】来定义： 互信息的两个变量可以交换位置 两个相互独立的互信息为 0；同一个变量的互信息为它的熵 互信息 I(X;Y)I(X;Y)I(X;Y) 中，使用分号 ; 分隔两个变量 Venn 图 使用 Venn 图理解多个信息量的度量 多个变量的链式法则 条件互信息 为了描述在变量 ZZZ 给定条件下，变量 X,YX,YX,Y 的互信息量(符号中 ∣Z\\mid Z∣Z 是整体，表示条件 ZZZ) 条件相对熵 条件相对熵和相对熵的链式法则： 链接 中山大学教学资料 信息论基础中文版-Cover 英文版-Cover An Introduction to Single-User Information Theory.pdf 函数的凹凸性 ↩︎ ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"信息论基础","feature":"","link":"https://blog.qxxiao.eu.org/post/信息论基础/","stats":{"text":"6 min read","time":336000,"words":1174,"minutes":6},"date":"2023-04-27 17:48:27","dateFormat":"2023-04-27","isTop":false},{"content":"简介 基础 密码分析学 密码分析者攻击密码体制的方法： 穷举攻击：通过试遍所有的密钥进行破译 对抗：增大密钥的数量 统计分析攻击：通过分析密文和明文的统计规律破译 对抗：设法使明文和密文的统计规律不一样 解密变换攻击：针对加密变换的数学基础，通过数学求解设法找到解密变换 对抗：选用具有坚实的数学基础和足够复杂的加密算法 根据攻击强度，可以分为：唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击，强度越来越强。 安全性： 无条件安全：无论截获多少密文，都没有足够信息来唯一确定明文，即对算法的破译不比猜测有优势； 计算上安全：使用有效资源对一个密码系统进行分析而未能破译； 古典密码算法 置换密码 对明文字符进行位置移动的密码 单表代替密码 用密码字母表中字母代替明文字母 多表代换密码 在模数 NNN 下的矩阵乘法中，矩阵 AAA 只有在满足 gcd(Adet,N)=1gcd(A_{det}, N) = 1gcd(Adet​,N)=1 的情况下才有逆矩阵。这是因为在模数 NNN 下，只有与 NNN 互质的数才有模 NNN 下的乘法逆元。如果 gcd(Adet,N)≠1gcd(A_{det}, N) \\neq 1gcd(Adet​,N)​=1，则 AAA 的行列式 AdetA_{det}Adet​ 和模数 NNN 不互质，因此 AAA 没有模 NNN 下的乘法逆元，也就没有逆矩阵。 有限域 例如，Zn={0,1,2,⋯ ,n−1}mod nZ_{n}= \\{ 0,1,2,\\cdots,n-1 \\}_{mod\\ n}Zn​={0,1,2,⋯,n−1}mod n​ 并且加法和乘法都是模 nnn 的运算，ZnZ_nZn​ 的数什么时候有乘法逆元呢？ 整数 a 在模 n 乘法下有逆元，当且仅当 a 与 n 互素。 所有与 n 互素的元素在模 n 乘法下构成乘法交换群(交换律) 1...n-1 都与 n 互素，则 n 为素数 所以，对于任何一个素数 p，ZpZ_pZp​ 为域，其元素的个数为 p 个。 定义有限域上的多项式 F[x]F[x]F[x] 和 n 次多项式 f(x)f(x)f(x)，F[x]/f(x)={r(x)=rn−1xn−1+rn−1xn−2+⋯+r1x+r0 ∣ ri∈F,0≤i≤n−1}F[x]/f(x)=\\{ r(x) = r_{n-1}x^{n-1} + r_{n-1}x^{n-2}+\\cdots+r_1x+r_{0}\\ |\\ r_{i}\\in F, 0\\le i \\le n-1 \\}F[x]/f(x)={r(x)=rn−1​xn−1+rn−1​xn−2+⋯+r1​x+r0​ ∣ ri​∈F,0≤i≤n−1} ，加法和乘法都是模 f(x)f(x)f(x) 的运算，运算是封闭的。那么 F[x]/f(x)F[x]/f(x)F[x]/f(x) 中的多项式什么时候有乘法逆元呢？ r(x)r(x)r(x) 在模 f(x)f(x)f(x) 的乘法下有逆元，当且仅当 r(x)r(x)r(x) 与 f(x)f(x)f(x) 互素。 所有与 f(x)f(x)f(x) 互素的元素在模 f(x)f(x)f(x) 的乘法下构成乘法交换群 次数比 f(x)f(x)f(x) 次数低的多项式都与 f(x)f(x)f(x) 互素，则 f(x)f(x)f(x) 为不可约多项式 对于任意一个首项系数为 1 的不可约多项式，F[x]/f(x)F[x]/f(x)F[x]/f(x) 为域 若 F=ZpF=Z_pF=Zp​，则 F[x]/f(x)F[x]/f(x)F[x]/f(x) 中元素的个数为 pnp^npn 个 说明：pnp^npn 域的构造方法，首先选取 ZpZ_pZp​ 中的一个 n 次不可约多项式，然后构造集合 F[x]/f(x)={r(x)=rn−1xn−1+rn−1xn−2+⋯+r1x+r0 ∣ ri∈F,0≤i≤n−1}F[x]/f(x)=\\{ r(x) = r_{n-1}x^{n-1} + r_{n-1}x^{n-2}+\\cdots+r_1x+r_{0}\\ |\\ r_{i}\\in F, 0\\le i \\le n-1 \\}F[x]/f(x)={r(x)=rn−1​xn−1+rn−1​xn−2+⋯+r1​x+r0​ ∣ ri​∈F,0≤i≤n−1}，集合中的加法和乘法运算都为模多项式 f(x)f(x)f(x) 的运算。 资料 中科大-现代密码学 密码学 Cryptography_and_Network_Security Principles_and_Practice-5th_edition.pdf 信息论与编码技术 电子科技大学-现代密码学 课件(密码 miao) 密码学基础文章 附录 群和域 群和域都是抽象代数中的基本概念，它们都是一种代数结构。 群是一个集合 GGG 和一个二元运算 ⋅\\cdot⋅ 的组合 (G,⋅)(G, \\cdot)(G,⋅)，满足以下四个条件： 封闭性：对于任意 a,b∈Ga, b \\in Ga,b∈G，a⋅b∈Ga \\cdot b \\in Ga⋅b∈G。 结合律：对于任意 a,b,c∈Ga, b, c \\in Ga,b,c∈G，(a⋅b)⋅c=a⋅(b⋅c)(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)(a⋅b)⋅c=a⋅(b⋅c)。 单位元：存在一个元素 e∈Ge \\in Ge∈G，使得对于任意 a∈Ga \\in Ga∈G，a⋅e=e⋅a=aa \\cdot e = e \\cdot a = aa⋅e=e⋅a=a。 逆元：对于任意 a∈Ga \\in Ga∈G，存在一个元素 a−1∈Ga^{-1} \\in Ga−1∈G，使得 a⋅a−1=a−1⋅a=ea \\cdot a^{-1} = a^{-1} \\cdot a = ea⋅a−1=a−1⋅a=e。 换句话说，群是一个满足封闭性、结合律、单位元和逆元的代数结构。群中的元素可以是任何东西，例如数字、矩阵、函数等等。群的一个重要性质是它的元素可以进行交换（即满足交换律）或者不可以进行交换（即不满足交换律），分别称为交换群和非交换群。 域是一个集合 FFF 和两个二元运算 +++ 和 ⋅\\cdot⋅ 的组合 (F,+,⋅)(F, +, \\cdot)(F,+,⋅)，满足以下条件： (F,+)(F, +)(F,+) 是一个交换群，其中 000 是加法的单位元，对于任意 a∈Fa \\in Fa∈F，存在一个元素 −a∈F-a \\in F−a∈F，使得 a+(−a)=(−a)+a=0a + (-a) = (-a) + a = 0a+(−a)=(−a)+a=0。 (F∖{0},⋅)(F \\setminus \\{0\\}, \\cdot)(F∖{0},⋅) 是一个交换群，其中 111 是乘法的单位元，对于任意 a∈F∖{0}a \\in F \\setminus \\{0\\}a∈F∖{0}，存在一个元素 a−1∈F∖{0}a^{-1} \\in F \\setminus \\{0\\}a−1∈F∖{0}，使得 a⋅a−1=a−1⋅a=1a \\cdot a^{-1} = a^{-1} \\cdot a = 1a⋅a−1=a−1⋅a=1。 分配律：对于任意 a,b,c∈Fa, b, c \\in Fa,b,c∈F，a⋅(b+c)=a⋅b+a⋅ca \\cdot (b + c) = a \\cdot b + a \\cdot ca⋅(b+c)=a⋅b+a⋅c 和 (a+b)⋅c=a⋅c+b⋅c(a + b) \\cdot c = a \\cdot c + b \\cdot c(a+b)⋅c=a⋅c+b⋅c。 换句话说，域是一个满足加法和乘法都是交换群，并且满足分配律的代数结构。 ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"}],"title":"密码学简介","feature":"","link":"https://blog.qxxiao.eu.org/post/密码学简介/","stats":{"text":"8 min read","time":438000,"words":1649,"minutes":8},"date":"2023-04-25 23:54:32","dateFormat":"2023-04-25","isTop":false},{"content":"Shamir’s Secret Sharing 方案是一种重要的加密算法，它允许私人信息 secret (机密)在一个不受信任的网络中安全地分发。 secret sharing 在密码学中，secret sharing 是一种安全地分发重要私人信息片段给分布式网络或群体的方法，这使得此类方案特别适用于保护高度敏感的信息，如私有加密密钥或生物识别数据。 secret sharing 通过将私人信息分割成更小的部分 shares，然后在群组或网络中分发这些 shares 来实现。 每个单独的 share 本身是无用的，但是获取所有的 shares 可以重建原始的 secret。 在大多数方案中，实施了一个额外的加密层，以确保额外的隐私和安全，允许在 secret 所有者不知道的网络或团体中分发 shares。 例如，每个 share 分配者只有一个看起来随机的数(share)： 19_____, _5____, __3___, ___18__, ____5_,_____20 通过加密，当获取到所有的 shares (例如上述的数字)，仍然需要解密密钥来得到原始的 secret (例如上述中表示其对应字母表中顺序)。这一重要步骤可以保护私人信息免受有组织的攻击，即使每个 shareholder 都勾结起来重新创建原始秘密，他们也无法了解该秘密的任何信息，因为原始秘密已经加密。 Shamir’s Scheme 问题：分发的 shares 可能丢失或被泄漏。 shareholder 可能不在线，或者丢失自己的 share 或者被窃取；此外 shareholder 可能称为敌对方。如果要使用所有的 share 来重构 secret 可能会变得不实际和低效。 Shamir’s Secret Sharing 是以色列密码学家 Adi Shamir 1979 年首次提出的算法。它允许信息被分成多份 (shares)，只需要一部分 shares 就可以重建原始 secret。需要的最小数量称为阈值。 原理 SSS(Shamir’s Secret Sharing) 依赖多项式插值，构造一个 LLL 次多项式函数 f(x)f(x)f(x) 将 secret s 分成 nnn 个 share，使得： f(0)=sf(0)=sf(0)=s share1=f(1),share2=f(2),⋯ ,sharen=f(n)\\textbf{share}_{1}= f(1),\\textbf{share}_{2}= f(2),\\cdots,\\textbf{share}_{n}= f(n)share1​=f(1),share2​=f(2),⋯,sharen​=f(n) 其中： 任何 ≤L\\le L≤L 数量的 shares 组合不能了解到 secret s 任何信息 任何 &gt;L&gt; L&gt;L 数量的 shares 可以得到完整的 secret s 解码 使用 Lagrange interpolation，例如使用 3 次多项式，获得了 f(5)=3,f(7)=2,f(12)=6,f(30)=15f(5)=3,f(7)=2,f(12)=6,f(30)=15f(5)=3,f(7)=2,f(12)=6,f(30)=15 可以构造原多项式： secret 就是计算 f(0) 当然，有限域中也是成立的，表达式中的除法改用元素的逆元计算 隐私保护 Shamir’s Secret Sharing 使互不相识的多方有可能存储私人信息。因为 Shamir 方案在信息理论上是安全的，即使是拥有无限计算能力的攻击者，如果没有足够的 share 来满足阈值(最低份 share)，也无法破解解密的 share 来访问数据。 该方案可以扩展为，对 secret 的 share 执行计算并且将组合起来得到 secret 的计算的结果(同态计算)，而不需要将 secret 先解密出来。 当与其他加密技术相结合时，如安全多方计算和零知识密码学，SSS 提供了一个额外的安全层，使数据共享和存储安全、私密，并能抵御意外的数据丢失和外部攻击。 链接 https://web.mit.edu/6.857/OldStuff/Fall03/ref/Shamir-HowToShareASecret.pdf Simple introduction to Shamir's Secret Sharing and Lagrange interpolation Basics of Secure Multiparty Computation Finite Fields in Cryptography | Introduction to GF ","tags":[{"name":"Paper","slug":"paper","used":true,"link":"https://blog.qxxiao.eu.org/tag/paper/"}],"title":"Shamir’s Secret Sharing","feature":"","link":"https://blog.qxxiao.eu.org/post/shamirs-secret-sharing/","stats":{"text":"4 min read","time":228000,"words":957,"minutes":4},"date":"2023-04-13 15:50:21","dateFormat":"2023-04-13","isTop":false},{"content":"说明 翻译使用 Bob 以及 Mac 自带字典软件，为了高效查询单词的含义使用添加外部字典《朗文当代高级英语词典》方式。浏览器大段文章使用沉浸式翻译插件更好，其它情况翻译使用 Bob + DeepL 更快。更加复杂的翻译可以使用 MacGPT/ChatGPT 翻译并解释。 字典使用场景： 三指点击查询（推荐） 配合 Alfred （define 单词 =&gt; tr 单词） 使用聚焦搜索快速浏览，输入单次后使用 cmd+L 定位到单词定义 使用 Alfred 效果（需要 Enter 打开字典）： 下载地址 下载地址 更多字典下载 下载解压后拖入 ~/Library/Dictionaries/ 即可，重启字典程序。 其它 如果希望禁用 MacOS 下特定程序的暗黑模式，执行如下命令： 查询应用捆绑的 id，其中程序名称可以查询简介等获取 osascript -e 'id of app &quot;&lt;App-Name&gt;&quot;' 写入属性 AquaSystemAppearance，其中 ID 为上条命令返回的结果 defaults write &lt;Bundle-Identifier&gt; NSRequiresAquaSystemAppearance -bool yes 恢复，删除该属性值即可： defaults delete &lt;Bundle-Identifier&gt; NSRequiresAquaSystemAppearance ","tags":[{"name":"Mac","slug":"mac","used":true,"link":"https://blog.qxxiao.eu.org/tag/mac/"}],"title":"Mac 字典和翻译","feature":"https://pic.qxxiao.cn/202304051940623.png","link":"https://blog.qxxiao.eu.org/post/mac字典和翻译/","stats":{"text":"2 min read","time":66000,"words":291,"minutes":2},"date":"2023-04-05 19:32:35","dateFormat":"2023-04-05","isTop":false},{"content":"https://go.dev/ref/mem The Go Memory Model 整理学习。 Go 内存模型规定了，在一个 goroutine 中读取一个变量时，可以保证观察到不同 goroutine 中对同一变量的写入所产生的值的条件。 数据竞争：对一个内存位置的写与对同一位置的另一个读或写同时发生，除非所有涉及的访问都是同步/原子包提供的原子数据访问。 内存模型 内存操作由四个细节描述： 它的类型，指示它是普通数据读取、普通数据写入还是同步操作，例如原子数据访问、互斥操作或通道操作。 它在程序中的位置。 正在访问的内存位置或变量。 操作读取或写入的值。 要求 1：每个 goroutine 中的内存操作必须对应于该 goroutine 的正确顺序执行，考虑从内存中读取和写入的值。该执行必须与 sequenced before 关系一致，该关系定义为 Go 语言规范对于 Go 控制流构造的部分顺序要求以及表达式的求值顺序。 【Go 程序执行被建模为一组 goroutine 执行，以及一个映射 W，指定每个类似读取的操作从哪个类似写入的操作中读取。】 要求 2：对于给定的程序执行，当限制为同步操作时，映射 W 必须可以通过一些隐含的同步操作的总序来解释，该总序与这些操作读取和写入的值以及顺序一致。 synchronized before 关系是从 W 派生的同步内存操作的偏序关系。如果同步读取类内存操作 r 观察到同步写入类内存操作 w（即，如果 W(r) = w），则 w 在 r 之前同步。 happens before 关系被定义为 sequenced before 关系和 synchronized before 的并集的传递闭包。 要求 3：对于内存位置 x 上的普通（非同步）数据读取 r，W(r) 必须是对 r 可见的写入 w，其中“可见”意味着以下两个条件都成立： w 在 r 之前发生。 w 不在任何其他写入 w'（到 x）之前发生，而这些写入 w' 在 r 之前发生。 【简单来说，对于一个内存位置 x，如果一个普通数据读取 r 读取了该位置的值，那么它必须读取到最近的写入 w 的值，该写入 w 满足 w 在 r 之前发生，并且没有其他写入 w' 在 w 和 r 之间发生。这个要求确保了内存读取操作读取到的是最近的写入操作的值，而不是过时的值。】 对含数据竞争的限制 任何实现都可以在检测到数据竞争时报告该竞争并停止程序的执行。使用 ThreadSanitizer（通过 go build -race 访问）的实现正是这样做的。 同步 初始化 程序的初始化是在一个单独的 goroutine 中运行； 如果 p 包导入 q 包，那么 q 包的 init函数 是 happen before p 包任何函数； 所有的 init 函数 的完成是 synchronized before 主包中的 main.main 函数执行。 【Go 程序中，程序的初始化过程是由一个单独的 goroutine 负责，该 goroutine 会按照包的导入顺序依次执行每个包的 init 函数，直到所有包的 init 函数都被执行完毕包括主包的 init 函数。最后启动新的主 goroutine 运行 main 函数。】 Goroutine 创建 创建新 goroutine 的 go 语句 synchronized before 这个 goroutine 的执行开始。 Goroutine 销毁 不能保证 goroutine 的退出 synchronized before 于程序中的任意事件。 Channel 通信 通道通信是 goroutine 之间同步的主要方法。一个特定通道上的每一个发送都与该通道的相应接收相匹配，通常是在一个不同的 goroutine 中。 一个 channel 的一次 send 是 synchronized before 于该 channel 上其对应 receive 的完成。 var c = make(chan int, 10) var a string func f() { a = &quot;hello, world&quot; c &lt;- 0 // close(c) } func main() { go f() &lt;-c print(a) } 例子保证会打印 &quot;hello world&quot;。对 a 的写是 sequence before 于 c 的发送，c 的发送是 synchronize before 于对应(int) c 的接收，而 c 的接收 sequence before 于打印。 channel 的关闭是 synchronized before 其对应的 receive，并且由于通道关闭，接收返回的是通道元素类型的零值。 无缓冲 channel 的 receive 是 synchronized before 于该通道其对应 send 的完成。 使用无缓冲 channel 改写： var c = make(chan int) var a string func f() { a = &quot;hello, world&quot; &lt;-c } func main() { go f() c &lt;- 0 print(a) } 容量为 C 的 channel 的第 k 次 receive 是 synchronized before 于该通道的第 k+C 次 send 的完成。 【容量为 C 的 channel 使用信号量来实现】 使用缓冲的 channel 来限制并发执行任务的数量： var limit = make(chan int, 3) func main() { for _, w := range work { go func(w func()) { limit &lt;- 1 w() &lt;-limit }(w) } select{} // 一直阻塞 } Locks sync package 实现了两种锁 lock 数据类型：sync.Mutex 以及 sync.RWMutex。 对于任何 sync.Mutex 或 sync.RWMutex 变量 l，并且 n&lt;mn&lt;mn&lt;m ，前 n 次调用 l.Unlock() 完成是 synchronized before 于第 m 次 l.Lock() 返回。 对于任何对 sync.RWMutex 变量 l 的 l.RLock() 调用，都存在一个 n，使得第 n 次调用 l.Unlock() 是 synchronized before 于 l.RLock() 返回，并且对应的 l.RUnlock() 调用完成 synchronized before 于第 n+1 次对 l.Lock() 的调用返回。 【就内存模型而言，l.TryLock（或 l.TryRLock）可以被认为是能够返回 false 的，即使是在 mutex l 是解锁状态。】 Once sync package 通过 Once 类型为存在多 goroutine 情况下的初始化提供了一种安全机制。 多个线程为函数 f 可执行 once.Do(f)，只有一个 goroutine 执行 f 函数，其它 goroutine 会阻塞直到该 f 函数返回。 【使用 done 标志和互斥锁实现 】 once.Do(f) 中该单次 f 调用完成是 synchronized before 于任何 once.Do(f) 调用的返回。 例如： var a string var once sync.Once func setup() { a = &quot;hello, world&quot; } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } // &quot;hello, world&quot; will be printed twice. Atomic Values sync/atomic 包中的 API 是“原子操作”，可用于同步不同 goroutine 的执行。如果原子操作 A 的效果被原子操作 B 观察到，则 A 在 B 之前同步。程序中执行的所有原子操作都表现为按某种顺序连续执行的顺序一致。这个定义与 C++的顺序一致原子(变量)和 Java 的 volatile 变量具有相同的语义。 Finalizers 在 Go 语言中，Finalizer 是一种机制，用于在对象被垃圾回收器回收之前执行一些清理操作。Finalizer 是通过 runtime.SetFinalizer 函数设置的，该函数接受两个参数：要设置 Finalizer 的对象和一个函数，该函数将在对象被垃圾回收器回收之前执行。 当一个对象被创建时，Go 语言的垃圾回收器会为其分配内存，并将其标记为“可达”。如果该对象不再被引用，垃圾回收器会将其标记为“不可达”，并在某个时间点回收该对象的内存。在回收对象之前，垃圾回收器会检查该对象是否有 Finalizer。如果有，垃圾回收器会将该对象添加到一个 Finalizer 队列中，并在下一次垃圾回收时执行 Finalizer 函数。 另外，由于 Finalizer 函数的执行是不确定的(甚至可能不执行)，因此不建议在程序中过多地使用 Finalizer。如果需要释放资源或执行必须的清理操作，应该使用 defer 语句或显式地调用清理函数来实现。 调用 SetFinalizer(x, f) 是 synchronized before 函数 f(x) 的调用。 其它 condition variables, lock-free maps, allocation pools, and wait groups. 错误同步 程序中存在竞争条件时，可能会出现非顺序一致的执行结果。特别地，一个读操作 r 可能会观察到与 r 并发执行的任何写操作 w 所写入的值。即使这种情况发生了，也不能保证在 w 之前发生的写操作会被在 r 之后的读操作所观察到。 var a, b int func f() { a = 1 b = 2 } func g() { print(b) print(a) } func main() { go f() g() } g() 可能打印 2 和 0 （f 函数两个写语句不满足 sequenced before 关系 另一个例子，不正确的忙等待: var a string var done bool func setup() { a = &quot;hello, world&quot; done = true } func main() { go setup() for !done { } print(a) } 可能打印空字符串，main 中观察到写入 done，并不保证已经观察到写入 a。 更糟糕的是：由于两个线程之间没有同步事件，所以也无法保证写入 done 的内容会被 main 观察到，不能保证 main 中的循环能够结束。 需要注意上述问题的解决方法：使用显示的同步语句。 编译优化限制 Go 语言内存模型对编译器优化的限制，一些编译器优化在单线程程序中是有效的，但不是对于所有 Go 程序都是有效的。特别是，编译器不能引入源程序中不存在的写入操作，不允许使得单个读取操作观察到多个不同的值，不允许使得单个写操作写入多个值。【主要目的，避免编译器在优化程序时引入数据竞争以及不确定的行为。】 在没有竞争条件的程序中，不应该将写操作从它们所在的条件语句中移出。(避免其它 goroutine 观察可能观察到原来不可能出现的值) 在没有竞争条件的程序中，编译器不应该假设循环一定会终止。 在没有竞争条件的程序中，编译器不应该假设被调用的函数总是会返回或不包含同步操作。 编译器不允许单个读操作观察到多个值，这意味着编译器不应该从共享内存中重新加载本地变量。 i := *p if i&lt;0 || i&gt;=len(funcs){...} funcs[i]() // 禁止重新加载 *p funcs[*p]() 编译器不允许单个写操作写入多个值(禁止在写入之前把将要写入的局部变量作为临时存储) *p = i + *p/2 // if i=2,*p=2, 只能观察到 *p 为 2/3 // 不能改写为 2/1/3 *p /=2 *p += i 说明：所有这些优化在 C/C++编译器中都是允许的，但是与 C/C++编译器共享后端的 Go 编译器必须注意禁用那些对 Go 无效的优化。 请注意，禁止引入数据竞争的规则不适用于编译器可以证明这些竞争不会影响目标平台上的正确执行的情况。 总结 对于没有数据竞争的程序，可以放心地依赖于顺序一致的执行； 而对于存在数据竞争的程序，应该避免过于聪明的优化，编写易于理解和推理的代码，并使用同步原语来确保程序的正确性。 ","tags":[{"name":"Go","slug":"go","used":true,"link":"https://blog.qxxiao.eu.org/tag/go/"}],"title":"Go 内存模型","feature":"https://pic.qxxiao.cn/golang.png","link":"https://blog.qxxiao.eu.org/post/go内存模型/","stats":{"text":"11 min read","time":652000,"words":2834,"minutes":11},"date":"2023-04-04 09:50:43","dateFormat":"2023-04-04","isTop":false},{"content":"参考资料： https://artofproblemsolving.com/wiki/index.php/LaTeX:Symbols https://mathvault.ca/wp-content/uploads/Comprehensive-List-of-Mathematical-Symbols.pdf https://www.latexlive.com/ 说明 换行 \\\\ 或者 \\newline 换段落 \\par 或者使用空行 latex 源文件连续空格等效于一个，多个空行等效一个空行 使用命令的形式：\\command[option选项参数]{argument参数} latex 进入数学模式 其中 \\[...\\] 与 $$...$$ 等效 equation 环境不能换行，align 环境用于多个方程对齐，gather 环境居中对齐； \\displaystyle 命令用语显示公式完整的行高 运算符 符号 LaTex 符号 LaTex 符号 LaTex 符号 LaTex ±\\pm± \\pm ∓\\mp∓ \\mp ×\\times× \\times ÷\\div÷ \\div ⋅\\cdot⋅ \\cdot ∗\\ast∗ \\ast ⋆\\star⋆ \\star ∙\\bullet∙ \\bullet ∪\\cup∪ \\cup ∩\\cap∩ \\cap ⊔\\sqcup⊔ \\sqcup ⊓\\sqcap⊓ \\sqcap ∨\\vee∨ \\vee ∧\\wedge∧ \\wedge ⊕\\oplus⊕ \\oplus ⊗\\otimes⊗ \\otimes ⊖\\ominus⊖ \\ominus ⊘\\oslash⊘ \\oslash ⊙\\odot⊙ \\odot ⊎\\uplus⊎ \\uplus ∘\\circ∘ \\circ ◯\\bigcirc◯ \\bigcirc ⋄\\diamond⋄ \\diamond ◊\\Diamond◊ \\Diamond ⊲\\lhd⊲ \\lhd ⊳\\rhd⊳ \\rhd ⊴\\unlhd⊴ \\unlhd ⊵\\unrhd⊵ \\unrhd ◃\\triangleleft◃ \\triangleleft ▹\\triangleright▹ \\triangleright △\\bigtriangleup△ \\bigtriangleup ▽\\bigtriangledown▽ \\bigtriangledown ▽\\triangledown▽ \\triangledown □\\Box□ \\Box ∖\\setminus∖ \\setminus ≀\\wr≀ \\wr ⨿\\amalg⨿ \\amalg †\\dagger† \\dagger ‡\\ddagger‡ \\ddagger x∘x^{\\circ}x∘ x^{circ} xn\\sqrt[n]{x}nx​ \\sqrt[n]{x} axyza^{xyz}axyz a^{xyz} axa_xax​ a_x ∞\\infty∞ \\infty ∂\\partial∂ \\partial ∇\\nabla∇ \\nabla 关系符号 ≡\\equiv≡ \\equiv &lt;\\lt&lt; \\lt &gt;\\gt&gt; \\gt ∀\\forall∀ \\forall ∃\\exists∃ \\exists {1,2,⋯ ,n}\\lbrace1,2,\\cdots,n\\rbrace{1,2,⋯,n} \\lbrace1,2,\\cdots,n\\rbrace， \\{1,2,\\cdots,n\\} 希腊字母 箭头 点 符号 LaTex 符号 LaTex ⋅\\cdot⋅ \\cdot ⋮\\vdots⋮ \\vdots …\\dots… \\dots ⋱\\ddots⋱ \\ddots ⋯\\cdots⋯ \\cdots \\iddots \\iddots 声调 括号和边界 使用 \\left，\\right 来标定左右括号进行适当的放大，对一些箭头符号也适用；(ax)2\\left(\\frac{a}{x} \\right)^2(xa​)2 \\left(\\frac{a}{x} \\right)^2 分段函数，使用 cases 环境；f(x)={x2x≥0xx&lt;0f(x) = \\begin{cases} x^2 &amp; x \\ge 0 \\\\ x &amp; x &lt; 0 \\end{cases}f(x)={x2x​x≥0x&lt;0​ f(x) = \\begin{cases} x^2 &amp; x \\ge 0 \\\\ x &amp; x &lt; 0 \\end{cases} a0+a1+a2+⋯+an⎵x\\underbrace{a_0+a_1+a_2+\\cdots+a_n}_{x}xa0​+a1​+a2​+⋯+an​​​ \\underbrace{a_0+a_1+a_2+\\cdots+a_n}_{x} a0+a1+a2+⋯+an⏞x\\overbrace{a_0+a_1+a_2+\\cdots+a_n}^{x}a0​+a1​+a2​+⋯+an​​x​ \\overbrace{a_0+a_1+a_2+\\cdots+a_n}^{x} 其它常见符号 数学常用命令 a3i+1a^{i+1}_3a3i+1​ 1+1x3x+2\\frac{1+\\frac{1}{x}}{3x + 2}3x+21+x1​​ 1+1x3x+2\\dfrac{1+\\dfrac{1}{x}}{3x + 2}3x+21+x1​​ 21+21+21+21\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}}1+1+1+12​2​2​2​ xn\\sqrt[n]{x}nx​ ∑i=1∞1i\\sum_{i=1}^{\\infty}\\frac{1}{i}∑i=1∞​i1​ ∑i=1∞1i\\sum\\limits_{i=1}^{\\infty}\\frac{1}{i}i=1∑∞​i1​ ∏n=15nn−1\\prod_{n=1}^5\\frac{n}{n-1}∏n=15​n−1n​ lim⁡x→∞1x\\lim_{x\\to\\infty}\\frac{1}{x}limx→∞​x1​ lim⁡x→∞1x\\lim\\limits_{x\\to\\infty}\\frac{1}{x}x→∞lim​x1​ log⁡nn2\\log_n n^2logn​n2 ln⁡e\\ln elne 9≡3 mod 69\\equiv 3 \\bmod{6}9≡3mod6 9≡3(mod6)9\\equiv 3 \\pmod{6}9≡3(mod6) 9≡3mod 69\\equiv 3 \\mod{6}9≡3mod6 9≡3(6)9\\equiv 3 \\pod{6}9≡3(6) (n−1r−1)\\binom{n-1}{r-1}(r−1n−1​) (n−1r−1)\\dbinom{n-1}{r-1}(r−1n−1​) Cn−1r−1C_{n-1}^{r-1}Cn−1r−1​ cos⁡2x+sin⁡2x=1\\cos^2 x +\\sin^2 x = 1cos2x+sin2x=1 cos⁡90∘=0\\cos 90^\\circ = 0cos90∘=0 a+bi‾\\overline{a+bi}a+bi​ 747‾\\underline{747}747​ ddx(x2)=2x\\frac{d}{dx}\\left(x^2\\right) = 2xdxd​(x2)=2x ∫2x dx=x2+C\\int 2x\\,dx = x^2+C∫2xdx=x2+C ∫152x dx=24\\int^5_1 2x\\,dx = 24∫15​2xdx=24 ∂2U∂x2+∂2U∂y2\\frac{\\partial^2U}{\\partial x^2} + \\frac{\\partial^2U}{\\partial y^2}∂x2∂2U​+∂y2∂2U​ 14π∮Σ1r∂U∂nds\\frac{1}{4\\pi}\\oint_\\Sigma\\frac{1}{r}\\frac{\\partial U}{\\partial n} ds4π1​∮Σ​r1​∂n∂U​ds ∬\\iint∬ % 1. 上下标 a^{i+1}_3 % 2. 分数 \\frac{1+\\frac{1}{x}}{3x + 2} \\dfrac{1+\\dfrac{1}{x}}{3x + 2} %display 模式 % 3. 连续分数 \\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}} % 4. 根号 \\sqrt[n]{x} % 5. 求和，求积，极限，对数 \\sum_{i=1}^{\\infty}\\frac{1}{i} \\sum\\limits_{i=1}^{\\infty}\\frac{1}{i} \\prod_{n=1}^5\\frac{n}{n-1} \\lim_{x\\to\\infty}\\frac{1}{x} \\lim\\limits_{x\\to\\infty}\\frac{1}{x} \\log_n n^2 \\ln e % 6. 模 9\\equiv 3 \\bmod{6} 9\\equiv 3 \\pmod{6} 9\\equiv 3 \\mod{6} 9\\equiv 3 \\pod{6} % 7. 组合数 \\binom{n-1}{r-1} \\dbinom{n-1}{r-1} %display 模式 C_{n-1}^{r-1} % 8. 三角函数 \\sin \\cos \\tan... \\cos^2 x +\\sin^2 x = 1 \\cos 90^\\circ = 0 % 9. 上下横线 \\overline{a+bi} \\underline{747} % 10. 积分 \\frac{d}{dx}\\left(x^2\\right) = 2x \\int 2x\\,dx = x^2+C %\\,小空格 \\int^5_1 2x\\,dx = 24 \\frac{\\partial^2U}{\\partial x^2} + \\frac{\\partial^2U}{\\partial y^2} \\frac{1}{4\\pi}\\oint_\\Sigma\\frac{1}{r}\\frac{\\partial U}{\\partial n} ds \\iint 数学函数 矩阵 array 环境 (abcdefghi)\\left( \\begin{array}{ccc} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{array} \\right) ⎝⎛​adg​beh​cfi​⎠⎞​ abS001011101110\\begin{array}{|c|c||c|} a &amp; b &amp; S \\\\ \\hline 0&amp;0&amp;1\\\\ 0&amp;1&amp;1\\\\ 1&amp;0&amp;1\\\\ 1&amp;1&amp;0\\\\ \\end{array} a0011​b0101​S1110​​ \\left( \\begin{array}{ccc} a &amp; b &amp; c \\\\ d &amp; e &amp; f \\\\ g &amp; h &amp; i \\end{array} \\right) \\begin{array}{|c|c||c|} a &amp; b &amp; S \\\\ \\hline 0&amp;0&amp;1\\\\ 0&amp;1&amp;1\\\\ 1&amp;0&amp;1\\\\ 1&amp;1&amp;0\\\\ \\end{array} pmatrix 环境 (abcdefghi)\\begin{pmatrix} a &amp; b &amp; c\\\\ d &amp; e &amp; f\\\\ g &amp; h &amp; i \\end{pmatrix} ⎝⎛​adg​beh​cfi​⎠⎞​ \\begin{pmatrix} a &amp; b &amp; c\\\\ d &amp; e &amp; f\\\\ g &amp; h &amp; i \\end{pmatrix} vmatrix 环境 ∣xyzv∣\\begin{vmatrix} x &amp; y \\\\ z &amp; v \\end{vmatrix} ∣∣∣∣​xz​yv​∣∣∣∣​ ∥xyzv∥\\begin{Vmatrix} x &amp; y \\\\ z &amp; v \\end{Vmatrix} ∥∥∥∥​xz​yv​∥∥∥∥​ \\begin{vmatrix} x &amp; y \\\\ z &amp; v \\end{vmatrix} \\begin{Vmatrix} x &amp; y \\\\ z &amp; v \\end{Vmatrix} bmatrix 环境 [0⋯0⋮⋱⋮0⋯0]\\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix} ⎣⎢⎡​0⋮0​⋯⋱⋯​0⋮0​⎦⎥⎤​ {xyzv}\\begin{Bmatrix} x &amp; y \\\\ z &amp; v \\end{Bmatrix} {xz​yv​} \\bigl(\\begin{smallmatrix} a&amp;b\\\\ c&amp;d \\end{smallmatrix}\\bigr) \\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\begin{Bmatrix} x &amp; y \\\\ z &amp; v \\end{Bmatrix} \\bigl(\\begin{smallmatrix} a&amp;b\\\\ c&amp;d \\end{smallmatrix}\\bigr) cases 环境 array 代替 这里不支持 \\mbox，使用 \\text 代替 f(x)={x+7if 5&lt;x;x2−3if −3≤x≤5;−xif x&lt;−3.f(x) = \\left\\{ \\begin{array}{ll} x+7 &amp; \\text{if $5&lt; x$};\\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$};\\\\ -x &amp; \\text{if $x &lt; -3$}.\\end{array} \\right. f(x)=⎩⎨⎧​x+7x2−3−x​if 5&lt;x;if −3≤x≤5;if x&lt;−3.​ x+7if 5&lt;x;x2−3if −3≤x≤5;−xif x&lt;−3.}=f(x)\\left. \\begin{array}{ll} x+7 &amp; \\text{if $5&lt; x$};\\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$};\\\\ -x &amp; \\text{if $x &lt; -3$}. \\end{array} \\right\\} =f(x) x+7x2−3−x​if 5&lt;x;if −3≤x≤5;if x&lt;−3.​⎭⎬⎫​=f(x) cases 环境 f(x)={x+7if 5&lt;x;x2−3if −3≤x≤5;−xif x&lt;−3.f(x) = \\begin{cases} x+7 &amp; \\text{if $5&lt; x$}; \\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$}; \\\\ -x &amp; \\text{if $x &lt; -3$}. \\end{cases} f(x)=⎩⎪⎨⎪⎧​x+7x2−3−x​if 5&lt;x;if −3≤x≤5;if x&lt;−3.​ f(n)={n2,if n is even3n+1,if n is oddf(n) = \\begin{cases} \\dfrac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex] 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} f(n)=⎩⎨⎧​2n​,3n+1,​if n is evenif n is odd​ % 使用 array f(x) = \\left\\{ \\begin{array}{ll} x+7 &amp; \\text{if $5&lt; x$};\\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$};\\\\ -x &amp; \\text{if $x &lt; -3$}.\\end{array} \\right. \\left. \\begin{array}{ll} x+7 &amp; \\text{if $5&lt; x$};\\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$};\\\\ -x &amp; \\text{if $x &lt; -3$}. \\end{array} \\right\\} =f(x) % 推荐使用 amsmath 包cases环境 f(x) = \\begin{cases} x+7 &amp; \\text{if $5&lt; x$}; \\\\ x^2-3 &amp; \\text{if $-3 \\le x \\le 5$}; \\\\ -x &amp; \\text{if $x &lt; -3$}. \\end{cases} f(n) = \\begin{cases} \\dfrac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex] % 使用\\\\[2ex] 适配行高 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} align 环境 网页可能不支持 align ，可以使用 array 来替代 \\begin{align} \\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align} % 对齐和标号 \\begin{align} v + w &amp; = 0 &amp;\\text{Given} \\tag 1\\\\ -w &amp; = -w + 0 &amp; \\text{additive identity} \\tag 2\\\\ -w + 0 &amp; = -w + (v + w) &amp; \\text{equations $(1)$ and $(2)$} \\end{align} 符号样式 \\mathbb 黑板粗体，空心字母，向量或集合的符号 \\mathbf 正粗体 \\mathcal 手写体，大写字母 \\mathfrak 哥特体 RQZFabcwxyz01234567890123456789RQZFRUFL\\begin{aligned} &amp;\\boldsymbol{R\\quad Q\\quad Z\\quad F \\quad abcwxyz} \\\\ &amp;\\mathit{0123456789} \\\\ &amp;\\mathrm{0123456789 \\quad R\\quad Q\\quad Z\\quad F} \\\\ &amp;\\mathscr{R} \\quad \\mathscr{U} \\quad \\mathscr{F}\\quad \\mathscr{L} \\\\ \\end{aligned} ​RQZFabcwxyz01234567890123456789RQZFRUFL​ % 斜粗体，可以加粗所有合法符号 \\boldsymbol{R Q Z F abcwxyz} % 斜体数字 \\mathit{0123456789} % 罗马体 \\mathrm{012…abc…ABC…}或\\operatorname{} % 花体字母 \\mathscr{R U F L} 空格 颜色 字体颜色 {\\color{色调}表达式} \\textcolor[rgb]{0,0,1}{表达式} 背景颜色 \\colorbox{色调}{表达式} Red\\colorbox{Red}{\\color{white}Red}Red​ Blue\\colorbox{Blue}{\\color{white}Blue}Blue​ Aquamarine\\colorbox{Aquamarine}{\\color{white}Aquamarine}Aquamarine​ Orange\\colorbox{Orange}{\\color{white}Orange}Orange​ Cyan\\colorbox{Cyan}{\\color{white}Cyan}Cyan​ ForestGreen\\colorbox{ForestGreen}{\\color{white}ForestGreen}ForestGreen​ SpringGreen\\colorbox{SpringGreen}{\\color{white}SpringGreen}SpringGreen​ Goldenrod\\colorbox{Goldenrod}{\\color{white}Goldenrod}Goldenrod​ 又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么\\textcolor{Blue}{又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么}又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么 又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么\\textcolor{Pink}{又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么}又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么 又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么\\textcolor{ForestGreen}{又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么}又想起你曾说的陪我到最后,暖色的梦变冰凉的枷锁,如果时光倒流我们又能抓得住什么 ","tags":[{"name":"LaTeX","slug":"latex","used":true,"link":"https://blog.qxxiao.eu.org/tag/latex/"}],"title":"LaTeX 数学公式","feature":"https://pic.qxxiao.cn/202303200109311.png","link":"https://blog.qxxiao.eu.org/post/latex数学公式/","stats":{"text":"14 min read","time":795000,"words":2447,"minutes":14},"date":"2023-03-19 19:15:10","dateFormat":"2023-03-19","isTop":false},{"content":"问题 图论中的最短路问题，求两个点之间最短距离（路径）的问题； 规定使用 n: 表示点的数量；m: 表示边的数量；边数 m 是顶点数 n 的平方级别视为稠密图 稠密图使用邻接矩阵存储（使用 g[N][N]） 稀疏图使用邻接表存储（使用数组模拟） 只考虑有向图，如果是无向图则建立 2 条双向边即可；默认只考虑有向图 为了方便记忆和实现，图(树)的邻接矩阵或邻接表都使用 vector&lt;vector&lt;int&gt;&gt; 存储, 根据节点数量初始化行数。 // 1. 邻接矩阵 vector&lt;vector&lt;int&gt;&gt; g(N, vector&lt;int&gt;(N, 0)); // 2. 邻接表 vector&lt;vector&lt;int&gt;&gt; g(N); 算法总结： 单源最短路 求从一个点到其他所有点的最短距离，顶点为 1,2,3...n，求顶点 1 到其他所有顶点的最短路 边权都是正数 Dijkstra 基于贪心算法 朴素的 Dijkstra 算法 O(n2)O(n^2)O(n2) 适用于稠密图，边数多的情形 m=n2m=n^2m=n2，此时比堆优化好 堆优化版 Dijkstra 算法 O(mlogn)O(mlogn)O(mlogn) 适用于稀疏图，m 和 n 同阶的情形 m&lt;n2m&lt;n^2m&lt;n2 朴素 Dijkstra O(n2)O(n^2)O(n2) 稠密图使用邻接矩阵存储 边权是正数时，如果数据出现自环和重边需要预处理： 省略自环 重边只保存最短的边 距离都是单源点 1 号点到其他点的距离，使用 dist[N]数组保存当前距离；维护一个已经确定最小距离的点的集合 S，使用了 st[N]数组来标记： 算法思路： 1. 初始化距离: dist[1] = 0, dist[i!=0] = +∞ 2. for i: 1~n: // 迭代n次，每次得到一个最短路径的点 t &lt;-- 不在S中的点，且距离最近的点 S &lt;-- t（将t加入到S中) 用点t来更新其他点的距离 朴素版 Dijkstra 算法 Dijkstra 求最短路 I #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 510; int n, m; int g[N][N]; // 邻接矩阵 int dist[N]; // 当前顶点 1 到所有点的距离 bool st[N]; // 是否加入集合 S(已知最短距离的点集合) int dijkstra() { // 初始化当前的距离 memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n; i++) { int t = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; st[t] = true; // 更新相邻顶点的距离 for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } //判断 dist[n] if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m--) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); // 处理多重边 g[a][b] = min(g[a][b], c); } int t = dijkstra(); printf(&quot;%d\\n&quot;, t); } 堆优化的 Dijkstra O(mlogn) 稀疏图--使用邻接表存储，方便遍历邻接边，h[N],w[N],e[N],ne[N] 采用 stl 的priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; queue; 堆优化版本 Dijkstra 算法 Dijkstra 求最短路 II #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; using PII = pair&lt;int, int&gt;; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; // 邻接表添加边 a --&gt; b (w=c) void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int dijkstra() { // 初始化距离 memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; // 标记更新过 st[ver] = true; // 只遍历所有的邻边 for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); // 邻接表的表头初始化 memset(h, -1, sizeof h); while (m--) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); // 有重边也不影响，算法会使用最短的来更新 add(a, b, c); } int t = dijkstra(); printf(&quot;%d\\n&quot;, t); return 0; } 这里取出队头后可以添加 dist[ver]=distance ，其可以省略的原因是：由于初始化了起点距离为 0，并且扩展时根据是否距离是否更新更新了距离。 存在负权边 Bellman-Ford 算法 O(nm) SPFA 一般：O(m)，最坏 O(nm); 是 Bellman-Ford 算法的一个优化，效率比 Bellman-Ford 好 但是不是所有的问题都可以用 SPFA 做，例如最短路边数&lt;=k 的最短路，只能使用 Bellman-Ford 算法 Bellman-Ford 算法 O(nm)O(nm)O(nm) 边的存储方式：只要能够遍历所有的边就可以；算法思路： struct edge{ int a,b,w; }edges[N]; for 1:n : // n 次循环 for 所有边 a,b,w // 遍历所有边 (a -&gt; b,(w))进行更新 dist[b]=min(dist[b], dist[a]+w(a,b)); 思想：因为最短路径最多为 n-1 个边的组合; 松弛 n-1 次，一定可以松弛完最远的点，得到所有的最短距离 注意： 每次迭代，是对上一个 dist 数组（同一个状态)进行迭代的，对相同的距离状态进行更新（需要先备份） Bellman-Ford 算法 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 510, M = 10010; int n, m, k; int dist[N], backup[N]; struct Edge { int a, b, w; } edges[M]; int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) { memcpy(backup, dist, sizeof dist); for (int j = 0; j &lt; m; j++) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], dist[a] + w); } } // if (dist[n] &gt; 0x3f3f3f3f / 2) // return -1; // return dist[n]; // -1 也可能是路径长度 return dist[n]; } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; m; i++) { int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; edges[i] = {a, b, w}; } int res = bellman_ford(); if (res &gt; 0x3f3f3f3f / 2) puts(&quot;impossible&quot;); else cout &lt;&lt; res &lt;&lt; endl; return 0; } 说明 迭代 k 次，表示 1 号点不超过 k 条边的最短距离 如果经过 n 次迭代，第 n 次最短路径还有更新，说明这个 n 条边的路径上 n+1 个节点，有环，说明有负环，因此，可以判断有负环，但通常使用 spfa 判断 SPFA （没有负环） 使用邻接表存储，复杂度一般是 O(m)，网格图可能卡成 O(nm) 对 Bellman-Ford 算法的改进，每次迭代中对于任意边a --&gt; b(w)，只有顶点a距离变小了，才有可能更新邻点b的距离 使用一个队列，存储所有距离变小的顶点 a，（优化：使用 st 数组存储顶点是否已经在队列中），算法思路： 1. 初始化距离: dist[1] = 0, dist[i!=0] = +∞ 2. queue &lt;-- {0,1} //顶点 1 入队{距离，编号} while queue 非空： t &lt;-- queue.front() queue.pop() 更新 t 的所有出边的终点的距离 t --&gt; b // 更新 如果 t 不在队列 queue 中，queue &lt;-- t 注意：没有负环，才能直接用 spfa 算法 spfa 求最短路 #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int N = 100010; int n, m; int h[N], e[N], w[N], ne[N], idx; int dist[N]; // 优化: 标记是否在队列中 bool st[N]; void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; } int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; // 只有更新过的点才能更新其他顶点的距离 while (!q.empty()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } return dist[n]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); for (int i = 0; i &lt; m; i++) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); add(x, y, z); } int t = spfa(); if (t &gt; 0x3f3f3f3f / 2) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0; } 判断负环：判断(任意一条)最短路径的长度是否&gt;=n (注意这里需要将所有点预先加入队列)，因为负环可能在某些顶点不可到达 不需要维护绝对距离，维护一个 cnt 数组，存储更新后路径上边数，如果有一路径的边数&gt;=n，说明路径上出现负环： bool spfa() { queue&lt;int&gt; q; // 判断负环 for (int i = 1; i &lt;= n; i++) //可能 1 号点到不了，把所有点都加入 { q.push(i); st[i] = true; } //队列中的点，都是距离缩短的，需要更新它的邻点距离 while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; // 更新路径长度 if (cnt[j] &gt;= n) // 说明有负环 return true; if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } 说明：有负权回路的图，负环不在路径上也可能求到某点的最短路径 多源汇最短路 起点和终点都不确定/都任意，求所有顶点间的最短路 Floyd 算法 O(n^3) 基于动态规划原理 Floyd 算法 O(n3)O(n^3)O(n3) 使用邻接矩阵存储d[N][N]顶点间的距离，自己到自己的距离为 0； 算法思路：分阶段d[k,i,j]=min(d[k-1,i,j], d[k-1,i,k]+d[k-1,k,j]) 需要没有负权环，数据的预处理：自环（正）可以省略，重边取最短的边 #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 210, INF = 1 e 9; int n, m, Q; int d[N][N]; void floyd() { for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (i == j) d[i][j] = 0; else d[i][j] = INF; while (m--) { int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; d[a][b] = min(d[a][b], w); } floyd(); while (Q--) { int a, b; cin &gt;&gt; a &gt;&gt; b; if (d[a][b]&gt;INF/2) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt;d[a][b]&lt;&lt;endl; } } 链接 最短路算法模版 ","tags":[{"name":"Algorithm","slug":"algorithm","used":true,"link":"https://blog.qxxiao.eu.org/tag/algorithm/"}],"title":"图论-最短路问题","feature":"https://pic.qxxiao.cn/algorithm.png","link":"https://blog.qxxiao.eu.org/post/最短路问题/","stats":{"text":"13 min read","time":752000,"words":2623,"minutes":13},"date":"2023-03-15 17:35:00","dateFormat":"2023-03-15","isTop":false},{"content":"背包问题 https://www.cnblogs.com/jbelial/articles/2116074.html 背包问题 01 背包问题 完全背包问题 多重背包问题 混合背包问题 二维费用的背包问题 分组背包问题 有依赖的背包问题 背包问题求方案数 求背包问题的方案 01 背包问题 https://www.acwing.com/problem/content/2/ 有 NNN 件物品和一个容量是 VVV 的背包。每件物品只能使用一次。第 iii 件物品的体积是 viv_ivi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 注意的点： 空间优化：使用一个一维数组即可，每次保存上一层的计算结果，然后从后往前计算(保证逻辑等价即可)。 如果考虑体积恰好等于 VVV 的最大价值，只需要将 f[0][0]f[0][0]f[0][0] 初始化为 0，f[0][j≠0]f[0][j\\neq 0]f[0][j​=0] 初始化为负无穷，保证如果结果不是从 f[0][0]f[0][0]f[0][0] 递推出来的为负无穷，最后判断最大的结果 max⁡{f[n][m=0,1...n]}\\max\\{f[n][m=0,1...n]\\}max{f[n][m=0,1...n]} #include&lt;iostream&gt; using namespace std; const int N=1010; int v[N], w[N]; int f[N][N]; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { f[i][j]=f[i-1][j]; if(j&gt;=v[i]) f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i]); } } cout&lt;&lt;f[n][m]&lt;&lt;endl; } 完全背包问题 https://www.acwing.com/problem/content/3/ 有 NNN 种物品和一个容量是 VVV 的背包，每种物品都有无限件可用。第 iii 种物品的体积是 viv_ivi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 优化空间化的形式与 01 背包相似，体积循环的方向从小到大 /** * 1. 01背包 f[i][j]=max(f[i-1][j], f[i-1][j-v]+w); * 2. 完全背包 f[i][j]=max(f[i-1][j], f[i][j-v]+w); * */ #include&lt;iostream&gt; using namespace std; const int N=1010; int n,m; int v[N], w[N]; int f[N][N]; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=m; j++) { f[i][j] = f[i-1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j], f[i][j-v[i]]+w[i]); } } cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0; } 多重背包问题 https://www.acwing.com/problem/content/4/ 有 NNN 种物品和一个容量是 VVV 的背包。第 iii 种物品最多有 sis_isi​ 件，每件体积是 viv_ivi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 点击查看代码-优化空间的写法 #include&lt;iostream&gt; using namespace std; const int N=110; int n,m; int f[N]; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) { int v,w,s; cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; // 优化同01背包 for(int j=m; j&gt;=0; j--) for(int k=1; k&lt;=s &amp;&amp; k*v &lt;=j; k++) f[j]=max(f[j], f[j-k*v]+k*w); } cout&lt;&lt;f[m]&lt;&lt;endl; return 0; } 注意的点： 二进制优化方法：如果 SSS 范围较大，可以将 SSS 用 ⌊log2S⌋+1\\lfloor{log_2S}\\rfloor+1⌊log2​S⌋+1 个数来表示 (即二进制 1,2,4...1,2,4...1,2,4... 划分，但是不能超界)，然后使用 01 背包问题求解。复杂度 O(NVlnS)O(NVlnS)O(NVlnS) 题目和代码 单调队列优化方法：将循环的体积分为 vvv 类，使用单调队列优化。(算法题中使用 deque 可能会卡常数，使用数组模拟) 题目和代码 单调队列优化方法： 代码： #include&lt;iostream&gt; #include&lt;deque&gt; #include&lt;cstring&gt; using namespace std; const int N=20010; //V int n,m; int f[N], g[N]; // g[N]作为滚动数组 deque&lt;int&gt; q; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) { int v,w,s; cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; memcpy(g, f, sizeof f); for(int j=0; j&lt;v; j++) //remain { //每次需要重新清空队列 q.clear(); for(int k=j; k&lt;=m; k+=v) //遍历j j+v j+2v ...;窗口大小为s { if(!q.empty() &amp;&amp; q.front()&lt;k-s*v) //前s个(不包括k) q.pop_front(); //先更新结果，f[k]与该元素前s窗口元素的max if(!q.empty()) f[k]=max(f[k], g[q.front()]+(k-q.front())/v * w); //insert while(!q.empty() &amp;&amp; g[q.back()]-(q.back()-j)/v *w &lt;= g[k]-(k-j)/v *w) //while (hh &lt;= tt &amp;&amp; g[q[tt]] &lt;= g[k] - (k - q[tt]) / v * w) tt -- ; q.pop_back(); q.push_back(k); } } } cout&lt;&lt;f[m]&lt;&lt;endl; return 0; } 混合背包问题 https://www.acwing.com/problem/content/7/ 有 NNN 种物品和一个容量是 VVV 的背包。物品一共有三类： 第一类物品只能用 1 次（01 背包）； 第二类物品可以用无限次（完全背包）； 第三类物品最多只能用 sis_isi​ 次（多重背包）； 每种体积是 viv_ivi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 利用二进制优化，全部转换为 01 背包和完全背包，然后求解每一层(列举物品) 二维费用的背包问题 https://www.acwing.com/problem/content/8/ 有 NNN 件物品和一个容量是 VVV 的背包，背包能承受的最大重量是 MMM。每件物品只能用一次。体积是 viv_ivi​，重量是 mim_imi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。 输出最大价值。 二维费用背包问题将限制扩展为两维-体积和重量，思路和 01 背包相同，dp 数组可以省略一维 #include&lt;iostream&gt; using namespace std; const int N=110; int n,v,m; int f[N][N]; int main() { cin&gt;&gt;n&gt;&gt;v&gt;&gt;m; for(int i=0; i&lt;n; i++) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int j=v; j&gt;=a; j--) for(int k=m; k&gt;=b; k--) f[j][k]=max(f[j][k], f[j-a][k-b]+c); } cout&lt;&lt;f[v][m]&lt;&lt;endl; return 0; } 分组背包问题 https://www.acwing.com/problem/content/9/ 有 NNN 组物品和一个容量是 VVV 的背包。每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vijv_{ij}vij​，价值是 wijw_{ij}wij​，其中 iii 是组号，jjj 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 思路与 01 背包一样 有依赖的背包问题 https://www.acwing.com/problem/content/10/ 有 NNN 个物品和一个容量是 VVV 的背包。物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。(依赖关系形成一颗树) 每件物品的编号是 iii，体积是 viv_ivi​，价值是 wiw_iwi​，依赖的父节点编号是 pip_ipi​。物品的下标范围是 1…N1…N1…N。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 树形 DP+分组背包问题 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N=110; int n,m; int h[N], e[N], ne[N], idx; int v[N], w[N], f[N][N]; void add(int a, int b) // add node(b) to head(a) { e[idx]=b, ne[idx]=h[a], h[a]=idx++; } void dfs(int u) { for(int i=h[u]; i!=-1; i=ne[i]) { int son=e[i]; dfs(son); // 更新子节点 for(int j=m-v[u]; j&gt;=0; j--) for(int k=0; k&lt;=j; k++) f[u][j]=max(f[u][j], f[u][j-k]+f[son][k]); } for(int i=m; i&gt;=v[u]; i--) // 容量大于等于根节点需要加上根节点的价值 f[u][i]=f[u][i-v[u]]+w[u]; for(int i=0; i&lt;v[u];i++) // 容量小于根节点的总价值为0 f[u][i]=0; } int main() { memset(h, -1, sizeof h); cin&gt;&gt;n&gt;&gt;m; int root; for(int i=1; i&lt;=n; i++) { int p; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;p; if(p==-1) root=i; else add(p, i); } dfs(root); cout&lt;&lt;f[root][m]&lt;&lt;endl; return 0; } 背包问题求方案数 https://www.acwing.com/problem/content/11/ 思路同 01 背包 注意的点： 求最大价值的方案数，就是求恰好达到最大价值的方案数，需要将状态 f[j]f[j]f[j] 理解为前 iii 个物品中体积恰好是 jjj 的最大价值（只需要将初始化 f[j=0]=0,f[j&gt;=1]=−∞f[j=0]=0, f[j&gt;=1]=- \\inftyf[j=0]=0,f[j&gt;=1]=−∞，即所有其他状态都是有 f[0]f[0]f[0] 转移而来的） 同时添加方案数组 g[j]g[j]g[j] 表示体积恰好是 jjj 的最大价值的方案数。（根据递推关系得到） for(int j=m; j&gt;=v; j--) { int t=max(f[j], f[j-v]+w); int s=0; if(t==f[j]) s+=g[j]; // 最大价值转移路径1 if(t==f[j-v]+w) s+=g[j-v]; // 最大价值转移路径2 if(s&gt;=mod) s-=mod; f[j]=t; g[j]=s; } 注意最后最优解是所有 f[j]f[j]f[j] 的最大价值（因为最优解需要的体积可能小于背包总容量，而且可能是不同的体积） 求背包问题的方案 https://www.acwing.com/problem/content/12/ 有 NNN 件物品和一个容量是 VVV 的背包。每件物品只能使用一次。第 iii 件物品的体积是 viv_ivi​，价值是 wiw_iwi​。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N1…N1…N。 注意： 存储完整的状态 f[i][j]f[i][j]f[i][j] 根据状态来 f[n][m]f[n][m]f[n][m] 来倒推选择的物品 （是否选择了第 nnn 件，第 n−1n-1n−1 件，…） // f[n][m] // if f[n][m] = f[n-1][m] 不选第n件物品 // if f[n][m] = f[n-1][m-v[n]]+w[n] 选第n件物品 由于输出字典序最小的方案，根据贪心，需要优先选择序号小的物品，倒推需要从第 1 件物品开始； 所以求解问题时从 N...1N...1N...1 的顺序来列举物品（将 1 号物品看成最后一个），最后从 f[1][m]f[1][m]f[1][m] 根据贪心来倒推选择的物品。 ","tags":[{"name":"Algorithm","slug":"algorithm","used":true,"link":"https://blog.qxxiao.eu.org/tag/algorithm/"}],"title":"背包九讲","feature":"https://pic.qxxiao.cn/algorithm.png","link":"https://blog.qxxiao.eu.org/post/背包九讲/","stats":{"text":"13 min read","time":766000,"words":2790,"minutes":13},"date":"2023-03-10 19:44:59","dateFormat":"2023-03-10","isTop":false},{"content":" https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols 可迭代协议 可迭代对象：对象必须实现 @@iterator 方法，这意味着对象（或者它原型链上的某个对象）必须有一个键为 @@iterator的属性，可通过常量 Symbol.iterator 访问该属性。可迭代对象可以使用 for…of 中遍历，使用展开语法 …object ，解构赋值等 [Symbol.iterator] 一个无参函数，返回一个迭代器对象 此函数可以是普通函数，也可以是生成器函数 一个对象需要被迭代，首先调用它的 @@iterator方法，然后使用此方法返回的迭代器获得要迭代的值 迭代器 迭代器协议定义了产生一系列值的标准方式。 定义了特定语义的 next()方法，该对象才能成为迭代器： 返回一个对象 {done: boolean, value: any} ，done 为 true 时属性 value 可省略; 注意： 不能判断一个特定的对象是否实现了迭代器协议 创建同时满足迭代器协议和可迭代协议是容易的，例如 Map 的 keys()/values()/entries() 方法返回的对象. 因此，迭代器一般都会实现可迭代协议成为可迭代对象： var myIterator = { next: function () { // ... }, [Symbol.iterator]: function () { return this } } 内置可迭代对象 String、Array、TypedArray、Map和 Set，它们的原型对象都实现了 @@iterator方法。 例如，简单的 map 示例：(只是为了说明迭代原理，非底层实现) CodeBlock · GitHubCodeBlock. GitHub Gist: instantly share code, notes, and snippets. https://gist.github.com/qxxiao/5ae665244881bb12564cf74785c1bcaf#file-js-mymap-md 生成器 生成器对象是由一个 generator function 返回的，它是迭代器(next 方法)，也是可迭代对象(@@iterator )。 function* 声明方式，定义一个生成器函数，其返回一个生成器对象。 执行流程： next()方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。 或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数； next()方法返回一个对象，这个对象包含两个属性：value 和 done（迭代器语义） 调用 next()方法时，如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量 注意：生成器函数中 return 可以提前结束生成器的状态(next 返回的对象 done:true)，可以返回值。返回的生成器对象也可以调用 return 函数提前结束。 let aGeneratorObject = (function* () { yield 1 yield 2 yield 3 })() // 返回生成器对象 typeof aGeneratorObject.next // 返回&quot;function&quot;, 因为有一个 next 方法，所以这是一个迭代器 typeof aGeneratorObject[Symbol.iterator] // 返回&quot;function&quot;, 因为有一个 @@iterator 方法，所以这是一个可迭代对象 aGeneratorObject[Symbol.iterator]() === aGeneratorObject // true，因为 @@iterator 方法返回自身（即迭代器） ;[...aGeneratorObject] // 返回 [1, 2, 3] console.log(Symbol.iterator in aGeneratorObject) // true CodeBlock · GitHubCodeBlock. GitHub Gist: instantly share code, notes, and snippets. https://gist.github.com/qxxiao/5ae665244881bb12564cf74785c1bcaf#file-js-js 异步可迭代对象 异步可迭代对象：定义了 Symbol.asyncIterator 属性，可用于 for await...of 循环。 (Symbol.asyncIterator 是一个用于访问对象的@@asyncIterator 方法的内建符号) 主要作用：迭代返回值的操作是异步操作时，优化性能。 使用for await...of 语句创建一个循环，可遍历异步可迭代对象，注意它也可以遍历上面的同步可迭代对象(相当于使用 Promise.resolve(val)包装). 同时存在，优先迭代返回的异步迭代器对象。 自定义异步可迭代对象 const myAsyncIterable = new Object() myAsyncIterable[Symbol.asyncIterator] = async function* () { yield 'hello' yield 'async' yield 'iteration!' } ;(async () =&gt; { for await (const x of myAsyncIterable) { console.log(x) // expected output: // &quot;hello&quot; // &quot;async&quot; // &quot;iteration!&quot; } })() 异步迭代器，可以看作每次迭代返回的是一个 promise 对象。 注意：async 函数调用，await 后面的表达式执行都是同步操作，只有 await 语句后面的语句即回调才是异步执行(微任务) ","tags":[{"name":"JavaScript","slug":"javascript","used":true,"link":"https://blog.qxxiao.eu.org/tag/javascript/"}],"title":"迭代器和生成器","feature":"https://pic.qxxiao.cn/js-logo.png","link":"https://blog.qxxiao.eu.org/post/迭代器和生成器/","stats":{"text":"4 min read","time":239000,"words":1020,"minutes":4},"date":"2022-11-23 00:57:00","dateFormat":"2022-11-23","isTop":false},{"content":" 来源：https://www.jianshu.com/p/992dfcecff34 github：https://github.com/imhuster/DynamicProxy/blob/master/src/main/java/com/iqts/MyProxy.java 彻底理解动态代理 - 简书本文篇幅比较长，在确定您是否需要仔细阅读本文前，可以先思考一下下面几个问题： 动态代理是什么？ 如何实现动态代理？ 所有类都能实现动态代理吗？ 非目标方法是否会被代理？ 为什... https://www.jianshu.com/p/992dfcecff34 JDK 动态代理 实现：动态生成的代理类的字节码(内存中 []byte)，原理是继承Proxy 类，实现被代理类的所有接口生成动态代理类。 生成的代理类 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package proxy.jdk; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; final class $Proxy0 extends Proxy implements Subject { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void doOperation() throws { try { super.h.invoke(this, m3, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m3 = Class.forName(&quot;proxy.jdk.Subject&quot;).getMethod(&quot;doOperation&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } } } 除了实现了被代理类所有接口中的方法外，JDK 动态代理还重写了 Object 类中的 hashCode、equals、toString 三个方法。（注意在 invoke 方法中在代理类上调用它们会递归） 继承的 Proxy 类拥有 InvocationHandler 字段，通过代理类的构造器初始化； 重写的方法中，都会转向调用 super.h.invoke 问题： 为什么 JDK 实现动态代理必须要求被代理类实现接口？ 动态生成的代理类需要继承 Proxy 类，而 Java 中只能单继承的限制使得被代理类必须实现接口才能实现动态代理 如果被代理的类没有实现接口就无法实现动态代理，这时候我们就需要使用第三方工具。 CGLib CGLib 可以在运行期扩展 Java 类及实现Java接口、提供方法的拦截，因此被众多 AOP 框架使用。CGLib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。 原理：CGLib 是通过继承被代理类实现动态代理的，这也就要求被代理的类不能是 final 类 代理类 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package proxy.cglib; ... public class RealSubject$$EnhancerByCGLIB$$5fe030cf extends RealSubject implements Factory { private MethodInterceptor CGLIB$CALLBACK_0; private static final Method CGLIB$doOperation$0$Method; private static final MethodProxy CGLIB$doOperation$0$Proxy; ... static void CGLIB$STATICHOOK1() { CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(&quot;proxy.cglib.RealSubject$$EnhancerByCGLIB$$5fe030cf&quot;); Class var1; CGLIB$doOperation$0$Method = ReflectUtils.findMethods(new String[]{&quot;doOperation&quot;, &quot;()V&quot;}, (var1 = Class.forName(&quot;proxy.cglib.RealSubject&quot;)).getDeclaredMethods())[0]; CGLIB$doOperation$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;doOperation&quot;, &quot;CGLIB$doOperation$0&quot;); ... } final void CGLIB$doOperation$0() { super.doOperation(); } public final void doOperation() { MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if (var10000 == null) { CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; } if (var10000 != null) { var10000.intercept(this, CGLIB$doOperation$0$Method, CGLIB$emptyArgs, CGLIB$doOperation$0$Proxy); } else { super.doOperation(); } } ...... static { CGLIB$STATICHOOK1(); } } CGLib 不仅重写了 Object 类的 hashCode、equals、toString方法，还重写了 clone 方法。 代理的方法都对应两个具体的方法，例如 CGLIB$doOperation$0 和 doOperation ，后者是对被代理对象的重写方法，前者是调用父类的方法。因此在实现 MethodInterceptor 接口的 intercept 方法中： methodProxy.invoke() 是对 doOperation 方法的调用(对于代理对象，就调用该重写方法，因此需要注意递归调用) methodProxy.invokeSuper() 是对 CGLIB$doOperation$0 方法的调用(必须是代理对象，该方法仅调用父类的 doOperation 方法，即目标对象的方法)。 由于是继承实现，final 方法是不会代理的，只会调用父类的 final 方法。 CGLib 可以直接生成接口的代理对象，代理对重新接口中的方法，类似 JDK 动态代理； ^26a5aa CGLib 可以实现 MethodInterceptor 接口与 InvocationHandler 接口(CGLib包中)，使用 InvocationHandler 方式与 JDK 方式类似，并且代理的方法只对应一个具体的方法(代理类对父类的重写方法-同名)。 ","tags":[{"name":"Java","slug":"java","used":true,"link":"https://blog.qxxiao.eu.org/tag/java/"}],"title":"Java动态代理","feature":"https://www.notion.so/images/page-cover/webb1.jpg","link":"https://blog.qxxiao.eu.org/post/Java动态代理/","stats":{"text":"6 min read","time":318000,"words":1154,"minutes":6},"date":"2022-11-11 14:58:00","dateFormat":"2022-11-11","isTop":false},{"content":" 官方教程：https://cmake.org/cmake/help/latest/guide/tutorial/index.html 一些总结：https://wangpengcheng.github.io/2019/08/13/learn_cmake/ 基础 最小配置的 CMakeLists.txt # Set the minimum required version of CMake to be 3.10 cmake_minimum_required(VERSION 3.10) # Create a project named Tutorial project(Tutorial VERSION 1.0) # set(Tutorial_VERSION_MAJOR 1) # set(Tutorial_VERSION_MINOR 0) # Set the variable CMAKE_CXX_STANDARD to 11 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # Add an executable called Tutorial to the project add_executable(Tutorial tutorial.cpp) 如果文件较多，aux_source_directory(. DIR_SRCS) 将当前目录所有源文件的文件名赋值给变量 DIR_SRCS，使用 add_executable(Tutorial ${DIR_SRCS}) 可选：MacOS + gcc + clangd 最小配置 # Set the minimum required version of CMake to be 3.10 cmake_minimum_required(VERSION 3.10) # Create a project named Tutorial project(Tutorial VERSION 1.0) # set(Tutorial_VERSION_MAJOR 1) # set(Tutorial_VERSION_MINOR 0) # Set the variable CMAKE_CXX_STANDARD to 11 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # set -isysroot for macOS # default to macOS [according to gcc version] if(APPLE) set(CMAKE_OSX_SYSROOT /Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk) set(CMAKE_OSX_DEPLOYMENT_TARGET 12.0) # [according to gcc built for macos version] endif() # Add an executable called Tutorial to the project aux_source_directory(. DIR_SRCS) add_executable(Tutorial ${DIR_SRCS}) 生成lib并可选使用 生成lib，并在项目中可选地使用 项目中会生成 lib 库文件，并在其他部分可选的链接使用该库 cmake_minimum_required(VERSION 3.10) # set the project name and version project(Tutorial VERSION 1.0) # specify the C++ standard set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON) configure_file(TutorialConfig.h.in TutorialConfig.h) if(USE_MYMATH) add_subdirectory(MathFunctions) # 子目录会生成 MathFunctions lib list(APPEND EXTRA_LIBS MathFunctions) list(APPEND EXTRA_INCLUDES &quot;${PROJECT_SOURCE_DIR}/MathFunctions&quot;) endif() # add the executable add_executable(Tutorial tutorial.cxx) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS}) target_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot; ${EXTRA_INCLUDES}) 使用 option 命令，可以定义一个boolean变量 使用 configure_file 命令，将配置头文件，经过变量替换生成C++ header file: @var@ 变量，使用 CMakeLists.txt 中定义个变量进行替换； #cmakedefine 替换为 #define ，如果后面定义的boolean变量是 ON 则进行替换 生成的头文件放置在 ${PROJECT_BINARY_DIR} 目录，即 cmake 的 build 目录 使用 if() 来控制添加 lib 生成，定义 EXTRA_LIBS 列表，EXTRA_INCLUDES 列表，默认为空 使用 target_link_libraries 对 target 链接指定的库 使用 target_include_directories 对 target 添加指定的头文件目录 说明：可以在配置项目时，指定 cmake .. -DUSE_MYMATH=OFF 来覆盖定义的值 生成lib并可选使用(INTERFACE) 对上一个 cmake 改进，之前的做法需要链接 lib 库文件，并且在上层中需要显示的指定库对应的 include 头文件目录，非常繁琐。 通过 Usage Requirements 来控制库在链接时的传递属性，使用 INTERFACE 来表达该语义：任意链接该库 target 必须 include 当前/指定的源目录(用于搜索头文件)。INTERFACE 表示消费者需要，但是生产者不需要。(对于库而言，生成的 lib target 不需要，但是需要链接该库的 target 必须包含指定的目录) 子目录生成 lib 并指定 Usage Requirements 的 CMakeLists.txt ： add_library(MathFunctions mysqrt.cxx) # Hint: Use target_include_directories with the INTERFACE keyword # 尽管 MathFunctions 库不需要包含当前源目录，但是任何链接到 MathFunctions 的库都需要包含当前源目录 target_include_directories(MathFunctions INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}) top-level CMakeLists.txt ： cmake_minimum_required(VERSION 3.10) # set the project name and version project(Tutorial VERSION 1.0) # specify the C++ standard set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # should we use our own math functions option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON) # configure a header file to pass some of the CMake settings # to the source code configure_file(TutorialConfig.h.in TutorialConfig.h) # add the MathFunctions library if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) endif() # add the executable add_executable(Tutorial tutorial.cxx) target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS}) # find TutorialConfig.h target_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot;) 使用生成器表达式 https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7) 生成器表达式，主要可以生成复杂的条件表达式，用于条件编译，条件链接等等。 例如，使用一个 interface library 来指定编译选项，使用生成器表达式对不同的编译器选择不同的编译选项： cmake_minimum_required(VERSION 3.15) # set the project name and version project(Tutorial VERSION 1.0) set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # * Creating an interface library called tutorial_compiler_flags add_library(tutorial_compiler_flags INTERFACE) target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11) # Create helper variables to determine which compiler we are using set(gcc_like_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC&gt;&quot;) set(msvc_cxx &quot;$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;&quot;) # With nested generator expressions, only use the flags for the build-tree target_compile_options(tutorial_compiler_flags INTERFACE &quot;$&lt;${gcc_like_cxx}:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;&quot; &quot;$&lt;${msvc_cxx}:$&lt;BUILD_INTERFACE:-W3&gt;&gt;&quot; ) # should we use our own math functions option(USE_MYMATH &quot;Use tutorial provided math implementation&quot; ON) configure_file(TutorialConfig.h.in TutorialConfig.h) # add the MathFunctions library if(USE_MYMATH) add_subdirectory(MathFunctions) list(APPEND EXTRA_LIBS MathFunctions) endif() # add the executable add_executable(Tutorial tutorial.cxx) # Link to tutorial_compiler_flags target_link_libraries(Tutorial PUBLIC tutorial_compiler_flags ${EXTRA_LIBS}) target_include_directories(Tutorial PUBLIC &quot;${PROJECT_BINARY_DIR}&quot;) 使用生成器表达式，指定 cmake 最小版本为 3.15 使用 INTERFACE 来创建一个接口库，用于传递/指定 Usage Requirements 表达式： $&lt;COMPILE_LANG_AND_ID:CXX,...&gt; 如果编译单元的语言是CXX，并且编译器ID与后面之一匹配，表达式为1否则为0 $&lt;BUILD_INTERFACE: STRING&gt; 在相同build为STRING，否则为空；上面的目的是：为了使得我们 installed project 的其他消费者不会继承编译选项； install and test 安装 executable | lib | headers set(installable_libs MathFunctions tutorial_compiler_flags) install(TARGETS ${installable_libs} DESTINATION lib) install(FILES MathFunctions.h DESTINATION include/MathFunc) # bin file install(TARGETS Tutorial DESTINATION bin) 构建和安装： cmake --build . cmake --install . --prefix &quot;/home/myuser/installdir&quot; # 有默认的位置，例如 /usr/local 或者 cmake --build . --target install 简单的测试样例 # enable testing enable_testing() # basic test, return value is zero add_test(NAME Runs COMMAND Tutorial 25) # verify that the output of the test contains certain strings. add_test(NAME Correctness COMMAND Tutorial 4 ) set_tests_properties(Correctness PROPERTIES PASS_REGULAR_EXPRESSION &quot;4 is 2&quot;) # 定义函数 do_test 添加多个测试 function(do_test target arg result) add_test(NAME Comp${arg} COMMAND ${target} ${arg}) set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result} ) endfunction() # do a bunch of result based tests do_test(Tutorial 4 &quot;4 is 2&quot;) do_test(Tutorial 9 &quot;9 is 3&quot;) do_test(Tutorial 5 &quot;5 is 2.236&quot;) do_test(Tutorial 7 &quot;7 is 2.645&quot;) do_test(Tutorial 25 &quot;25 is 5&quot;) do_test(Tutorial -25 &quot;-25 is (-nan|nan|0)&quot;) do_test(Tutorial 0.0001 &quot;0.0001 is 0.01&quot;) 构建完成后，使用 ctest -VV 进行测试 添加系统检查 例如测试系统是否支持某个库/函数： # does this system provide the log and exp functions? include(CheckCXXSourceCompiles) check_cxx_source_compiles(&quot; #include &lt;cmath&gt; int main() { std::log(1.0); return 0; } &quot; HAVE_LOG) check_cxx_source_compiles(&quot; #include &lt;cmath&gt; int main() { std::exp(1.0); return 0; } &quot; HAVE_EXP) if(HAVE_LOG AND HAVE_EXP) target_compile_definitions(MathFunctions PRIVATE &quot;HAVE_LOG&quot; &quot;HAVE_EXP&quot;) endif() 根据测试结果，添加编译定义 target_compile_definitions() 其最终指令结果：g++ -DHAVE_EXP -DHAVE_LOG 添加自定义命令 在build开始可以先生成 output，用于后续的 target build: add_executable(MakeTable MakeTable.cxx) # add a custom command that specifies how to produce Table.h by running MakeTable. add_custom_command( OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h DEPENDS MakeTable ) build 会先指定自定义命令中的指定，生成 output 文件，在 cmake --build . 执行 【说明：在指定 add_library 等，可以指定依赖的头文件用于说明构建的依赖关系】 打包程序 使用 CPack 将生成的二进制文件，库和头文件打包成压缩文件，并生成简易的提取安装脚本。 # 该模块将包括当前平台项目所需的任何运行时库 include(InstallRequiredSystemLibraries) set(CPACK_RESOURCE_FILE_LICENSE &quot;${CMAKE_CURRENT_SOURCE_DIR}/License.txt&quot;) set(CPACK_PACKAGE_VERSION_MAJOR &quot;${Tutorial_VERSION_MAJOR}&quot;) set(CPACK_PACKAGE_VERSION_MINOR &quot;${Tutorial_VERSION_MINOR}&quot;) set(CPACK_SOURCE_GENERATOR &quot;TGZ&quot;) # selects a file format for the source package include(CPack) 构建 build 后，使用 cpack 打包即可，主要工作： 导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块； 设置一些 CPack 相关变量，包括版权信息，版本信息，压缩格式； 导入 CPack 模块。 添加导出配置 https://cmake.org/cmake/help/latest/guide/tutorial/Adding Export Configuration.html#cmakelists-txt-install-export 便于其他 CMake 项目可以复用我们的项目，无论是通过我们的构建目录、本地安装还是打包时。 行为：在构建目录build，本地安装(/usr/local/lib/cmake)或者在打包的文件夹中生成cmake配置文件。 好处：不用特别指定项目/库的相关 include/lib 路径，方便使用（指定 package 目录） 生成的文件： xxx.cmake 目标信息 xxxConfig.cmake 通过 Config.cmake.in 文件生成，以便 CMake **find_package()**命令可以找到该项目(用于修改包的 PREFIX_DIR 路径) xxxConfigVersion.cmake 记录软件包的版本和兼容性 使用package，例如打包后的目录为： Tutorial-1.0-Darwin ├── bin │ └── Tutorial ├── include │ ├── MathFunctions.h │ └── TutorialConfig.h └── lib ├── cmake │ └── MathFunctions │ ├── MathFunctionsConfig.cmake │ ├── MathFunctionsConfigVersion.cmake │ ├── MathFunctionsTargets-noconfig.cmake │ └── MathFunctionsTargets.cmake ├── libMathFunctions.dylib └── libSqrtLibrary.a 使用非常方便： list(APPEND CMAKE_PREFIX_PATH &quot;${PROJECT_SOURCE_DIR}/Tutorial-1.0-Darwin&quot;) find_package(MathFunctions REQUIRED) # add the executable add_executable(Tutorial tutorial.cxx) target_link_libraries(Tutorial PUBLIC MathFunctions) # no namespace 使用 INTERFACE 自动包含链接库的头文件目录 ","tags":[{"name":"CMake","slug":"cmake","used":true,"link":"https://blog.qxxiao.eu.org/tag/cmake/"}],"title":"cmake示例","feature":"https://pic.qxxiao.cn/20221031044602.png","link":"https://blog.qxxiao.eu.org/post/cmake示例/","stats":{"text":"10 min read","time":593000,"words":2060,"minutes":10},"date":"2022-10-29 12:23:00","dateFormat":"2022-10-29","isTop":false},{"content":" libcurl：高可移植、功能丰富的通信库 cpr：更现代、更易用的通信库 安装 ZMQ：高效、多功能的通信库 sockpp 小结 转载和来源于：罗剑锋的 C++ 实战笔记 libcurl：高可移植、功能丰富的通信库 libcurl，来源于著名的curl 项目，也是 curl 的底层核心。 它最早只支持 HTTP 协议，但现在已经扩展到支持所有的应用层协议，比如 HTTPS、FTP、LDAP、SMTP 等，功能强大。 libcurl 使用纯 C 语言开发，兼容性、可移植性非常好，基于 C 接口可以很容易写出各种语言的封装，所以 Python、PHP 等语言都有 libcurl 相关的库。 ubuntu 下安装： apt-get install libcurl4-openssl-dev libcurl 的接口可以粗略地分成两大类：easy 系列和 multi 系列。其中，easy 系列是同步调用，比较简单；multi 系列是异步的多线程调用。 使用 libcurl 收发 HTTP 数据的基本步骤有 4 个： 使用 curl_easy_init() 创建一个句柄，类型是 CURL*。但我们完全没有必要关心句柄的类型，直接用 auto 推导就行。 使用 curl_easy_setopt() 设置请求的各种参数，比如请求方法、URL、header/body 数据、超时、回调函数等。这是最关键的操作。 使用 curl_easy_perform() 发送数据，返回的数据会由回调函数处理。 使用 curl_easy_cleanup() 清理句柄相关的资源，结束会话。 Code示例 #include &lt;assert.h&gt; #include &lt;curl/curl.h&gt; #include &lt;iostream&gt; using namespace std; // 回调函数的原型 // 回调会被多次调用，每次调用都会传递一块数据;ptr指向传递的数据，该数据的大小为nmemb；size始终为1 // size * nmemb 是缓冲区的大小 // ptr 是缓冲区的地址 // userdata 是用户自定义的数据 size_t write_callback(char*, size_t, size_t, void*); int main() { auto curl = curl_easy_init(); // 创建CURL句柄 assert(curl); curl_easy_setopt(curl, CURLOPT_URL, &quot;http://nginx.org&quot;); // 设置请求URI // 避免代理设置为长连接 Proxy-Connection:close或者不使用代理 curl_easy_setopt(curl, CURLOPT_PROXY, &quot;&quot;); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L); // 没有设置回调函数时，内部的默认回调，把得到的 HTTP 响应数据输出到标准流 // c++11, 无捕获的 lambda 表达式可以显式转换成一个函数指针=&gt;C使用 curl_easy_setopt( curl, CURLOPT_WRITEFUNCTION, // 设置回调函数 (decltype(&amp;write_callback)) // decltype获取函数指针类型，显式转换 [](char* ptr, size_t size, size_t nmemb, void* userdata) { cout &lt;&lt; &quot;size = &quot; &lt;&lt; size &lt;&lt; &quot;*&quot; &lt;&lt; nmemb &lt;&lt; &quot;=&quot; &lt;&lt; size * nmemb &lt;&lt; endl; // 简单的处理 return size * nmemb; // 返回接收的字节数 }); auto res = curl_easy_perform(curl); // 发送数据 if (res != CURLE_OK) { // 检查是否执行成功 cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl; } curl_easy_cleanup(curl); // 清理句柄相关的资源 return 0; } 推荐使用cpr代替它 cpr：更现代、更易用的通信库 cpr 是对 libcurl 的一个 C++11 封装，使用了很多现代 C++ 的高级特性，对外的接口模仿了 Python 的 requests 库，非常简单易用。 安装 下载源码，用 cmake 编译安装 git clone git@github.com:whoshuu/cpr.git cmake . -DUSE_SYSTEM_CURL=ON -DBUILD_CPR_TESTS=OFF make &amp;&amp; make install 或者在 cmake 项目中直接使用[CMakeLists.txt]： include(FetchContent) FetchContent_Declare(cpr GIT_REPOSITORY https://github.com/libcpr/cpr.git GIT_TAG 871ed52d350214a034f6ef8a3b8f51c5ce1bd400) # The commit hash for 1.9.0. Replace with the latest from: https://github.com/libcpr/cpr/releases FetchContent_MakeAvailable(cpr) target_link_libraries(cpr_example PRIVATE cpr::cpr) 说明：macos 下指定 clang++/clang 编译器生成项目；gcc 编译会失败； 在 cpr 里，HTTP 协议的概念都被实现为相应的函数或者类，内部再转化为 libcurl 操作，主要的有： GET/HEAD/POST 等请求方法，使用同名的 Get/Head/Post 函数； URL 使用 Url 类，它是 string 的封装； URL 参数使用 Parameters 类，KV 结构，近似 map； 请求头字段使用 Header 类，它其实是 map 的别名，使用定制的函数实现了大小写无关比较； Cookie 使用 Cookies 类，也是 KV 结构，近似 map； 请求体使用 Body 类；超时设置使用 Timeout 类。 cpr 也支持异步处理，但它内部没有使用 libcurl 的 multi 接口，而是使用了标准库里的 future 和 async。 Code示例 #include &lt;cpr/cpr.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main(int argc, char** argv) { cpr::Response r = cpr::Get(cpr::Url{&quot;https://api.github.com/repos/whoshuu/cpr/contributors&quot;}, cpr::Authentication{&quot;user&quot;, &quot;pass&quot;, cpr::AuthMode::BASIC}, cpr::Parameters{{&quot;anon&quot;, &quot;true&quot;}, {&quot;key&quot;, &quot;value&quot;}}); std::cout &lt;&lt; &quot;Status code: &quot; &lt;&lt; r.status_code &lt;&lt; '\\n'; std::cout &lt;&lt; &quot;Header:\\n&quot;; for (const std::pair&lt;const std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt;&gt;&amp; kv : r.header) { std::cout &lt;&lt; '\\t' &lt;&lt; kv.first &lt;&lt; ':' &lt;&lt; kv.second &lt;&lt; '\\n'; } std::cout &lt;&lt; &quot;Text: &quot; &lt;&lt; r.text &lt;&lt; '\\n'; return 0; } ZMQ：高效、多功能的通信库 libcurl 和 cpr 处理的都是 HTTP 协议，方便但协议自身也有一些限制，比如必须要一来一回，必须点对点直连，在超大数据量通信的时候就不是太合适。并且 libcurl 和 cpr 只能充当 HTTP 的客户端。 ZMQ 不仅是一个单纯的网络通信库，更像是一个高级的异步并发框架。 https://zeromq.org/get-started/ Zero Message Queue——零延迟的消息队列，意味着它除了可以收发数据外，还可以用作消息中间件，解耦多个应用服务之间的强依赖关系，搭建高效、有弹性的分布式系统，从而超越原生的 Socket。 ubuntu 下安装 apt-get install libzmq3-dev ZMQ 是用 C++ 开发的，但出于兼容的考虑，对外提供的是纯 C 接口。它也有很多 C++ 封装，可以使用 cppzmq，只有头文件的封装，简单使用。 ZMQ 把自身定位于更高层次的“异步消息队列”，定义了 5 种不同的工作模式，来适应实际中常见的网络通信场景。 原生模式（RAW），没有消息队列功能，相当于底层 Socket 的简单封装； 结对模式（PAIR），两个端点一对一通信； 请求响应模式（REQ-REP），也是两个端点一对一通信，但请求必须有响应； 发布订阅模式（PUB-SUB），一对多通信，一个端点发布消息，多个端点接收处理； 管道模式（PUSH-PULL），或者叫流水线，可以一对多，也可以多对一； 前四种模式类似 HTTP 协议、Client-Server 架构，管道模式非常适合进程间无阻塞传送海量数据。管道模式介绍示意： 在 ZMQ 里有两个基本的类。 第一个是 context_t，它是 ZMQ 的运行环境。使用 ZMQ 的任何功能前，必须要先创建它。 第二个是 socket_t，表示 ZMQ 的套接字，需要指定刚才说的那 5 种工作模式。注意它与原生 Socket 没有任何关系，只是借用了名字来方便理解。 ZMQ 套接字支持 TCP/IP，还支持进程内和进程间通信，这在本机交换数据时会更高效： TCP 通信地址的形式是 tcp://…，指定 IP 地址和端口号； 进程内通信地址的形式是 inproc://…，指定一个本地可访问的路径； 进程间通信地址的形式是 ipc://…，也是一个本地可访问的路径。 用 bind()/connect() 这两个函数把 ZMQ 套接字连接起来之后，就可以用 send()/recv() 来收发数据了： Code示例 #include &quot;zmq.hpp&quot; #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;thread&gt; using namespace std; int main() { const auto thread_num = 1; // 并发线程数z zmq::context_t context(thread_num); // ZMQ环境变量 auto make_sock = [&amp;](auto mode) { // 定义一个lambda表达式 return zmq::socket_t(context, mode); // 创建ZMQ套接字 }; const auto addr = &quot;ipc:///tmp/shm/zmq.sock&quot;s; // 通信地址 auto receiver = [=]() { // lambda表达式接收数据 auto sock = make_sock(ZMQ_PULL); // 创建ZMQ套接字，拉数据 sock.bind(addr); // 绑定套接字 assert(sock.handle() != nullptr); // 断言套接字有效 auto buf = make_unique&lt;char[]&gt;(1024); // 创建一个1024字节的缓冲区 zmq::mutable_buffer msg(buf.get(), 1024); // 创建ZMQ消息 sock.recv(msg, zmq::recv_flags::none); // 接收数据 cout &lt;&lt; (char*)msg.data() &lt;&lt; endl; }; auto sender = [=]() { // lambda表达式发送数据 auto sock = make_sock(ZMQ_PUSH); // 创建ZMQ套接字，推数据 sock.connect(addr); // 连接到对端 assert(sock.handle() != nullptr); string s = &quot;hello zmq&quot;; sock.send(zmq::const_buffer{s.data(), s.length()}); // 发送消息 }; thread t1(sender); thread t2(receiver); t1.join(); t2.join(); } 使用 ZMQ 完全不需要考虑底层的 TCP/IP 通信细节，它会保证消息异步、安全、完整地到达服务器，让你关注网络通信之上的业务逻辑。 其他说明 ZMQ 环境的线程数。它的默认值是 1，适当增大一些就可以提高 ZMQ 的并发处理能力。 收发消息时的本地缓存数量，ZMQ 的术语叫 High Water Mark。如果收发的数据过多，数量超过 HWM，ZMQ 要么阻塞，要么丢弃消息。 HWM 需要调用套接字的成员函数 setsockopt() 来设置，注意收发使用的是两个不同的标志： sock.setsockopt(ZMQ_RCVHWM, 1000); // 接收消息最多缓存1000条 sock.setsockopt(ZMQ_SNDHWM, 100); // 发送消息最多缓存100条 即使设置 100 万以上的值，ZMQ 会把一切都处理得很好。 sockpp 简单易用的C++ Socket 库，这是一个低层级的 socket 包装库，提供 socket, connector, acceptor 等相关接口。 下载并安装 https://github.com/fpagliughi/sockpp git clone https://github.com/fpagliughi/sockpp cd sockpp mkdir build &amp;&amp; cd build cmake .. # 默认使用 -DSOCKPP_BUILD_SHARED=ON cmake --build . --target install MacOS 下如果使用 gcc/g++，则使用 gcc/g++ toolchain 编译安装 使用方式非常简单，例如 TCP 编程： TCP Server #include &lt;iostream&gt; #include &lt;thread&gt; #include &quot;sockpp/tcp_acceptor.h&quot; #include &quot;sockpp/version.h&quot; using namespace std; // The thread function. void run_echo(sockpp::tcp_socket sock) { ssize_t n; char buf[512]; while ((n = sock.read(buf, sizeof(buf))) &gt; 0) sock.write_n(buf, n); cout &lt;&lt; &quot;Connection closed from &quot; &lt;&lt; sock.peer_address() &lt;&lt; endl; } int main(int argc, char* argv[]) { cout &lt;&lt; &quot;Sample TCP echo server for 'sockpp' &quot; &lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; '\\n' &lt;&lt; endl; in_port_t port = (argc &gt; 1) ? atoi(argv[1]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp_acceptor acc(port); if (!acc) { cerr &lt;&lt; &quot;Error creating the acceptor: &quot; &lt;&lt; acc.last_error_str() &lt;&lt; endl; return 1; } cout &lt;&lt; &quot;Awaiting connections on port &quot; &lt;&lt; port &lt;&lt; &quot;...&quot; &lt;&lt; endl; while (true) { sockpp::inet_address peer; // Accept a new client connection sockpp::tcp_socket sock = acc.accept(&amp;peer); cout &lt;&lt; &quot;Received a connection request from &quot; &lt;&lt; peer &lt;&lt; endl; if (!sock) { cerr &lt;&lt; &quot;Error accepting incoming connection: &quot; &lt;&lt; acc.last_error_str() &lt;&lt; endl; } else { // Create a thread and transfer the new stream to it. thread thr(run_echo, std::move(sock)); thr.detach(); } } return 0; } TCP Client #include &lt;iostream&gt; #include &lt;string&gt; #include &quot;sockpp/tcp_connector.h&quot; #include &quot;sockpp/version.h&quot; using namespace std; using namespace std::chrono; int main(int argc, char* argv[]) { cout &lt;&lt; &quot;Sample TCP echo client for 'sockpp' &quot; &lt;&lt; sockpp::SOCKPP_VERSION &lt;&lt; '\\n' &lt;&lt; endl; string host = (argc &gt; 1) ? argv[1] : &quot;localhost&quot;; in_port_t port = (argc &gt; 2) ? atoi(argv[2]) : 12345; sockpp::socket_initializer sockInit; sockpp::tcp_connector conn({host, port}); if (!conn) { cerr &lt;&lt; &quot;Error connecting to server at &quot; &lt;&lt; sockpp::inet_address(host, port) &lt;&lt; &quot;\\n\\t&quot; &lt;&lt; conn.last_error_str() &lt;&lt; endl; return 1; } cout &lt;&lt; &quot;Created a connection from &quot; &lt;&lt; conn.address() &lt;&lt; endl; // Set a timeout for the responses if (!conn.read_timeout(seconds(5))) { cerr &lt;&lt; &quot;Error setting timeout on TCP stream: &quot; &lt;&lt; conn.last_error_str() &lt;&lt; endl; } string s, sret; while (getline(cin, s) &amp;&amp; !s.empty()) { if (conn.write(s) != ssize_t(s.length())) { cerr &lt;&lt; &quot;Error writing to the TCP stream: &quot; &lt;&lt; conn.last_error_str() &lt;&lt; endl; break; } sret.resize(s.length()); ssize_t n = conn.read_n(&amp;sret[0], s.length()); if (n != ssize_t(s.length())) { cerr &lt;&lt; &quot;Error reading from TCP stream: &quot; &lt;&lt; conn.last_error_str() &lt;&lt; endl; break; } cout &lt;&lt; sret &lt;&lt; endl; } return (!conn) ? 1 : 0; } 小结 libcurl 是一个功能完善、稳定可靠的应用层通信库，最常用的就是 HTTP 协议； cpr 是对 libcurl 的 C++ 封装，接口简单易用；libcurl 和 cpr 都只能作为客户端来使用，不能编写服务器端应用； ZMQ 是一个高级的网络通信库，支持多种通信模式，可以把消息队列功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。 sockpp 是一个简单易用的底层sock封装库。 最后， C++20，原本预计会加入期待已久的 networking 库，但现在已经被推迟到了下一个版本（C++23） networking 库基于已有多年实践的 boost.asio，采用前摄器模式（Proactor）统一封装了操作系统的各种异步机制（epoll、kqueue、IOCP），而且支持协程。 ","tags":[{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"C++网络库","feature":"https://pic.qxxiao.cn/cpp-logo.png","link":"https://blog.qxxiao.eu.org/post/C++网络库/","stats":{"text":"14 min read","time":820000,"words":3072,"minutes":14},"date":"2022-10-23 21:42:00","dateFormat":"2022-10-23","isTop":false},{"content":"Git 原理 .git 文件夹说明 -rw-r--r-- HEAD # 当前的头部commit/指向 -rw-r--r-- config # 本地仓库的配置 drwxr-xr-x hooks # hooks模版 -rw-r--r-- index # 暂存区的索引[被追踪的文件信息](添加到暂存区会持久化) drwxr-xr-x logs # HEAD 的记录[分支记录以及HEAD移动记录] drwxr-xr-x objects # 文件对象[commit对象文件，tree对象文件，bob普通文件] drwxr-xr-x refs # 分支的头部和tags(对应的commitID) commit 对象表示了此次提交的一次快照/版本，而暂存区是当前的修改版本，等到提交时将当前的状态建立一个 commit 保存归档。 例如一个 commit 对象关联的对象： commit 对象包含一个 tree 对象(指针)，表示了当前文件树形组织的快照版本 commit 对象之间通过 parent 指针联系 暂存区，上次提交+后续添加到暂存的文件修改的文件状态 说明： commit 之间，相同的文件对象是共享的； 每次修改添加到暂存区后，只会影响 bob 文件对象【tree 对象等到提交才会生成】 每个文件的权限、文件路径和 Hash存储在.git/index文件 Git 的 hash 指针/内容寻址/DAG 结构被广泛用于 IPFS 的存储架构中。 Git对象简单测试 # git sha-1 hash echo &quot;Hello&quot; | git hash-object --stdin # 查看暂存区的内容[由git追踪的文件] git ls-files --stage # 查看git对象的类型 git cat-file -t ID # 查看git对象的内容 git cat-file -p ID 实战 比较命令 git diff commitID1 commitID2 [-- file1 ...] 比较两个提交的[部分]文件差异，可以使用分支名代替 ID git diff[-- file1 ...] 比较工作区和暂存区的文件差异 git diff --cached [-- file1 ...] 比较暂存区和HEAD/最近提交的文件差异 git diff HEAD -- [-- file1 ...] 比较工作区和HEAD/最近提交的文件差异 分离头指针 分离头指针，即 HEAD 指向了非分支的头部提交，如果新建提交不属于任何分支，不会被 git 管理后续会被清理。 但是，基于该提交进行试验产生新提交是可行的 如果新提交需要保留，应该基于新提交建立新分支/tag 对于基于分离头指针的提交 为 unreachable object 会在默认策略下被清理【分支/tag/index/reflog 不能到达的对象】并且默认 2weeks 不变(不修改)[缓解竞争条件]的话会被清理 如果想要及时删除，例如大文件提交 将对应的提交变为unreachable 后(注意 ref/reflog 等都不能索引到它)，执行 git gc --prune=now 修改本地提交 修改最新 commit 的 message git commit --amend 使用变基rebase修改、合并提交 变基，改变当前分支base 提交位置，使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像重新播放一样。用于合并分支【会将分支的提交整理成线性】 git rebase 目标分支 [源分支] （会先切换到源分支[默认为当前分支]，并将当前分支指向目标分支的位置，应用源分支上的每个提交） (1) 修改本分支上的旧 commit 的提交信息 对自己进行变基，重新修改 base 提交后续的提交 git rebase -i commitID commitID 应该选取为需要修改的前一个提交 ID，通过交互式命令操作后续提交的状态，从而修改后续的所有提交 (2) 合并分支上的几个 commit git rebase -i commitID 同样可以操作不同的 commit 不同场景的恢复 首先需要知道工作区、暂存区和最近提交 commit 三者之间的关系 注意理解：分支 branch 是指向最新提交的指针(main)，通过它可以追溯到整个历史记录 git reset 命令的介绍： # git reset [--soft | --mixed | --hard] &lt;commit&gt; # --mixed 是默认值，同 git reset &lt;commit&gt; # 修改当前分支，将分支指向 &lt;commit&gt; 位置，同时重置暂存区内容与 &lt;commit&gt; 相同，但是不修改工作区(还是原来最新的工作区内容) # 可以用于将工作区的内容重新提交，通过回退分支+重新提交达到变相修改提交的目的 # --soft # 仅移动分支的头指针到指定的提交，不修改暂存区和工作目录 # --hard # 强制代码回滚，参考下节 常见的恢复场景： 让暂存区恢复成 HEAD 一样 git reset HEAD [file1 ...] 含义：使用 git reset —mixed HEAD ，重置了当前的暂存区为最新提交状态。保持最新工作区状态。 类似命令：git restore --staged &lt;file&gt; 必须加文件路径，是一个局部(指定文件)恢复操作，并且不会修改分支指针的状态 将工作区恢复成暂存区一样 git checkout -- '*' 丢弃最近的几次提交【代码回滚】 git reset —hard commitID 说明：由于丢弃的提交处于游离部分/不属于分支或 tag 关联的提交，可能会被清理，想切换分支请使用 checkout 命令 cherry-pick 复制提交 与分支合并(merge/rebase)不同，在只需要复制其他分支某一个 commit，使用 cherry-pick 命令，即可复制一个特定的提交到当前分支并生成一次新的提交，避免了相同的工作或分支的合并操作。 git cherry-pick commitID 在当前分支应用特定的提交 贮藏工作区与暂存区 https://git-scm.com/book/zh/v2/Git-工具-贮藏与清理 场景：当正在自己分支上开发，并修改和暂存了部分文件，临时需要切换到其它分支工作，但是此时不想提交自己未完成的工作。需要临时保存自己的工作状态，使用 git stash 来保存。 git stash 将工作区和暂存区中尚未提交的修改存入栈中 git stash list 查看栈中所有元素 git stash pop --index 将栈顶存储的修改恢复到当前分支，同时删除栈顶元素 默认会将先前暂存区的存储的内容撤销到工作区(暂存区修改的内容被清空)，使用--index恢复暂存区的内容/恢复得和原来一样 git stash apply --index 将栈顶存储的修改恢复到当前分支，但不删除栈顶元素 git stash drop 删除栈顶存储的贮藏 远程分支操作 https://learngitbranching.js.org/?locale=zh_CN .gitignore 配置 添加忽略文件列表到 .gitignore ，让 git 忽略这些文件/不管理 有时一些文件最好不要用 Git 跟踪。这通常在名为 .gitignore 的特殊文件中完成。你可以在 github.com/github/gitignore 找到有用的 .gitignore文件模板。或者：https://www.toptal.com/developers/gitignore 简单示例： *.class doc/ # 忽略doc文件夹 doc/*.txt # 非递归 doc/**/*.pdf # 递归，忽略doc/下所有pdf # 不忽略.gitignore和App.class: !.gitignore !App.class Git 集成使用禁忌 禁止向团队集成的分支强制推送 push -f 强制推送分支，发生冲突会强制覆盖远程分支的内容。会导致原来分支内容全部丢失/或部分丢失。 因此，对团队的集成分支严禁使用 push -f 命令 禁止对团队的集成分支作变基操作 团队的集成分支，是不能修改历史提交的，只能通过增加 commit 提交来改进 如果使用 rebase 修改历史，会导致其他成员与集成分支的冲突。 💡 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作. 手册 https://git-scm.com/book/zh/v2/Git-分支-变基 可视化 Git 命令 https://ndpsoftware.com/git-cheatsheet.html#loc=workspace; Git 相关文章 https://github.blog/2022-09-13-scaling-gits-garbage-collection/ ","tags":[{"name":"Git","slug":"git","used":true,"link":"https://blog.qxxiao.eu.org/tag/git/"}],"title":"理解Git和实战","feature":"https://images.unsplash.com/photo-1556075798-4825dfaaf498?ixlib=rb-4.0.3&q=80&fm=jpg&crop=entropy&cs=tinysrgb","link":"https://blog.qxxiao.eu.org/post/理解Git和实战/","stats":{"text":"8 min read","time":459000,"words":2032,"minutes":8},"date":"2022-10-17 15:48:00","dateFormat":"2022-10-17","isTop":false},{"content":" 转载： Java线程池实现原理及其在美团业务中的实践 随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。 本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。 一、写在前面 1.1 线程池是什么 线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。 而本文描述线程池是JDK中提供的ThreadPoolExecutor类。 当然，使用线程池可以带来一系列好处： 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 提高响应速度：任务到达时，无需等待线程创建即可立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。 提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。 1.2 线程池解决的问题是什么 线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题： 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。 系统无法合理管理内部的资源分布，会降低系统的稳定性。 为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。 Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。 在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。 二、线程池核心设计与实现 在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。 2.1 总体设计 Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。 图1 ThreadPoolExecutor UML类图 ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。 ExecutorService接口增加了一些能力： （1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法； （2）提供了管控线程池的方法，比如停止线程池的运行。 AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。 最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。 ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示： 图2 ThreadPoolExecutor运行流程 线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。 任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转： 直接申请线程执行该任务； 缓冲到队列中等待线程执行； 拒绝该任务。 线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。 接下来，我们会按照以下三个部分去详细讲解线程池运行机制： 线程池如何维护自身状态。 线程池如何管理任务。 线程池如何管理线程。 2.2 生命周期管理 线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示： private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。 关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示： private static int runStateOf(int c) { return c &amp; ~CAPACITY; } //计算当前运行状态 private static int workerCountOf(int c) { return c &amp; CAPACITY; } //计算当前线程数量 private static int ctlOf(int rs, int wc) { return rs | wc; } //通过状态和线程数生成ctl ThreadPoolExecutor的运行状态有5种，分别为： 其生命周期转换如下入所示： 图3 线程池生命周期 2.3 任务执行机制 2.3.1 任务调度 任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。 首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下： 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。 如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。 如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。 如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。 其执行流程如下图所示： 图4 任务调度流程 2.3.2 任务缓冲 任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。 阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素： 图5 阻塞队列 使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员： 2.3.3 任务申请 由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。 线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示： 图6 获取任务流程图 getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。 2.3.4 任务拒绝 任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。 拒绝策略是一个接口，其设计如下： public interface RejectedExecutionHandler { void rejectedExecution(Runnable r, ThreadPoolExecutor executor); } 用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下： 2.4 Worker线程管理 2.4.1 Worker线程 线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码： private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ final Thread thread;//Worker持有的线程 Runnable firstTask;//初始化的任务，可以为null } Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。 Worker执行任务的模型如下图所示： 线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。 ​Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。 1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。 在线程回收过程中就使用到了这种特性，回收过程如下图所示： 2.4.2 Worker线程增加 增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示： 2.4.3 Worker线程回收 线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。 try { while (task != null || (task = getTask()) != null) { //执行任务 } } finally { processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己 } 线程回收的工作是在processWorkerExit方法完成的。 事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。 2.4.4 Worker线程执行任务 在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下： 1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。 执行流程如下图所示： 三、线程池在业务中的实践 3.1 业务背景 在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。 场景1：快速响应用户请求 描述：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。 分析：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。 场景2：快速处理批量任务 描述：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。 分析：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。 3.2 实际问题及方案思考 线程池使用面临的核心的问题在于：线程池的参数并不好配置。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。 关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子： Case1：2018年XX页面展示接口大量调用降级： 事故描述：XX页面展示接口产生大量调用降级，数量级在几十到上百。 事故原因：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图线程数核心设置过小引发RejectExecutionException如下： Case2：2018年XX业务服务不可用S2级故障 事故描述：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。 事故原因：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低如下： 业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向： 1. 能否不用线程池? 回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研： 综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。 2. 追求参数设置合理性？ 有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？ 带着这样的疑问，我们调研了业界的一些线程池参数配置方案： 调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。 3. 线程池参数动态化？ 尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下： 基于以上三个方向对比，我们可以看出参数动态化方向简单有效。 3.3 动态化线程池 3.3.1 整体设计 动态化线程池的核心设计包括以下三个方面： 简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。 3.3.2 功能架构 动态化线程池提供如下功能： 动态调参：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 任务监控：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 负载告警：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 操作监控：创建/修改和删除线程池都会通知到应用的开发负责人。 操作日志：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 权限校验：只有应用开发负责人才能够修改应用的线程池参数。 参数动态化 JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图JDK 线程池参数设置接口所示： JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下： 线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图可动态修改线程池参数所示： 用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。 线程池监控 除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。 1. 负载监控和告警 线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。大象告警通知 2. 任务级精细化监控 在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图线程池任务执行监控所示： 3. 运行时状态实时查看 用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图线程池实时运行情况所示： 动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图线程池实时运行情况所示： 3.4 实践总结 面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。 四、参考资料 [1] JDK 1.8源码 [2] 维基百科-线程池 [3] 更好的使用Java线程池 [4] 维基百科Pooling(Resource Management) [5] 深入理解Java线程池：ThreadPoolExecutor [6]《Java并发编程实践》 作者简介 致远，2018年加入美团点评，美团到店综合研发中心后台开发工程师。 陆晨，2015年加入美团点评，美团到店综合研发中心后台技术专家。 ","tags":[{"name":"Java","slug":"java","used":true,"link":"https://blog.qxxiao.eu.org/tag/java/"}],"title":"Java线程池实现原理","feature":"https://pic.qxxiao.cn/bg-wallhaven.jpg","link":"https://blog.qxxiao.eu.org/post/Java线程池实现原理/","stats":{"text":"32 min read","time":1863000,"words":8986,"minutes":32},"date":"2022-10-14 10:24:29","dateFormat":"2022-10-14","isTop":false},{"content":"https://www.acwing.com/blog/content/21860/ https://www.w3cschool.cn/java/ http://www.java2s.com 变量和输入输出 Java的所有变量和函数都要定义在class中。 与C++主要的区别： Java属于完全面向对象语言，没有运算符重载(需要特定的方法实现功能) 使用虚拟机解释运行 基础类型 8种内置数据类型/基础类型，不支持无符号整数类型。 基础类型 字节数 举例 byte 1 123 short 2 12345 int 4 123456789 long 8 1234567891011L float 4 1.2F double 8 1.2，1.2D boolean 1 true，false char 2 'A'，'\\u0041' 输出输出 输入 方式1 ，使用Scanner类输入，效率较低，输入规模较小时使用 Scanner sc = new Scanner(System.in); String str = sc.next(); // 读入下一个字符串 int x = sc.nextInt(); // 读入下一个整数 float y = sc.nextFloat(); // 读入下一个单精度浮点数 double z = sc.nextDouble(); // 读入下一个双精度浮点数 String line = sc.nextLine(); // 读入下一行 方式2，使用输入流和缓存，效率较高，输入规模较大时使用。注意需要抛异常。 import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) throws Exception { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); System.out.println(str); } } 输出 方式1，使用print系列方法，效率较低，输出规模较小时使用。 System.out.println(123); // 输出整数 + 换行 System.out.println(&quot;Hello World&quot;); // 输出字符串 + 换行 System.out.print(123); // 输出整数 System.out.print(&quot;yxc\\n&quot;); // 输出字符串 System.out.printf(&quot;%04d %.2f\\n&quot;, 4, 123.456D); // 格式化输出，float与double都用%f输出 方式2，使用输出流和缓存效率较高，输出规模较大时使用。注意需要抛异常。 import java.io.BufferedWriter; import java.io.OutputStreamWriter; public class Main { public static void main(String[] args) throws Exception { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); bw.write(&quot;Hello World\\n&quot;); bw.flush(); // 需要手动刷新缓冲区 } } 字符串和数组 字符串 字符串类String的常用初始化方式： String a = &quot;Hello World&quot;; String b = &quot;My name is&quot;; String x = b; // 存储到了相同地址 String c = b + &quot;yxc&quot;; // String可以通过+拼接 String d = &quot;My age is &quot; + 18; // int会被隐式转化成字符串&quot;18&quot; String str = String.format(&quot;My age is %d&quot;, 18); // 格式化字符串，类似于C++中的sprintf String money_str = &quot;123.45&quot;; double money = Double.parseDouble(money_str); // String转double;其余包装类型具有类似方法 注意：Java 中的字符串是只读变量(底层使用 final 修饰)，不能修改；每次拼接会构造一个新的字符串。 注意访问String中的字符方式： str.length()返回该字符串 Unicode 码点数量（字符的数量） 使用str.charAt(int index)访问第index个字符 说明：底层使用 char(16bit) 存储，UTF16编码思想：从U+D800到U+DFFF之间的码位区段是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对**辅助平面的字符(从U+10000到U+10FFFF)**的码位进行编码。https://zh.m.wikipedia.org/zh-hans/UTF-16 String str = &quot;Hello World&quot;; for (int i = 0; i &lt; str.length(); i ++ ) { System.out.print(str.charAt(i)); // 只能读取，不能写入 } 字符串类常用 API: length()：返回长度 split(String regex)：分割字符串 indexOf(int c)、indexOf(String str)：查找，返回第一次找到下标，找不到返回-1 equals()：判断两个字符串是否相等，注意不能直接用 == compareTo()：判断两个字符串的字典序大小，负数表示小于，0表示相等，正数表示大于 startsWith()：判断是否以某个前缀开头 endsWith()：判断是否以某个后缀结尾 trim()：去掉首尾的空白字符 toLowerCase()：全部用小写字符 toUpperCase()：全部用大写字符 replace(char oldChar, char newChar)：替换字符(所有位置) replace(CharSequence target, CharSequence rep)：替换字符串(replaceFirst,replaceAll) substring(int beginIndex, int endIndex)：返回[beginIndex, endIndex)中的子串 可修改的字符串类型：StringBuilder、StringBuffer 如果打算修改字符串，可以使用StringBuilder和StringBuffer。 StringBuilder线程不安全，速度较快；而StringBuffer线程安全，速度较慢。 StringBuilder sb = new StringBuilder(&quot;Hello &quot;); // 初始化 sb.append(&quot;World&quot;); // 拼接字符串 System.out.println(sb); for (int i = 0; i &lt; sb.length(); i ++ ) { sb.setCharAt(i, (char)(sb.charAt(i) + 1)); // 读取和写入字符 } System.out.println(sb); 常用 API： reverse()：翻转字符串 数组 Java 数组是引用类型，推荐使用 Java风格int[] arr 初始化定长数组，长度可以是变量，并且可以在初始化时赋值 int[] a = new int[5]; // 初始化长度为5的int数组，初始值为0 int n = 10; float[] b = new float[n]; // 初始化长度为n的float数组，初始值为0.0F char[] c = {'a', 'b', 'c'}; // 初始化长度为3的char数组，初始值为：'a', 'b', 'c' char[] d = c; // d与c地址相同，更改c中的元素，d中的元素也会改变【引用类型】 多维数组 注意数组是引用类型，多维数组的变量也是引用类型，使用应该申请空间。 int[][] a = new int[2][3]; a[1][2] = 1; int[][] b = { {1, 2, 3}, {4, 5, 6}, }; // 声明和初始化赋值 System.out.println(a[1][2]); System.out.println(b[0][1]); 数组常用 API：(使用Arrays工具类操作) 属性 length：返回数组长度，注意不加小括号(属性) Arrays.sort()：数组排序 Arrays.fill(int[] a, int val)：填充数组 Arrays.toString()：将数组转化为字符串 Arrays.deepToString()：将多维数组转化为字符串 Arrays.asList(T…)返回自己实现的一个内部类ArrayList(实现了List接口)—保存了参数数组的引用，是该数组的一个视图(修改会反映到原数组)；说明：如果要得到一个可独立修改并可以添加/删除的List，使用***ArrayList&lt;&gt;(Arrays.asList(array))***。 copyOf复制数组(一维)；binarySearch()二分查找，需要先排序；equals()判断两个数组是否相等，如果元素是对象使用(e1==null ? e2==null : e1.equals(e2))判断对应位置元素相等；对于多维数组使用deepEquals()；stream()返回对应元素的流； 数组是不可变长度的 类和接口 Java 中所有变量和函数都要定义在类中。 源文件声明规则 一个源文件中最多只能有一个public类(其它类都为默认) 源文件的名称应该和public类的类名保持一致 每个源文件中，先写package语句，再写import语句，最后定义类 变量或方法前加static表示静态变量(类变量)/静态方法(类方法)，属于class，而不属于class的具体实例。static 可以修饰 Block 即静态块，用来初始化静态数据成员。static也可用来修饰内部类。 静态方法中只能调用静态方法和静态变量即类成员； 静态方法不能使用this,super 内部类 内部类主要分为非静态内部类和静态内部类。 说明：非静态内部类，其对象总有一个隐式引用，指向了创建它的外部类对象，所以可以访问外部类变量/方法。可以定义 static变量但是不能定义静态块(java8)。 静态内部类，属于外部类本身，但是不属于外部类的任何对象。 静态内部类只能访问外部类的类成员。 外部类可以使用静态内部类的类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类对象访问其实例成员。 4种访问修饰符 Java 中有4中访问修饰符，public, protected, friendly(default), private。 Java访问控制符的含义和可访问情况： 类内部 本包 子类 外部包 public ✔️ ✔️ ✔️ ✔️ protected ✔️ ✔️ ✔️ ✖️ friendly(default) ✔️ ✔️ ✖️ ✖️ private ✔️ ✖️ ✖️ ✖️ public：可以被所有其他类所访问 protected：自身，子类及同一个包中类可以访问 friendly：同一包中的类可以访问，声明时没有加修饰符，认为是friendly private：只能被自己访问和修改 注意：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。通过反射的手段，是可以访问任何包下任何类中的成员。 类继承 每个类最多只能继承一个类。 示例：使用super来调用父类构造函数或者访问其成员。 class ColorPoint extends Point { private String color; public ColorPoint(int x, int y, String color) { super(x, y); this.color = color; } public void setColor(String color) { this.color = color; } public String toString() { return String.format(&quot;(%d, %d, %s)&quot;, super.getX(), super.getY(), this.color); } } 方法重载 方法签名不同，即参数个数或者对应类型不相同的同名函数称作方法重载。 类(及接口)的多态 父类引用(或者接口)可以指向不同子类(接口变量指向不同是的实现类对象)，调用相同方法运行结果不同。【根据指向具体类型，调用其对应的方法实现】 接口和实现 接口主要用来定义行为，即定义类需要实现的方法(抽象方法的集合)。 接口可以继承其他多个接口，每个类可以实现多个接口(具有不同的行为)。 接口中可以定义(默认修饰符是public static final) 变量，以及抽象方法(默认使用public abstract修饰)；可以定义方法的默认实现(方法前添加default关键字)。 除非实现接口的类是抽象类，否则该类要定义/实现接口中的所有方法(默认方法可以不用)； 接口无法被实例化，但是可以被实现； 接口类型可用来声明一个变量，可以是null，或是被绑定在实现接口的类对象。 🌈 标记接口:没有包含任何方法的接口，仅表明它的类属于一个特定的类型。作用在于向类添加数据类型(添加该接口类型)以及建立公共的父接口。 实例： // 接口定义 interface Role { public void greet(); // public abstract } // 接口的继承，可以继承多个 interface Hero extends Role { public void attack(); } // 接口的实现 class Zeus implements Hero { private final String name = &quot;Zeus&quot;; public void attack() { System.out.println(name + &quot;: attack!&quot;); } public void greet() { System.out.println(name + &quot;: Hi!&quot;); } } // 接口的多态 class Athena implements Hero { private final String name = &quot;Athena&quot;; public void attack() { System.out.println(name + &quot;: attack!&quot;); } public void greet() { System.out.println(name + &quot;: Hi!&quot;); } } // ------------------------------------------------- public class Main { public static void main(String[] args) { Hero[] heros = {new Zeus(), new Athena()}; for (Hero hero: heros) { hero.greet(); } } } 泛型 Java的类和接口也可以定义泛型，即同一套函数可以作用于不同的对象类型。 注意：Java 泛型只能使用对象类型，不能用于基本变量类型。并且只是编译期泛型，运行时会擦除。 其它 集合框架｜泛型 IO 注解 反射 多线程 网络编程 XML ","tags":[{"name":"Java","slug":"java","used":true,"link":"https://blog.qxxiao.eu.org/tag/java/"}],"title":"Java SE基础","feature":"https://pic.qxxiao.cn/java-logo.png","link":"https://blog.qxxiao.eu.org/post/Java SE基础/","stats":{"text":"12 min read","time":667000,"words":2741,"minutes":12},"date":"2022-09-04 12:27:00","dateFormat":"2022-09-04","isTop":false},{"content":"基于官方文档总结 [TOC] 阅读 简介 | Vue.jsVue.js - 渐进式的 JavaScript 框架 https://staging-cn.vuejs.org/guide/introduction.html 模版语法 Vue允许声明式地将 DOM 绑定至底层组件实例的数据。 插值 文本插值 使用&lt;span&gt;Message: {{ msg }}&lt;/span&gt;语法绑定组件实例中的对应的 property 的值。 使用v-once指令进行一次性插值 原始 HTML 文本插值会解释为普通文本，如果需要输出 HTML，使用v-html 指令: &lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt; &lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;!--将整个v-html作用的标签 替换作为html内容--&gt; 属性 Attribute 用于动态修改标签属性的值，使用v-bind 指令： &lt;img v-bind:src=&quot;img&quot; alt=&quot;img&quot; /&gt; &lt;img :src=&quot;img&quot; alt=&quot;img&quot; /&gt; 说明：如果绑定的值是null或undefined，那么该 attribute 将不会被包含在渲染的元素上。（bool 属性有所区别） 使用JS表达式 对于所有的数据绑定，Vue 都提供了完全的 JavaScript 表达式支持（单个表达式） {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} &lt;div v-bind:id=&quot;'list-' + id&quot;&gt;&lt;/div&gt; 事件中也可以使用JS表达式 指令 常见指令如下，有的指令可以接收参数（冒号后） v-html v-bind（可以缩写:） v-model 在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;等元素上创建双向数据绑定。 v-if v-for v-on（可以缩写@） 指令参数也是支持 JS 表达式，语法： &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt; data 和 methods 组件的data选项是函数，创建组件实例时返回一个对象，并以$data存储在组件实例中。 同时该对象的顶级属性 property 会直接通过组件示例暴露处理。 组件的methods选项为包含组件所需要的方法的对象，Vue 自动为其绑定了this，始终指向组件实例。定义方法时避免使用箭头函数。 const app = Vue.createApp({ data() { return { count: 4 } }, methods: { increment() { // `this` 指向该组件实例 this.count++ } } }) const vm = app.mount('#app') console.log(vm.count) // =&gt; 4 vm.increment() console.log(vm.count) // =&gt; 5 data 返回对象的原因： 组件是可复用的，通过函数局部作用域创建并返回的对象，每个组件实例是不同的，否则组件之间的数据可能干扰。 计算属性和侦听器 计算属性 computed 💡 对于包含响应式数据的复杂逻辑，应该使用计算属性 在配置对像中的computed对象中定义计算属性（其实是一个函数并返回结果）。使用时可以像普通属性一样将数据(计算属性的结果)绑定到模版中的计算属性。 好处：一次声明Vue可以知道该计算属性依赖的真实属性，当依赖属性发送改变时，依赖该计算属性的绑定都会更新。与使用方法相比，计算属性可以缓存结果。 &lt;div id=&quot;computed-basics&quot;&gt; &lt;span&gt;{{ computedMsg }}&lt;/span&gt; &lt;/div&gt; Vue.createApp({ data(){...} computed: { // 计算属性 computedMsg() { return this.msg.split('').reverse().join(''); }, }, }).mount('#computed-basics') 侦听器 watch watch选项提供类一个更加通用方式来响应数据的变化。用于执行异步操作，或者开销比较大的操作。 ... watch: { // 每当 message 发生变化时，该函数将会执行 message(newValue, oldValue) { if(newValue.length()&gt;oldValue.length()){ this.getNewMessage() } } }, ... 深度侦听 ... watch: { &quot;user.name&quot;: { // 使用字符串，仅仅单独侦听该对象的某个属性 immediate: true, // 初始化时也会调用函数 deep: true, // 深度侦听，用于侦听对象中的属性变化 handler: function(newValue){ console.log(newValue); } } }, ... 样式绑定 操作元素的 class 列表和内联样式其实也是一种数据绑定，绑定元素的 attribute。 使用 v-bind 绑定class ｜ style，表达式结果可以是字符串、对象以及数组。 例如使用 data property 中的对象进行绑定： &lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;!-- v-bind:class 简写 --&gt; data() { return { classObject: { // 作为绑定的对象 active: true, 'text-danger': false } } } 或者可以绑定一个返回对象的计算属性；数组和对象也可以结合使用。 内联样式绑定与之类似。CSS property 名用驼峰式或短横线分隔 (用引号括起来) 来命名。 渲染 条件渲染 v-if/v-else/v-else-if有条件的渲染元素/分组(使用&lt;template&gt;标签包裹) v-show 使用v-if/v-else，v-if 中表达式返回 truthy 值的时候被渲染，否则渲染 v-else 元素 &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; v-show的元素始终会被渲染并保留在 DOM 中。v-show只是简单地切换元素的displayCSS property。它不支持&lt;template&gt;元素，也不支持v-else 💡 v-if更多适用与一次渲染或者条件改变不频繁的场景，v-show可用于条件频繁改变场景 列表渲染 使用v-for进行列表渲染数组 &lt;ul id=&quot;array-with-index&quot;&gt; &lt;!--(item, index) of items--&gt; &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;item.id&quot;&gt; {{ index }} - {{ item.message }} &lt;/li&gt; &lt;/ul&gt; 也可以渲染一个对象，第一个参数是对象键值，第二个参数是键名（可选的第三个参数 index）。注意遍历对象时使用的Object.keys()结果遍历。 注意：Vue 默认使用就地更新的策略，如果数据项顺序发生改变，并不会移动 DOM 元素来匹配数据项的位置顺序，只是就地更新每个元素。因此应该尽可能在使用v-for时提供:key作为标识来追踪该节点的身份(应该应用哪个数据项)。 Vue 将侦听的数组的变更方法进行了包裹，使用会自动触发视图的更新。 显示过滤/排序后的结果？ 可以使用计算属性，不实际变更或重置原始数据，只是返回过滤/排序后的数组。或者在嵌套的 v-for 循环中使用 methods 。 v-for 中可以使用整数，&lt;span v-for=&quot;n in 10&quot; :key=&quot;n&quot;&gt;{{ n }} &lt;/span&gt;重复模版 10次 利用&lt;template&gt;和v-for循环渲染一段包含多个元素的内容 v-for 与 v-if 不推荐在同一元素上使用v-if和v-for。当它们处于同一节点，v-if的优先级比v-for更高，这意味着v-if将没有权限访问v-for里的变量。 推荐写法：使用&lt;template&gt; &lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; {{ todo.name }} &lt;/li&gt; &lt;/template&gt; 事件处理 使用v-on指令 (通常缩写为@符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为v-on:click=&quot;methodName&quot;或使用快捷方式@click=&quot;methodName&quot; 事件处理写法： 直接内联 JS 代码 定义 Methods 中的(事件处理)方法，直接绑定一个方法的名称 在内联 JavaScript 语句中调用方法（12结合）；用特殊变量$event表示原始 DOM event对象 事件修饰符： .stop阻止事件继续冒泡 .prevent阻止默认行为，例如提交事件会重载页面 .once只能触发一次处理函数 .self只当在 event.target 是当前元素自身时触发处理函数 .capture内部元素触发的事件先在此处理 表单输入绑定 用v-model指令在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。 本质就是：绑定数据，并且监听用户的输入数据来更新对应的数据。 v-model不会在输入法组织文字过程中得到更新。使用input事件监听器和value绑定来替代v-model可以响应。 【会忽略表单元素 attr 上的初始值，可以在组件的 data 选项中声明其初始值】 &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot; /&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; 常见表单用法： https://v3.cn.vuejs.org/guide/forms.html#文本-text v-model 修饰符 .lazy v-model 默认每次input事件触发后将输入框的值与数据进行同步；使用 .lazy 修饰转为在change事件之后进行同步 .number 将用户的输入值转为数值类型；当输入类型为text时这通常很有用，如果值无法被parseFloat()解析，则返回原始值 .trim 自动过滤用户输入的首尾空白字符 组件 组件是带名称的可复用的实例。都接收相同的选项，例如data、computed、watch、methods以及生命周期钩子等。 说明：为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。 向子组件传递数据 使用 Prop 在组件上注册一些自定义 attribute 即 Prop，使用props选项来定义该组件可接受的 prop 列表。父组件通过该 prop 来向该子组件传值，该 property 的值可以在该组件的模板中访问。 传值，可以使用v-bind或:来动态传值： &lt;div id=&quot;blog-posts-demo&quot;&gt; &lt;blog-post v-for=&quot;post in posts&quot; :key=&quot;post.id&quot; :title=&quot;post.title&quot;&gt; &lt;/blog-post&gt; &lt;/div&gt; 定义props简单方式是定义 prop 数组，也可以定对象来为 prop 指定验证要求： export default { props: { title: { type: String, default: 'Hello !!!', required: true, } } } 注意：对象/数组的默认值，必须从一个工厂函数返回。 单向数据流 单向下行绑定，父级 prop 的更新会向下流动到子组件中，但是反过来则不行 向父组件传递数据 不能直接使用 Prop 方式传递，父组件可以监听子组件自定义的事件来接收传递的数据。 子组件中： // 在方法中定义触发的事件 methods:{ sendParent(){ // $emit 来触发事件 this.$emit(&quot;sendMsg&quot;, this.msg); } }, ... 父组件中： // 在子组件元素上监听事件 &lt;template&gt; &lt;ChildComponent @sendMsg=&quot;getChildMsg&quot;&gt;&lt;/ChildComponent&gt; &lt;/template&gt; 模版引用（访问组件） 在 JavaScript 中直接访问子组件，可以使用refattribute 为子组件或 HTML 元素指定引用 ID： &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt; 以 JS 方式访问元素(DOM)，例如以编程的方式 focus 到这个 input 。 父组件直接访问子组件：$refs 父组件中定义的(子组件)元素上使用ref=&quot;usernameInput&quot;添加引用名称后，可以使用$refs.usernameInput来获取引用元素. $refs只会在组件渲染完成之后生效，避免在模板或计算属性中访问 子组件访问父组件：$parent 子组件中使用$parent可以获取父组件对象信息。 由于组件是复用的，从而父组件可能是不同的，不建议使用该方式获取数据。而建议使用 Prop 来传递数据。 访问根组件：$root 插槽 类似与 HTML 中向一个标签传递值： &lt;alert-box&gt;Something bad happened.&lt;/alert-box&gt; 在组件中可以利用**&lt;slot&gt;&lt;/slot&gt;**来作为插入内容的占位符，在使用该组件元素时(使用双标签语法)可以进行填充。 &lt;Component1&gt;&lt;button&gt;111&lt;/button&gt;&lt;/Component1&gt; &lt;Component1&gt;&lt;p&gt;hello world!&lt;/p&gt;&lt;/Component1&gt; 如何定义多个插槽？ 具名插槽，定义 slot 时添加 name 属性，使用组件元素时使用&lt;templat&gt; 和 v-slot指令包裹每个插槽对应的内容： &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; 作用域插槽 为了某些场景(自定义渲染列表的方式)，插槽的中数据内容可以由子组件提供，使用**v-slot:default=&quot;slotProps&quot;** 来接收子组件定义插槽时传递的所有数据对象 slotProps &lt;template v-slot:default=&quot;slotProps&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in slotProps.list&quot; :key=&quot;item&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; 跨级通信 如果组件层次结构较深，使用provide, inject，父组件可以作为其所有子组件的依赖提供者。 父组件有一个provide 选项来提供数据，子组件有一个inject 选项来开始使用这些数据。作用类似于 Prop 数据的传递。 // 祖先组件的 provide 选项 provide: { user: 'John Doe' }, // 子组件使用 inject 选项 inject: ['user'], 注意：如果 provide 选项是一个对象，则不能直接访问组件实例的 property。 为了使用组件实例的 property，则 provide 选项需要改为返回对象的函数。 响应性问题 即使这样，访问的 property 也不是响应性绑定，即祖先数据的变化不会反映在子组件 inject 中的 property。默认的 provide/inject 绑定不是响应式的。 resolve: 可以通过传递一个refproperty 或reactive对象给provide来改变这种行为 响应式对象 provide(){ return{ obj: this.obj, // 接收的是包含数据的对象(修改也是修改该对象中的数据) } }, 箭头函数（响应式数据） provide(){ return{ message: ()=&gt;this.message, // 接收的是函数，调用才返回响应式数据 } }, 子组件多次调用中，可以使用计算属性来缓存该结果。 组合式 APIcomputed 生命周期 生命周期图示 使用： 组件视图更新（绑定数据更新）会执行对应的beforeUpdate，updated函数 组件的销毁和创建，会执行beforeUnmount，unmounted函数，例如使用 v-if 进行条件渲染。 组合式API 作用：将同一个逻辑关注点相关代码收集在一起。 setup选项是一个接收props/context的函数，在组件创建之前执行（可以代替 beforeCreate, created 生命周期钩子）。并且不能使用 this 来访问组件实例。 setup 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板(模版中使用的引用变量会自动浅解包)。 setup 选项中定义的变量默认是非响应式的(修改不会影响视图)，使用ref函数接收参数并将其包裹在一个带有valueproperty 的对象中返回，使用该 property 可以访问/修改该响应式变量值。因为JS中Number或String等基本类型是通过值而非引用传递，这样封装也是为了不同数据类型的行为统一。 ref()响应式变量 对Number, String使用 ref() ，返回响应式对象，通过value属性访问值。 数组对象也通常使用 ref() 对于对象，使用reactive()和toRefs() 对象使用 reactive() 返回代理对象（响应式） 为了直接暴露对象的属性名称(来访问值)，使得通过该属性名称访问也是响应式的，使用 toRefs() 与对象解构用法：toRefs() 返回一个对象，每个属性值都是原属性的响应式对象 ObjectRefImpl (方法需要一个响应式对象参数) 💡 ref() 返回的是 RefImpl，如果参数是对象，其value就是该对象的代理对象。reactive()直接返回对象的代理对象Proxy。一般对象使用 reactive 更加方便。 // setup() ... const user = reactive({ name: 'xiaoming', age: 20, }); const { name, age } = toRefs(user); function changName() { // console.log(name.value); name.value = 'zhou123'; } function changAge() { age.value = 22; } return{ name, age, changeName, changeAge} watch 组合式 API，从 vue 导入watch函数执行相同的操作。 一个想要侦听的响应式引用或 getter 函数 一个回调 可选的配置选项 注意 watch 函数只能监听getter 函数/ ref / reactive 对象，响应式对象中的属性改变会调用回调函数(但不能获取属性旧值)。 另一个是 watchEffect() ，自动分析依赖，发生改变后触发，不能获取旧值。 //setup() const user = reactive({ name: 'aaa', age: 18, }); changeUserName(){ user.name = 'bbb'; } watch(user, (newVal, oldVal)=&gt;{ ... }); watchEffect(()=&gt;{ console.log(user.name); }); computed 组合式 API，从 vue 导入computed函数执行相同的操作。 返回一个带有 value 属性的对象。模版中可以直接使用该名称。 // setup() const reverseMsg = computed(()=&gt;{ return msg.value.split('').reverse().join('') }) setup 获取值 setup() 中不能使用 this，setup(props, context) 有 setup函数中的props也是响应式的，当传入新的 prop 时，它将被更新。为组件接收的参数。因为props是响应式的，不能使用 ES6 解构，它会消除 prop 的响应性，使用toRefs 函数完成。 context是一个普通 JavaScript 对象，暴露了其它可能在setup中有用的值： context.attrs 等同于 $attrs，获取组件标签上定义的属性 context.slots 非响应式对象，等同于 $slots context.emit 方法，等同于 $emit，用来触发事件 context.expose 函数，暴露公共 property 。如果组件的 setup() 返回渲染函数(替代template)，它用来暴露组件的公共 property。组件元素上定义ref=&quot;refName&quot;，外部组件使用 $refs 来访问(模板 ref)。 生命周期钩子 https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html Provide / Inject 在setup()中使用provide，导入该方法即可。 在setup()中使用inject时，也需要从vue显式导入。 可以在 provide 值时使用ref 或reactive增加值之间的响应性。 ref 属性 reactive 对象 组合式 APIcomputed // ref let counter = ref(0) // let user = reactive({ name: 'abc', age: 20, }) let len = Vue.computed(() =&gt; this.todos.length) provide('counter', counter) provide('user', user) provide('len', len) SFC 单文件组件 &lt;script setup&gt;语法糖，相当于 set() 函数的定义，特殊点： 导入的子模块不需要注册，可以直接在模版中使用 顶层的绑定（变量/函数，导入的函数等）会直接暴露给模版使用（即定义的变量不需要通过 return 暴露） 定义响应式变量，也需要从vue中导入 prop 可以使用defineProps()宏来定义 ","tags":[{"name":"Vue","slug":"vue","used":true,"link":"https://blog.qxxiao.eu.org/tag/vue/"}],"title":"Vue 基础","feature":"https://pic.qxxiao.cn/vuejs.png","link":"https://blog.qxxiao.eu.org/post/Vue 基础/","stats":{"text":"19 min read","time":1095000,"words":4547,"minutes":19},"date":"2022-06-09 03:00:00","dateFormat":"2022-06-09","isTop":false},{"content":"多 package 的 Rust Workspace 组织和配置。 [TOC] Cargo 工作空间，可以管理相互关联需要协同开发的的 crate。共享同一个 Cargo.lock 和 输出文件夹。 创建工作空间 在工作区目录创建Cargo.lock，并使用cargo new packageName [—lib]创建需要的多个 Package。所得工作空间目录结构： ws ├── adder │ ├── Cargo.toml │ └── src ├── add-one │ ├── Cargo.toml │ └── src ├── add-two │ ├── Cargo.toml │ └── src ├── target │ ├── CACHEDIR.TAG │ ├── debug │ └── tmp ├── Cargo.lock └── Cargo.toml 将 package 添加到工作空间的成员配置下： # 工作空间下的 Cargo.toml [workspace] members=[ 'add-one', 'add-two', 'adder', ] exclude=[] 注意的问题： 不同 package 中使用的依赖版本会保持一致，配置在工作空间的Cargo.lock中 不同的 package 中的 crate 的依赖关系需要显示在 package 的 Cargo.toml 中配置： # Cargo.toml [package] name = &quot;add-two&quot; version = &quot;0.1.0&quot; edition = &quot;2021&quot; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] add-one = { path = &quot;../add-one&quot; } # relative path 💡 引用add-twocrate 时，rs 源文件使用 add_two 代替（下划线）use add_two::add_fun 构建和发布 构建指定的 crate，可以到该 package 下运行或者指定路径cargo run -p adder crate 发布时，需要切换指定的 package 文件夹下执行cargo publish；并且依赖中path说明会被移除，使用crates.io中的版本。 [dependencies] add-two = { path = &quot;../add-two&quot;, version = &quot;0.1.0&quot; } ","tags":[{"name":"Rust","slug":"rust","used":true,"link":"https://blog.qxxiao.eu.org/tag/rust/"}],"title":"Rust Workspace","feature":"https://pic.qxxiao.cn/20220530212851.png","link":"https://blog.qxxiao.eu.org/post/Rust Workspace/","stats":{"text":"2 min read","time":92000,"words":345,"minutes":2},"date":"2022-06-02 20:42:00","dateFormat":"2022-06-02","isTop":false},{"content":" Youtube IPFS More Bilibili Gride Markdown This is a notion2md page. 😃 Youtube 带你认识 CPU IPFS 🌈 使用notion转md时，可以用来存储一些大文件。 video hosted by IPFS gateway: nftstorage.link More 上传文件： https://gh.qxxiao.cn/IPFS-File-Uploader/ 【当前免费空间有限，已被锁定】 https://qxxiao.gitlab.io/IPFS-File-Uploader/ https://nft.storage/files/ 【当前推荐方式】 网关： checker: https://ipfs.github.io/public-gateway-checker/ https://ipfs.io | https://dweb.link | https://w3s.link/ ｜https://nftstorage.link https://ipfs.io/ipns/ipnso.com/ 下载 IPFS，本地搭建节点 Bilibili bilibili video Gride Markdown 👉 Hello World! Download File[ipfs.pdf] ","tags":[{"name":"Markdown","slug":"markdown","used":true,"link":"https://blog.qxxiao.eu.org/tag/markdown/"}],"title":"notion2md","feature":"https://www.notion.so/images/page-cover/met_vincent_van_gogh_irises.jpg","link":"https://blog.qxxiao.eu.org/post/notion2md/","stats":{"text":"1 min read","time":39000,"words":130,"minutes":1},"date":"2022-06-01 12:15:00","dateFormat":"2022-06-01","isTop":false},{"content":"Hello Rust. [TOC] Rust 快速入门系列的第二篇。 闭包｜迭代器 闭包 闭包：可以捕获其所在环境的匿名函数。（C++类似lambda，可以从其定义的作用域捕获值） 闭包可以保存为变量，作为函数参数，或者函数返回值。 fn main(){ let closure = |x| x; // let closure = |x: String| -&gt; String {x}; let s = closure(String::from(&quot;hello&quot;)); // let n = closure(5); // error 上一句已经推断出closure中的具体类型 } 闭包不要求标注参数和返回值的类型； 闭包的定义，最终只会被推断出唯一的具体类型（或者显示标注类型） 每个闭包实例都对应一个唯一匿名类型，并且闭包都实现了以下Fn Trait之一： Fn 不可变借用环境值 FnMut 可变借用环境值 FnOnce 取得所有权 利用闭包实现 Cacher 缓存器，实现延迟计算/惰性求值 use std::collections; struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, { calculation: T, value: collections::HashMap&lt;u32, u32&gt;, } impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, { fn new(calculation: T) -&gt; Cacher&lt;T&gt; { Cacher { calculation, value: collections::HashMap::new(), } } fn value(&amp;mut self, arg: u32) -&gt; u32 { match self.value.get(&amp;arg) { Some(v) =&gt; *v, None =&gt; { let v = (self.calculation)(arg); self.value.insert(arg, v); v } } } } 【闭包还不支持泛型】 捕获变量 普通函数不能捕获上下文变量，而闭包可以。结合上述3种Fn Trait，Rust可以根据环境值的使用情况推断出具体的闭包类型： 默认只捕获值的不可变引用，实现 Fn （不可变借用，只能读） 获取值的可变引用，实现 FnMut（可变借用，可以修改值） 获取值的所有权，实现 FnOnce，只能调用一次（因为获取了所有权） 💡 注意：3种Trait存在层级关系；实现了Fn的闭包都实现了FnMut，而实现了FnMut的闭包都实现了FnOnce，因此所有的闭包都实现了FnOnce. 使用move关键字： 可以在定义闭包的参数列表前使用 move，强制闭包获取值的所有权。 将闭包传递给新线程以移动数据时，非常有用。 let x = vec![1, 2, 3]; let equal_to_x = move |z: i32| z == x[0]; // println!(&quot;{:#?}&quot;, x); // error [E0382]: use of moved value: `x` 对于基本类型以及引用类型，没有所有权的变量不影响。 迭代器 Rust 迭代器是惰性迭代器，用于遍历： let v = vec![1, 2, 3]; // for val in v // 调用 into_iter() moved for val:&amp;i32 in v.iter() { // borrow println!(&quot;{}&quot;, val); } 实现： 迭代器都实现了trait Iterator，需要实现next方法；该 trait 也提供了一些默认实现方法。 pub trait Iterator{ type Item; fn next(&amp;mut self)-&gt;Option&lt;Self::Item&gt;; // default methods elided } 产生迭代器的迭代方法： iter() 创建迭代器，用于迭代元素的不可变引用； iter_mut() 创建迭代器，用于迭代元素的可变引用； **into_iter()**获取所有权，创建迭代器用于迭代元素本身； 迭代器适配器 Iterator trait 提供了迭代器适配器方法，用来将迭代器转换为不同种类的迭代器。 例如 map, filter let v = vec![1, 2, 3]; let iter = v.iter().map(|x: &amp;i32| x * 2); let iter2 = v.iter().map(|x| x * 2).filter(|x| x &gt; &amp;3); // 使用消耗型适配器方法（获取迭代器所有权，并会使用next方法） // collect 收集元素到集合类型 let v2:Vec[i32] = iter.collect(); 使用 zip 操作两个迭代器，转换为新的迭代器（元组类型） 遇到其中一个值是 None，迭代会停止。 示例 struct Counter { count: u32, } impl Counter { fn new() -&gt; Counter { Counter { count: 0 } } } impl Iterator for Counter { type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { self.count += 1; if self.count &lt; 6 { Some(self.count) } else { None } } } let sum: u32 = Counter::new().take(5) .zip(Counter::new().skip(1).take(4)) .map(|(a,b)| a*b) .filter(|x| x%3==0) .sum(); assert_eq!(18, sum); 智能指针 Rust 中的引用(使用&amp;)就是指针类型，只借用指向的值，是最常见的指针类型。（切片也是引用类型，会有长度信息） 💡 智能指针的行为类似指针，具有额外的元数据和功能；并且一般会拥有指向 数据的所有权 例如String | Vec&lt;T&gt;，拥有一片内存区域以及元数据和相关功能。 智能指针，语义上应该实现Deref trait 和 Drop trait： Deref Trait: 实现 deref() 方法 //允许智能指针 自定义解引用运算符 * 的行为 Drop Trait: 实现 drop() 方法 // 自定义当指针指针实例离开作用域时运行的代码 即实现了 Deref Trait (返回引用类型)，使得实现该 trait 类型的变量可以使用*var操作 *var // &lt;==&gt; *(var.deref()) 不允许显示调用 drop 方法，但是可以使用std::mem::drop函数； 解引用转换 Deref tait 将&amp;T ⇒ &amp;U并且类型 T 隐式实现了类型 U 的所有(不可变)方法。(隐式)解引用强制转换 deref coercion，实现了 Deref trait 的类型可以将其引用链式调用 deref 转换为其他类型的引用。 例如，String 实现了 Deref，可以自动将&amp;String转换为&amp;str 示例代码 MyBox use std::ops::Deref; struct MyBox&lt;T&gt;(T); impl&lt;T&gt; MyBox&lt;T&gt; { fn new(x: T) -&gt; MyBox&lt;T&gt; { MyBox(x) } } impl&lt;T&gt; Deref for MyBox&lt;T&gt; { type Target = T; // 关联类型，必须定义 fn deref(&amp;self) -&gt; &amp;T { &amp;self.0 } } fn main(){ let m = MyBox::new(String::from(&quot;Rust&quot;)); hello(&quot;hello Rust&quot;); hello(&amp;m); hello(&amp;String::from(&quot;Rust&quot;)); hello(&amp;(*m)[..]) } 允许使用DerefMut trait来重载可变引用的*运算符； 💡 Deref trait可以将可变引用可以转换为另一种类型不可变引用；DerefMut trait将可变引用可以转换为另一种类型的可变引用。 常见类型 Box 最简单的智能指针，在堆内存上分配值，栈空间有指向数据的指针。其拥有数据所有权。 Rc 多重所有权的引用计数智能指针Rc(Reference counting)，使得一份数据被多个所有者持有，引用计数为0才清理数据。通过不可变引用只提供对数据的不可变访问。 场景： 堆上数据被多个部分读取（不可变借用），但是编译器无法确定哪个部分最后使用完数据（否则将最后使用的部分设置为值的所有者即可）； 只能用于单线程； Rc::new()用来生成对应类型的引用计数智能指针，使用Rc::clone(&amp;rc)来获取相同值的引用计数智能指针（引用计数+1） enum 和 Rc 示例 use crate::List::{Cons, Nil}; use std::rc::Rc; // List 中元素存活时间至少比 List 的生命周期相同 #[derive(Debug)] enum List { Cons(i32, Rc&lt;List&gt;), Nil, } fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); let b = Cons(3, Rc::clone(&amp;a)); // 复制，增加引用计数 let c = Cons(4, Rc::clone(&amp;a)); // print strong_count println!(&quot;strong_count: {}&quot;, Rc::strong_count(&amp;a)); // 获取强引用计数 println!(&quot;a = {:#?}&quot;, b); println!(&quot;b = {:#?}&quot;, c); } RefCell 用于实现内部数据的可变性，允许你在只持有不可变引用的前提下对数据进行修改。 导入std::cell::RefCell 代表持有数据的唯一所有权，其可变性和借用规则是运行时期检查。 用于单线程环境 智能指针比较： 使用场景：需要在不可变环境中修改自身的数据，将数据使用RefCell&lt;T&gt;包装，可以在运行期获取可变引用来修改数据。用于实现内部可变性。 获取内部值的不可变引用borrow()方法，返回Ref&lt;T&gt;其实现了 Deref 获取内部值的可变引用borrow_mut()方法，返回RefMut&lt;T&gt;其实现了 Deref use std::cell::RefCell struct MockMes{ sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;, } impl MockMes{ fn send(&amp;self, message: &amp;str){ self.sent_messages.borrow_mut().push(String::from(message)); } } Ref&lt;T&gt; ｜RefMut&lt;T&gt;（RefCell方法）访问数据不可变引用和可变引用。 RefCell 会记录这两种指针个数，来维护运行时的借用检查规则，给定时间只允许拥有多个不可变借用或者一个可变借用。 通常会将 Rc 和 RefCell 结合使用，实现一个拥有多重所有权的可变数据。 循环引用 使用 Weak 来避免循环引用，并不分享实例的所有权，当 Strong_Reference 数量为0时，值会被清理。相关函数： 调用Rc::downgrade(&amp;rc)，返回Weak&lt;T&gt;，并且弱引用计数weak_count加1 调用Weak&lt;T&gt;的 upgrade() 方法，返回Option&lt;Rc&lt;T&gt;&gt;（需要保证指向的值仍然存在） ","tags":[{"name":"Rust","slug":"rust","used":true,"link":"https://blog.qxxiao.eu.org/tag/rust/"}],"title":"Rust基础（二）","feature":"https://pic.qxxiao.cn/20220530212851.png","link":"https://blog.qxxiao.eu.org/post/Rust基础（二）/","stats":{"text":"10 min read","time":548000,"words":2186,"minutes":10},"date":"2022-05-30 17:37:00","dateFormat":"2022-05-30","isTop":false},{"content":"hello rust. [TOC] Rust 快速入门，参考 《Rust程序设计语言》简要归纳 Rust 的基础，尽量简约而不失重点，方便查阅。 变量与类型 变量 基础类型 标量类型 复合类型 字符串和切片 经常使用的字符串类型有：&amp;str，String，&amp;String。 str系统类型，具有动态大小，所以不能直接用来声明变量。可以看作是一个字节数组区域，并且符合utf-8字符边界。 String动态大小字符串，可以用来声明(栈)变量指向堆上分配的数据（使用起始地值+长度+容量实现）。&amp;String是其引用类型，借用而不获取所有权。 &amp;str字符串切片，可以用来声明变量，也是一种引用类型，指向一块字符串字节数组。（起始地值+长度实现，没有所有权）。字符串字面量创建的变量默认声明为&amp;str，即引用分配在静态存储区的常量字符串。必须符合utf-8字符的边界。 示例： fn main() { let s = &quot;Hello, world!&quot;; let ss = String::from(&quot;Hello, world!&quot;); println!(&quot;{}&quot;, first_word(s)); println!(&quot;{}&quot;, first_word(&amp;ss)); // &amp;String } fn first_word(s: &amp;str) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[0..i]; } } &amp;s[..] } 函数参数如果是字符串类型，尽量使用&amp;str，更加通用(String类型容易转换为切片，&amp;String 可通过解引用强制转换为 &amp;str，或者使用切片) 字符串切片使用： let s = &quot;hello world&quot;; let s1 = &amp;s[0..5]; // &amp;s[..5] let s2 = &amp;s[6..11];// &amp;s[6..] let s3 = &amp;s[0..11];// &amp;s[..] 其他类型的切片原理类似，例如 整形切片&amp;[i32]等 注：整形切片可以由数组，Vec来构造。 struct 与 enum 自定义类型，封装多个字段。 如果定义 struct 是可变的，其所有的字段都是可变的； 函数中字段初始化简写，如果函数参数与字段名同名，可忽略赋值操作只写字段名； 基于原 struct 的更新语法： struct User{ name: String, active: bool, } let user2 = User{ active = false, // 不同的字段 ..user1 // 其他字段与user1相同 }; tuple struct 类似与元组并且可以结构，其元素没有名称，但是整个类型是具名类型。 struct Point(i32, i32, i32); let origin = Point(0, 0, 0); // unit-like struct没有字段的结构体 struct AlwaysEqual; 定义方法和关联函数 #[derive(Debug)] struct Rectangle { width: i32, height: i32, } impl Rectangle { //构造函数 pub fn new(width: i32, height: i32) -&gt; Self { Rectangle { //同名可以省略 width, height, } } //方法，&amp;self参数 fn erea(&amp;self) -&gt; i32 { self.width * self.height } //关联函数 fn erea2(width: i32, height: i32) -&gt; i32 { width * height } fn drop(mut self) { println!(&quot;drop myself&quot;); } } 使用imple块来定义方法和关联函数，可以有多个块； 如果其中函数第一个参数为&amp;self | &amp;mut self为该类型的方法，self 即为该类型的实例本身；其他方法就是关联方法，使用 structName::funcName() 调用； 枚举类型，含有类型的多个变体，rust 枚举变体可以关联一组不同类型的数据，关联的数据可以通过下面中的match模式匹配来获取: enum IpAddrKind { V4(u32,u32,u32,u32), V6(String), } 标准库枚举Option&lt;T&gt;用来解决空值问题，其2个变体Some&lt;T&gt;, None可以直接使用。 let some_num = Some(5); let absent_num: Option&lt;i32&gt; = None; 函数与控制流 函数使用 fn 声明，使用尾置形式返回类型： fn add(a: i32, b: i32) -&gt; i32{ a+b } 函数只要在模块作用域范围可见就可以使用，不需要先声明后使用。 if/else 条件表达式必须是 bool 类型，不使用小括号。 for/while/loop for i in 0..10{ println!(&quot;{}&quot;, i); } while number &gt; 0 { println!(&quot;{}&quot;, number); number -= 1; } loop { println!(&quot;{}&quot;, number); number -= 1; if number == 0 { break; } } match模式匹配 match类似传统的switch语法，当是支持更多特性。匹配的模式支持字面量、变量或者通配符；支持绑定值的模式，用来提取变量中的值： let some_num = Some(5); let some_num_value = match some_num { Some(i) =&gt; i, None =&gt; 0, }; println!(&quot;some_num_value is {}&quot;, some_num_value); match 匹配必须穷举所有可能模式，可以使用_通配符表示剩余其他值。 if let可以只匹配一种模式： // if let pattern = var if let Some(5)=some_num{ println!(&quot;some_num is 5&quot;); }else{ println!(&quot;other&quot;); } 所有权机制 引用类型，例如 &amp;String 是不拥有所有权的类型/借用类型。 引用类型，可直接调用该类型的方法(语法糖)，类型方法中的第一个参数就是该类型的引用/不可变类型。 常用集合 Vec 大小可变的动态数组，基本用法： let mut v = vec![1, 2, 3, 4, 5]; // let mut mv: Vec&lt;i32&gt; = Vec::new(); let first = &amp;v[0]; // ref println!(&quot;{}&quot;, first); match v.get(2) { Some(x) =&gt; println!(&quot;{}&quot;, x), None =&gt; println!(&quot;None&quot;), } // 遍历 for i in &amp;mut v { *i += 10; } for i in v { println!(&quot;{}&quot;, i); } 由于枚举类型的灵活性-可以附加数据，可以使用 Vec+enum 组合，从而可以存储枚举的不同变体以及不同类型的关联数据； String 字符串String类型底层就是Vec&lt;u8&gt;字节数组，字符串使用 UTF-8 编码，并提供字节-文本解析方法。String 类型来自标准库而非核心语言，可增长，可修改和获得所有权的类型。 💡 在核心语言层面，Rust只有一个字符串类型 str (大小可变的字符串)，通常使用 &str 来表示字符串切片。字符串切片：引用类型，对存储在其它地方的utf-8编码字符串的引用。 常用方法： // 创建String let s = String::from(&quot;hello&quot;); let s = String::new(); let s = &quot;hello&quot;.to_string(); // 添加字符/字符串 s.push_str(&quot;, world!&quot;); s.push('!'); // 拼接字符串 let s3 = s1 + &amp;s2; // fn add(self, s: &amp;str) -&gt; String let s3 = format!(&quot;{}-{}&quot;, &quot;hello&quot;, s); // format! 拼接字符串的+操作，注意获取了s1的所有权/后续失效，参数是&amp;str;解引用强制转换(deref coercion)可以将 &amp;String 转换为 &amp;str 类型。 使用format!宏拼接字符串，不会获取所有权，方便于多个字符串的拼接。 内部表示： String 底部是u8字节数组，使用 UTF-8 编码存储 Unicode 标量值，主要特性： 不支持整形下标索引(保证字符索引安全)； 使用 [..] 创建字符串切片时，也必须符合 utf-8 字符边界，否则出现运行时错误； HashMap 不在 prelude 中，需要显示导入use std::collections::HashMap;创建和使用： // 创建HashMap let mut scores: HashMap&lt;String, i32&gt; = HashMap::new(); scores.insert(String::from(&quot;Blue&quot;), 10); scores.insert(String::from(&quot;Yellow&quot;), 50); println!(&quot;{:#?}&quot;, scores); // collect let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)]; let initial_scores = vec![10, 50]; let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect(); println!(&quot;{:#?}&quot;, scores); let vec = vec![(String::from(&quot;Blue&quot;), 10), (String::from(&quot;Yellow&quot;), 50)]; let scores: HashMap&lt;_, _&gt; = vec.into_iter().collect(); println!(&quot;{:#?}&quot;, scores); 所有权问题： 对于实现了 Copy trait类型例如i32，会复制到 HashMap中；对于拥有所有权的类型会被移动（上述into_iter()方法会移动原来的vec中元素） 如果将引用插入到HashMap中，值不会移动，但是要保证被引用值的有效性； 使用： 常用的操作有：插入键值对、获取key对于的值、遍历以及修改。 // get 获取值 let score = scores.get(&quot;Blue&quot;); match score { Some(score) =&gt; println!(&quot;{}&quot;, score), None =&gt; println!(&quot;No score&quot;), } // 不检查 let score = scores[&quot;Blue&quot;]; // 借用使用 &amp;scores[&quot;Blue&quot;] // 遍历 for (k,v) in &amp;scores{ println!(&quot;{}:{}&quot;, k, v); } 更新操作： 使用insert()如果存在旧值会替换 使用 entry()返回 Option 类型，使用变体的 or_insert() 方法在不存在时插入；如果存在会返回该值的可变引用，通过解引用来更新。 // 添加值，insert方法替换旧值 let words = &quot;hello world wonderful world&quot;; let mut map = HashMap::new(); for word in words.split_whitespace() { let count = map.entry(word).or_insert(0); *count += 1; } 泛型 对于 struct，enum，方法/普通函数都可以定义为泛型： struct Point&lt;T&gt; { x: T, y: T, } impl&lt;T&gt; Point&lt;T&gt; { fn x(&amp;self) -&gt; &amp;T { &amp;self.x } } impl Point&lt;i32&gt; { fn origin() -&gt; Point&lt;i32&gt; { Point { x: 0, y: 0 } } } Rust泛型实现与 C++类型，编译时都会进行具体类型替换-单态化; struct 方法可以定义其他的类型参数，与struct是否为泛型无关; 对泛型struct的某个具体类型，例如Point&lt;i32&gt;定义方法是对该类型添加的，其他类型参数的Point不具有（与C++偏特化/特化不同） 泛型可以扩展代码的通用性，常见类型都定义为泛型，Option&lt;T&gt;, Result&lt;T, E&gt;等 Trait 类似与接口概念，告诉编译器某种类型具有哪些特定行为/功能，用来抽象地定义共享/公共行为。 一个主要作用就是为泛型类型参数进行约束Trait bounds，指定为实现特定行为的类型。 定义与为类型实现Trait： pub trait Summary { fn summarize(&amp;self) -&gt; String; } pub struct Tweet { pub username: String, pub content: String, } // impl impl Summary for Tweet { fn summarize(&amp;self) -&gt; String { format!(&quot;{}: {}&quot;, self.username, self.content) } } Trait可以定义默认实现。 类型实现Trait必须实现 trait 定义的所有没有默认实现的方法，对于有默认实现的，可以选择重写该方法；trait 定义中，(默认)方法可以调用没有默认实现的方法，类型会保证实现这些方法。 类型实现Trait的条件： 类型或者该 Trait 是在本地 crate定义的; 即无法为外部类型实现外部的 trait（孤儿规则） Trait作为参数 使用impl Trait或者Trait bound语法： // impl Trait 修饰参数 pub fn notify(item: impl Summary+Display) { println!(&quot;Breaking news! {}&quot;, item.summarize()); } // 使用泛型 + trait约束 pub fn notify&lt;T: Summary+Display&gt;(item: T) { println!(&quot;Breaking news! {}&quot;, item.summarize()); } // where pub fn notify2&lt;T, U&gt;(a: T, b: U) where T: Summary + Display, U: Clone + Debug, { println!(&quot;Breaking news! {}&quot;, a.summarize()); } Trait作为返回类型 使用impl trait语法： pub fn news() -&gt; impl Summary { Tweet { username: String::from(&quot;ebooks&quot;), content: String::from(&quot;people&quot;), } } 限制： 需要保证函数返回的类型需要一致，返回确定的同一种类型； 💡 Trait 主要用来表示类型约束，其他用法： 在泛型类型的 impl 块上使用 Trait bound，可以为类型参数实现了特定 Trait 的泛型类型有条件地实现某些方法； 为实现特定 Trait 的任意类型有条件地实现另一个 Trait (覆盖实现) 示例代码 // 1. 有条件地实现某些方法 impl&lt;T: Display+PartialOrd&gt; Pair&lt;T&gt;{ fn cmp_display(&amp;self){ ... } } // 2. 有条件实现另一个 Trait impl&lt;T: fmt::Display+?Sized&gt; ToString for T{ ... } 生命周期 生命周期目的：避免悬垂引用 dangling reference. Rust中每个引用都有自己的生命周期（保持有效的作用域），当生命周期以不同的方式互相关联，需要手动标注生命周期，使用泛型声明来规范生命周期的名称。 例如函数签名中使用泛型生命周期参数： 可以理解为返回引用的生命周期至少是x,y中较短的生命周期（交集） fn long_str&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str { if x.len() &gt; y.len() { x } else { y } } 生命周期标注不会实际改变引用的生命周期长度； 只是描述了多个引用的生命周期的关系，不影响其生命周期；因此单个生命周期的标注没有意义； 'static特殊生命周期标识，整个程序的运行时间（例如字符串字面量） 💡 注意：函数返回引用类型，返回类型的生命周期参数需要与一个参数的生命周期匹配（即跟输入参数相关，否则就是悬垂引用） 省略规则 Rust引用分析中考虑了一些特定模式/生命周期省略规则，符合该模式的代码无需显示标注生命周期。（输入生命周期: 参数为引用的生命周期；输出生命周期：返回值是引用的生命周期） 规则如下： 每个输入**参数(引用类型)**如果省略生命周期，则具有不同的生命周期参数（例如'a,'b,'c）； 如果只有一个输入生命周期参数，该生命周期被赋给所有的输出生命周期参数； 如果有多个输入生命周期参数，但是其中有一个是&amp;self，&amp;mut self（适用于方法中），那么 self 的生命周期被赋给所有的输出生命周期参数。 应用上述规则后如果不能确定签名中所有引用的生命周期编译器会报错。或者出现不匹配，例如返回值的生命周期与返回类型生命周期不同（示例见impl块和方法）。 struct struct 定义中字段除了基本类型和自拥有类型，其引用类型需要使用生命周期标注： struct Stu&lt;'a&gt; { name: &amp;'a str, // 至少比Stu实例生命周期长 age: u8, } // main fn main(){ let name = String::from(&quot;xiaoming&quot;); let stu = Stu { name: name.as_str(), age: 18, }; println!(&quot;{:#?}&quot;, stu); } impl块和方法 对于字段的生命周期需要在 imp 块中显示标注： struct Stu&lt;'a&gt; { name: &amp;'a str, age: u8, } // 对于struct 字段的生命周期标注显示指明/语法类似泛型 // 方法中的生命周期参数可以使用字段声明的，也可以自定义 // &amp;self 方法可以有默认规则 impl&lt;'a&gt; Stu&lt;'a&gt; { fn get_age(&amp;self) -&gt; u8 { self.age } fn get_name(&amp;self) -&gt; &amp;str { self.name } //fn get_name2(&amp;self, other: &amp;str) -&gt; &amp;str{ // other // error 引用规则3返回类型的声明周期与 self相同 //} } 阅读 Rust 程序设计语言 - Rust 程序设计语言 简体中文版Rust 程序设计语言 简体中文版 https://kaisery.github.io/trpl-zh-cn/title-page.html Rust 翻译计划( 代号 Rustt ) - Rust语言圣经(Rust Course)https://course.rs/rustt.html Rust Language Cheat Sheethttps://cheats.rs/ rust_cheat_sheet.pdf ","tags":[{"name":"Rust","slug":"rust","used":true,"link":"https://blog.qxxiao.eu.org/tag/rust/"}],"title":"Rust基础（一）","feature":"https://pic.qxxiao.cn/20220530212851.png","link":"https://blog.qxxiao.eu.org/post/Rust基础（一）/","stats":{"text":"16 min read","time":911000,"words":3614,"minutes":16},"date":"2022-05-28 02:59:00","dateFormat":"2022-05-28","isTop":false},{"content":"版本控制 概念： 主副本存储在版本库中 每个版本都是可用的 多开发分支 并行开发 构建工具和自动化 更容易构建意味着更容易测试和修改；更容易测试和修改意味着更快乐的程序和更快乐的程序员。 Makefiles Make的几个重要功能: 默认是第一个目标target 隐式编译规则 例如，将.c文件编译成.o文件。根据惯例，该隐含规则使用变量CFLAGS来定义C编译标志。 变量 CFLAGS=-Wall -g，CC 特殊变量 makeﬁle使用特殊变量$@，这个特殊变量表示 &quot;目标&quot;。特殊变量可以避免不必要的输入，并使规则更容易改变和重复使用。 Example 包含一个main程序和2个lib项目的Makefile: prog.c: The main program ﬁle lib.c: Lib#1 c file lib.h: Lib#1 header file lib_test.c: a set of tests for Library #1 lib2.c: Lib#2 c file lib2.h: Lib#2 header file lib2_test.c: a set of tests for Library #2 tests.h: A header ﬁle for some common test functions tests.c: A library with some useful test routines CC=gcc CFLAGS=-Wall -g LIBS=lib.o lib2.o HEADERS=lib.h lib2.h BINS=prog lib_test lib2_test all: ${BINS} prog: prog.o ${LIBS} ${HEADERS} ${CC} -o $@ ${CFLAGS} prog.o ${LIBS} lib_test: lib.o lib_test.o lib.h tests.o tests.h ${CC} -o $@ ${CFLAGS} lib_test.o lib.o tests.o lib2_test: lib2.o lib2_test.o lib2.h tests.o tests.h ${CC} -o $@ ${CFLAGS} lib2_test.o lib2.o tests.o test: ./lib_test ./lib2_test clean: rm -rf ${BINS} *.o core *.core 工具 代码检查 编译器检查 总是使用gcc -Wall 用**-D_FORTIFY_SOURCE**及早发现错误 用-D_FORTIFY_SOURCE=2编译程序将包括对系统调用（如printf）的缓冲区对齐的额外检查。这些检查决定了你是否向sprintf等函数传递了一个太小的缓冲区。 使用glibc变量及早发现错误 设置环境变量 MALLOC_CHECK_ 来识别 malloc 相关的问题，如果设置为1会记录错误，设置为2会导致立即终止。 调试 调试思维模式 一些有用的调试步骤： 使用堆栈跟踪 检查最近的修改 仔细阅读代码 向别人解释你的代码 让错误可以重现 增加一致性检查，找出你对程序状态的假设出错的地方； 增加调试输出，以显示程序的特定位的状态，或确定程序的哪些部分在崩溃前被到达； 删除可能导致错误/崩溃/等的部分代码，看看它们是否真的有责任； 发现bug后需要思考的是： 是否在代码的其他地方犯了这个错误？由于对接口的误解而产生的bug，很可能会在多个地方出现。做一次快速检查，以主动消除其他bug。 怎样才能避免在将来犯这个错误？你也许可以添加测试用例来自动发现它们，在代码中添加断言来检测该错误是否再次发生，使用编译器警告来自动检测它们，或者改变你写代码的方式，使其不可能犯错。 Printf：调试宏 调试宏可以在程序中增加调试printfs而不用移除。一组好的调试宏可以有选择的启用和关闭不同级别的调试级别。通常指定输出信息的方式有两种：调试级别和指定调试的功能（socket 操作，进程相关）。 debug.h #ifndef _DEBUG_H_ #define _DEBUG_H_ #include &lt;stdio.h&gt; /* for perror */ #include &quot;err.h&quot; #ifdef DEBUG extern unsigned int debug; #define DPRINTF(level, fmt, args...) \\ do { \\ if ((debug) &amp; (level)) fprintf(stderr, fmt, ##args); \\ } while (0) #define DEBUG_PERROR(errmsg) \\ do { \\ if ((debug)&amp;DEBUG_ERRS) perror(errmsg); \\ } while (0) #define DEBUGDO(level, args) \\ do { \\ if ((debug) &amp; (level)) { \\ args; \\ } \\ } while (0) #else #define DPRINTF(args...) #define DEBUG_PERROR(args...) #define DEBUGDO(args...) #endif /* * Debug levels */ #define DEBUG_NONE 0x00 // DBTEXT: No debugging #define DEBUG_ERRS 0x01 // DBTEXT: Verbose error reporting #define DEBUG_INIT 0x02 // DBTEXT: Debug Initialization #define DEBUG_SOCKETS 0x04 // DBTEXT: Debug sockets operations #define DEBUG_PROCESSES 0x08 // DBTEXT: Debug processes operations fork/reap #define DEBUG_ALL 0xffffffff // DBTEXT: All debugging #ifdef __cplusplus extern &quot;C&quot; { #endif int set_debug(char *arg); /* returns 0 on success, -1 on failure */ #ifdef __cplusplus } #endif #endif /* _DEBUG_H_ */ 调试工具 gdb 工作方式： gdb binary 调试二进制程序 gdb binary core 调试崩溃程序的core文件 gdb binary PID 附加到一个正在运行的进程 常见功能： 说明： 没有core文件？ 使用 ulimit -a 查看资源限制，如果 coredumpsize 的值被设置为零，核心转储将被禁用。可以使用：ulimit -c unlimited 启用，非必要时可以使用 ulimit -c 0 禁用。 Linux下core dump文件通常命名为 core/core.PID；Mac下会存储在 /cores 目录。 追踪系统调用 使用系统调用追踪工具 ktrace(BSD)、strace(Linux). strace [args] strace产生的输出列出了每个系统调用、其参数和结果。strace输出对于观察程序崩溃前的最后几个系统调用是非常有用的。 使用Valgrind内存调试 Valgrind是一个动态分析工具（它在你的代码运行时测试你的代码）。它提供的工具可以检查无效或未初始化的内存使用情况，在内存被释放后进行写入，以及内存泄漏。由于它在虚拟机中运行程序，程序在Valgrind下的运行速度要慢10倍左右。Valgrind只在Linux上可用。 valgrind [args] 使用Electric Fence内存调试 调试缓冲区越界的工具。它监控对malloc生成的缓冲区的访问，以检测你的代码是否写过了缓冲区的末端（或开始）。 ef [args] 或者可以使用链接 -lefence 来使用。使用electricfence，试图访问分配内存外的部分将导致程序出现seg故障，而不是引起奇怪的、不可预知的行为。 使用tcpdump/Wireshark追踪网络包 对于网络项目和分布式系统的调试，数据包嗅探器如tcpdump和Wireshark可以说是非常有用的。这些工具可以记录进出机器的数据包，并可以解码各种协议。 tcpdump是一个更低级的原始数据包接口；它很容易从命令行使用，并产生有用的输出； Wireshark能解析更多的协议，有更强大的功能（如重新组合TCP流），并且有一个方便的GUI 测试输出 对输出进行 &quot;比较 &quot;往往是有帮助（例如文件传输，结果比较） 只是传输文本数据 用传统的UNIX命令行工具，如wc、diff和grep，更容易地检查它 使用 cmp 命令工具 可视化工具 http://home.comcast.net/~chris-madsen/vbindiff/ 文档和风格 让代码功能显而易见/明显，不要注释明显的代码，尽量保持干净。 风格 重要的是选择一种风格，并一致地使用它。并且满足： 使代码可读性强 能区分重要的东西，如C++中的类名、变量、全局变量等 命名不要过分冗长和痛苦 统一使用风格比细节要重要得多。也就是说，随着时间的推移，一些约定俗成的东西已经出现了，它们可以极大地帮助使代码更加可读。例如： IsValid()是一个比checkValid()更好的名字，因为其语义更清晰 在介绍函数时要有简短的注释，解释其语义和任何调用者真正需要知道的关于使用它的信息 阅读其他代码 感受编码风格和技巧的一个好方法是阅读一些其他代码。建议阅读BSD源代码中的一些系统实用程序。总的来说，它组织得很好，很一致，而且经得起时间的考验。一些建议： ed 测试代码 很多内核代码很有趣，但很密集 使用脚本 时间是宝贵的，将重复性无意义的工作自动化的最好方法是使用脚本语言，如Perl、Python和Ruby。 单行代码 大多数脚本语言都有对 &quot;单行 &quot;的某种支持，可以完成特定的任务，例如将一组文件中出现的 &quot;foo &quot;改为 &quot;bar&quot;： perl: perl -pi.bak -e &quot;s/foo/bar/g” ruby: ruby -pi.bak -e &quot;gsub(’foo’, ’bar’)” https://wiki.python.org/moin/Powerful Python One-Liners https://www.bashoneliners.com/oneliners/popular/ shell 掌握shell常见功能，通配符，循环，重定向等等。 以及命令行、面向管道的工具，如 &quot;awk &quot;和 &quot;sed&quot;。 程序设计 程序设计有两个关键的方面是需要解决的： 数据结构。该程序对什么数据进行操作？它是如何存储的 模块。程序是如何被划分为各个组件的？这些组件是如何交互的？ 如何将程序中的功能分解成单个的源代码片段，例如： 不要重复自己的工作DRY DRY是决定哪些代码应该被拉入模块的经验法则。如果你发现自己不断重复相同或几乎相同的代码，或者更糟糕的是复制和粘贴它！那么是时候考虑把它分离成一个漂亮、干净的模块，可以在其他地方使用。 隐藏不必要的实现细节 会使以后改变这些细节更容易，而不需要改变所有使用模块的代码。 保持简单! 不要过早地进行优化，不要添加不必要的功能，设计可重用的东西。 为渐进式的快乐而设计 极不可能坐下来，在一次不间断的狂欢中，完成整个工作项目。 相反，在开始编码之前，坐下来思考一下你可以沿途采取的渐进步骤。在开发时，以这些渐进的步骤为目标，这样你就可以把问题分解成小的、可管理的块状。你的目标应该是，一旦你开发了一个特定的 &quot;块&quot;，你就可以相信它此后会继续做它的工作。通过如下方法进行分解： 识别单独的构件（列表、哈希、算法等） 识别 特征/基本本质 可测试性设计 在设计和编码过程中测试的第一个目标是确保一旦你建立了一个特定的组件或模块，你可以依靠这个组件来工作，并保持工作。后来，当你的程序出现错误时，你就可以专注于较新的代码，减少了调试和后期编码的复杂性。 单元测试是测试的最基本元素。它们特别适合于你在前面将代码分解成步骤时确定的那种完善的模块-实用程序、容器等。对于这些模块中的每一个，我们建议写一套专门针对该模块的测试。编写测试用例可以使你更努力地思考你所暴露的接口和你必须实现的行为。 系统测试是对大局的测试，注意，即使在这里，你也可以从项目的开始就开始写有用的测试。 对抗的心态 在设计测试的时候，要把自己放在真正的、真正的试图破解代码的心态上。不要只测试简单的情况，要测试边界情况。 先是简单的测试，然后是复杂的测试。很可能在你第一次尝试简单的测试时，你会发现一些错误。一旦你解决了这些问题，就可以继续进行更复杂的测试，以发现更难解决的问题。 测试自动化 通过这样做，你将更经常地运行它们，将对你更有用。理想情况下，你应该能够类似使用 make test 让你的所有测试运行。 编辑器 了解你的编辑器并对其了如指掌，可以为你节省无数的按键和零星的时间。常见特点： 语法高亮。对运算符、函数调用、注释等进行着色，可以使你更容易扫描代码，找到你要找的东西 标签。一些编辑器和集成开发环境（IDE）提供了单次点击或按键命令，让你快速跳转到声明或实现某个函数的文件中。 自动补全。编辑器提供不同类型的自动完成功能，从括号匹配到函数名称自动完成，等等。 请注意，当调试涉及多个进程或机器或操作系统内核代码时，一些IDE的集成特性在系统编程的背景下可能对你不利。 阅读 https://www.cs.cmu.edu/~dga/systems-se.pdf ","tags":[{"name":"Article","slug":"article","used":true,"link":"https://blog.qxxiao.eu.org/tag/article/"},{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"Software Engineering for Systems Hackers","feature":"","link":"https://blog.qxxiao.eu.org/post/software-engineering-for-systems-hackers/","stats":{"text":"12 min read","time":710000,"words":3145,"minutes":12},"date":"2022-04-30 09:25:28","dateFormat":"2022-04-30","isTop":false},{"content":" 虚函数实现原理 RTTI (run time type identification) 参考 🔖 Reversing C++ Virtual Functions: Part 1There are a few posts in various parts of the internet discussing reverse engineering C++, and these https://alschwalm.com/blog/static/2016/12/17/reversing-c-virtual-functions/ 虚函数实现原理 基本的实现原理可以参考链接，不同编译器实现可以不同。 gcc version 11.2.0 (Homebrew GCC 11.2.0)测试 多重继承并且改写父类中的虚函数 测试代码 #include &lt;iostream&gt; class A1 { public: virtual void a() { std::cout &lt;&lt; &quot;A1::a&quot; &lt;&lt; std::endl; } virtual void b() { std::cout &lt;&lt; &quot;A1::b&quot; &lt;&lt; std::endl; } virtual void c() { std::cout &lt;&lt; &quot;A1::c&quot; &lt;&lt; std::endl; } int a1 = 1; }; class A2 { public: virtual void d() { std::cout &lt;&lt; &quot;A2::d&quot; &lt;&lt; std::endl; } virtual void e() { std::cout &lt;&lt; &quot;A2::e&quot; &lt;&lt; std::endl; } int a2 = 2; }; // A1::a B::b A1::c [[B::f B::g]] // B::d A2::e // ==&gt; // A1::a [B::b] A1::c [B:d B:e] [[B:f B:g]] // thunk:B:d thunk:B:e class B : public A1, public A2 { public: virtual void b() { std::cout &lt;&lt; &quot;B::b&quot; &lt;&lt; std::endl; } virtual void d() { std::cout &lt;&lt; &quot;B::d&quot; &lt;&lt; std::endl; } virtual void e() { std::cout &lt;&lt; &quot;B::e&quot; &lt;&lt; std::endl; } virtual void f() { std::cout &lt;&lt; &quot;B::f&quot; &lt;&lt; std::endl; } virtual void g() { std::cout &lt;&lt; &quot;B::g&quot; &lt;&lt; std::endl; } int b3 = 3; }; int main() { B b; long *pvptr = (long *)&amp;b; long *vptr = (long *)*pvptr; typedef void (*pfunc)(); for (unsigned i = 0; i &lt; 7; ++i) { std::cout &lt;&lt; std::hex &lt;&lt; vptr + i &lt;&lt; &quot; &quot; &lt;&lt; vptr[i] &lt;&lt; std::endl; pfunc pfun = pfunc(vptr[i]); pfun(); } std::cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; std::endl; long *vptr2 = (long *)*(long *)((char *)&amp;b + sizeof(A1)); for (unsigned i = 0; i &lt; 2; ++i) { std::cout &lt;&lt; std::hex &lt;&lt; vptr2 + i &lt;&lt; &quot; &quot; &lt;&lt; vptr2[i] &lt;&lt; std::endl; pfunc pfun = pfunc(vptr2[i]); pfun(); } return 0; } 汇编后，类B的虚函数表结构： vtable for B: .quad 0 .quad typeinfo for B .quad A1::a() .quad B::b() .quad A1::c() .quad B::d() .quad B::e() .quad B::f() .quad B::g() .quad -16 .quad typeinfo for B .quad non-virtual thunk to B::d() .quad non-virtual thunk to B::e() 其中虚函数表中指向的B类 typeinfo 结构： typeinfo for B: .quad vtable for __cxxabiv1::__vmi_class_type_info+16 .quad typeinfo name for B .long 0 .long 2 .quad typeinfo for A1 .quad 2 .quad typeinfo for A2 .quad 4098 在 GCC 实现中： 继承多个有虚函数的父类，派生类就有多个虚表指针，每个虚函数指针都位于基类存储位置中的起始地址(派生类对象中)。所以使用派生类对象向上转型的基类指针可以方便地调用虚函数-找到对应的虚指针。 虚表指针指向的虚函数表大致是连续的，每个虚表指针指向的前一个元素是type_info结构体指针，用于实现RTTI(类名和子类信息)，两个表之间是分隔元素(编译器决定)这里是-16。 第一个虚表指针指向的虚函数表很重要 存储对应基类(第一个基类)的虚函数，如果子类改写第一个基类的虚函数则代替对应的槽位置(代替为改写的虚函数地址)； 此外，改写其他基类的虚函数也会添加在第一个虚表，派生类新添加的虚函数也会添加到第一个虚表中。 其余虚表类似，包含没有被覆盖的虚函数，如果其虚函数被改写了，对应槽位置是一个 thunk 函数，作用是跳转到改写的虚函数地址执行； 想一想为什么这么实现： 可以方便地使用基类的指针来调用虚函数，在派生类被再次继承时，只需要修改它的第一个虚表的内容就作为新的派生类的虚表，实现更加方便。 注意： 存在多个基类时，直接使用派生类指针向上转型时，指针会赋值到该派生对象中该基类的起始地址，因此调用虚函数时，会找到它的虚表指针对应的虚表中的对应位置，如果被override改写会跳转到真实的函数地址实现多态效果。这里的多个虚表指针可以便捷编译器确定在该基类指针下找到对应函数的下标位置(生成虚表时就可以确定)，进而可以调用到实际的函数。 由派生类对象地址向上转型可以确定基类的起始地址，从而可以调用对应的虚函数。如果使用： void* p = &amp;b; // 派生类地址赋值给void* A1* pa = p; // 再赋值给基类指针 这样会使得基类指针指向的位置直接变成派生类的起始地址，如果不是单继承或者第一个基类会出现问题，必须直接使用派生类地址向上转型得到对应基类地址指针。 内存对齐问题 在继承体系中，派生类会保存基类的原始布局(包括大小)；如果在满足每个基类的内存对齐情况下gcc允许紧密布局，例如上述类B占用32个字节。 // A1: vptr:8B + sizeof(a1):4B + padding:4B total:16B // A2: vptr:8B + sizeof(a2):4B + [sizeof(b3)] total:16B // B: total:32B (b3直接和A2中的数据紧密布局) 哪些函数不能定义为虚函数？ 友元函数，它不是类的成员函数 全局函数 静态成员函数，它没有this指针 构造函数，拷贝构造函数以及赋值运算符重载（可以但是一般不建议作为虚函数） 构造函数/析构函数中可以调用虚函数吗？ 💡 不能；构造派生类对象时，首先调用基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。析构派生类对象时，首先析构他的派生类部分，然后按照与构造顺序的逆序析构他的基类部分。 在运行构造函数或者析构函数时，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在调用构造/析构函数时发生了变换，即：视对象的类型为当前构造函数/析构函数所在的类的类类型。由此造成的结果是：在基类构造函数或者析构函数中，会将派生类对象当做基类类型对象对待。 即如果在构造函数或者析构函数中调用虚函数，运行的都将是为构造函数或者析构函数自身类类型定义的虚函数版本。对象的虚函数表地址在对象的构造和析构过程中会随着部分类的构造和析构而发生变化，这一点应该是编译器实现相关的。 RTTI (run time type identification) RTTI，即运行时类型检查，其主要作用： 向下类型转换：将父类指针转换为子类指针 异常处理 数据存储 相关的运算符： typeid: 返回type_info结构体的对象（如果没有虚函数实现多态，返回的是静态类型而不是运行时类型的type_info结构体） dynamic_cast: 向下类型转换，成功返回子类指针，失败返回nullptr（如果没有实现多态，编译器报错） 代码示例 #include &lt;iostream&gt; class Base { public: virtual ~Base() {} }; class Derive : public Base {}; int main() { Base* pBase = new Derive(); std::cout &lt;&lt; typeid(*pBase).name() &lt;&lt; std::endl; Derive* pDerive = nullptr; if ((pDerive = dynamic_cast&lt;Derive*&gt;(pBase)) != nullptr) { std::cout &lt;&lt; &quot;dynamic_cast success&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;dynamic_cast failed&quot; &lt;&lt; std::endl; } return 0; } RTTI的实现原理 虚函数表中vptr[-1]是type_info结构体指针，dynamic_cast也要依据type_info运行，所以使用typeid和dynamic_cast都要有虚函数表，也就是虚函数。 参考 🔖 book.douban.comhttps://book.douban.com/subject/1091086/ 🔖 C++虚函数表深入探索(详细全面)-腾讯云开发者社区-腾讯云 这篇博客可能有一点点长，代码也有一点点多，但是仔细阅读分析完，会对虚函数表有一个深刻的认识。 https://cloud.tencent.com/developer/article/1599283 C++在gcc下的单继承，多继承，虚继承的内存布局_LupinLeo的博客-CSDN博客一览本文目的gcc下不同继承方式的存储模型单继承单继承无重写：单继承重写多重继承多继承无重写：多继承重写：虚继承多重继承无法解决的模型真正的菱形继承尾语本文目的&nbsp; 最近看了《深入探索c++ https://blog.csdn.net/shichao1470/article/details/91563282 ","tags":[{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"C++对象模型-虚函数","feature":"","link":"https://blog.qxxiao.eu.org/post/C++对象模型-虚函数/","stats":{"text":"9 min read","time":540000,"words":2168,"minutes":9},"date":"2022-04-19 20:08:00","dateFormat":"2022-04-19","isTop":false},{"content":"B+ 树 B+ 树是一种多叉排序树，即每个节点通常有多个孩子。一棵 B+ 树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。 结构示例： 定义方式采取和 wikipedia 上保持一致。一颗 b 阶的 B+ 树，其中 b 表示树的每个节点最多可以拥有的子节点个数，特性有： B+ 树的阶或分支因子 b 定义为：内部节点允许的最大的子树节点数量/指针的数量； 内部节点的实际子树节点/指针的数量 m 限制：⌈b2⌉≤m≤b\\lceil \\frac{b}{2} \\rceil \\le m \\le b⌈2b​⌉≤m≤b ；根节点子树节点的数量为：2≤m≤b2 \\le m \\le b2≤m≤b 如果内部节点包含 m 个子树节点/指针，那么该节点包含 m-1 个关键字 key (不同定义此处有差别) 叶子节点都在同一高度上 特别的，当初始只有一个节点时，根节点本身就是叶子节点，其记录的个数：0≤n≤b−10\\le n \\le b-10≤n≤b−1 所有叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接； B+树的查找操作，无论查找成功与否，每次查找操作都是走了一条从根结点到叶子结点的路径。 查找插入删除操作 参考链接：https://zhuanlan.zhihu.com/p/149287061 用途 B+树 主要适用于索引操作。为什么说 B+树 比 B-树 更适合实际应用于操作系统的文件索引和数据库索引？ B+树的内部节点只存储索引信息，而不存储实际数据，因此可以存储更多的索引信息，提高查询效率。 B+树的叶子节点形成一个有序链表，可以方便地进行范围查询和排序操作。 B+树的查询效率更加稳定: 由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 MySQL 中的应用 为了查询更加高效，采用 B+树 作为数据库索引。在 MySQL 中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。我们接下来讨论两个引擎：MyISAM 和 InnoDB 这两种引擎。 MyISAM MyISAM 中有两种索引，分别是主索引和辅助索引，在这里面的主索引使用具有唯一性的键值进行创建，而辅助索引中键值可以是相同的。MyISAM 分别会存在一个索引文件和数据文件，它的主索引是非聚集索引。当我们查询的时候，我们找到叶子节点中保存的地址，然后通过地址我们找到对应的信息。 InnoDB InnoDB 索引和 MyISAM 的最大区别是它只有一个数据文件。在 InnoDB 存储引擎中，表数据文件本身就是按 B+树 组织的一个索引结构，这棵树的叶节点数据保存了完整的数据记录，所以我们把它的主索引叫做聚集索引。而它的辅助索引和 MyISAM 也会有所不同，它的辅助索引都是将主键作为数据域，所以这样当我们查找的时候通过辅助索引先找到主键，然后通过主索引找到对应的主键，从而得到相应的数据信息。 链接 说明：不同的版本在定义上可能有差别。 https://oi-wiki.org/ds/bplus-tree/ https://www.cnblogs.com/nullzx/p/8729425.html https://zhuanlan.zhihu.com/p/149287061 B+树及插入和删除操作详解(注: key数量等于指针数量) C++简单实现 ","tags":[{"name":"Algorithm","slug":"algorithm","used":true,"link":"https://blog.qxxiao.eu.org/tag/algorithm/"},{"name":"MySQL","slug":"mysql","used":true,"link":"https://blog.qxxiao.eu.org/tag/mysql/"}],"title":"B+ 树","feature":"https://pic.qxxiao.cn/algorithm.png","link":"https://blog.qxxiao.eu.org/post/b+tree/","stats":{"text":"5 min read","time":240000,"words":1113,"minutes":5},"date":"2022-04-13 20:25:49","dateFormat":"2022-04-13","isTop":false},{"content":"C++值的类型说明 C++表达式(操作符表达式，字面量，变量名等)都有值类型，通常将值的类型划分为左值和右值： 一个表达式，如果能对它进行取地址运算/确定的内存地址，则它是左值；（包括左值的引用） 否则，它就是右值 C++11后出现了5种值的类型，简单解释： glvalue 广义左值，（运算结果）是具有身份/内存地址的对象/函数的表达式，包括xvalue和lvalue xvalue 即将过期值/亡值，属于glvalue广义左值，表示其资源可以被重复使用/移动的对象 返回类型是右值引用的函数调用，如std::move(x)； a[n]，a.m，a.*mp表达式(其中a是rvalue，m是非引用类型的非静态成员，mp是指针) 转换为对象类型的右值引用的cast表达式，如static_cast&lt;int&amp;&amp;&gt;(x) lvalue 历史上叫法(可以出现在赋值运算符的左边)，属于glvalue但不是xvalue prvalue 纯右值，例如字面量(字符串除外)、算术表达式(a+b, &amp;a, 后置加加等)、临时对象、lamda表达式等。 rvalue 历史叫法(可以出现在赋值运算符的右边)，包括prvalue和xvalue 可以将值大概分为3种： xvalue 广义左值，但是其资源可以重复使用/移动【有身份，可以移动】 lvalue 传统左值，资源不能移动【有身份，不可以移动】 prvalue 传统右值，资源可以移动【没有身份，可以移动】 在C++中右值rvalue的语义就是可移动的。 只需要记住特殊的广义左值xvalue，它是有身份的但是其资源可以移动，常见情形： // 1. 返回右值引用的函数调用 std::move(x); func(); //func的声明：Foo&amp;&amp; func(); // 2. 转换为右值引用的cast static_cast&lt;int&amp;&amp;&gt;(x); // 3. rvalue的成员 std::move(x).m_data; // 非引用类型的非静态成员 func().m_data; //func的声明：Foo&amp;&amp; func(); static_cast&lt;Foo&amp;&amp;&gt;(x).m_data; ","tags":[{"name":"C++","slug":"c","used":true,"link":"https://blog.qxxiao.eu.org/tag/c/"}],"title":"C++值的类型","feature":"https://pic.qxxiao.cn/cpp-logo.png","link":"https://blog.qxxiao.eu.org/post/C++值的类型/","stats":{"text":"2 min read","time":119000,"words":521,"minutes":2},"date":"2022-04-10 23:22:18","dateFormat":"2022-04-10","isTop":false},{"content":"MySQL学习笔记 转载：https://shockerli.net/post/1000-line-mysql-note/ 数据库操作 -- 查看所有数据库 SHOW DATABASES; -- 查看当前数据库 SELECT DATABASE(); -- 切换当前数据库 USE 库名; -- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version(); -- 创建库 CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项; 数据库选项, 字符集和其排序规则： CHARACTER SET charset_name COLLATE collation_name -- 查看已有库 SHOW DATABASES [LIKE 'PATTERN']; -- 查看当前库信息 SHOW CREATE DATABASE 数据库名; -- 修改库的选项信息 ALTER DATABASE 库名 选项信息; -- 删除库 DROP DATABASE [IF EXISTS] 数据库名; 同时删除该数据库相关的目录及其目录内容 表操作 -- 创建表 CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [库名.]表名 (表的结构定义)[表选项]; 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string'] -- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory CSV Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES /* 显示存储引擎的状态信息 */ SHOW ENGINE 引擎名 {LOGS|STATUS} /* 显示存储引擎的日志或状态信息 */ -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = '目录' -- 索引文件目录 INDEX DIRECTORY = '目录' -- 表注释 COMMENT = 'string' -- 分区选项 PARTITION BY ... (详细见手册) -- 查看所有表 SHOW TABLES [LIKE 'pattern']; SHOW TABLES FROM 库名; -- 查看表结构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN'] SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern'] -- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项; eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名, RENAME TABLE table1 TO temp_name, table2 TO table1, temp_name TO table2; -- 修改表的字段结构（ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP [COLUMN] 字段名 -- 删除字段 MODIFY [COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE [COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键 -- 删除表 DROP TABLE [IF EXISTS] 表名 ... -- 清空表数据(不能回滚) TRUNCATE [TABLE] 表名 -- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名; -- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名; -- 检查表是否有错误 CHECK TABLE 表名 [, 表名] ... [option] ... -- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... -- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM] -- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作 -- 增 INSERT INTO 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ -- REPLACE 与 INSERT 完全一样，可互换 INSERT INTO 表名 SET 字段名=值[, 字段名=值, ...] -- 查 SELECT 字段列表 FROM 表名 [其他子句]; -- 可来自多个表的多个字段 -- 字段列表可以用*代替，表示所有字段 -- 子句 -- WHERE 过滤条件 -- ORDER BY 排序, ASC升序, DESC降序 -- LIMIT 限制结果集的数量 -- GROUP BY 分组, 可用于聚合函数; HAVING 对分组过滤 -- DISTINCT 去重 -- 内连接（INNER JOIN）/左连接（LEFT JOIN）/右连接（RIGHT JOIN）/通过 UION 联合实现全连接 -- 笛卡尔积 JOIN（不加条件） -- 删 DELETE FROM 表名 [删除条件子句] 没有条件子句，则会删除全部 -- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码 MySQL 的数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 SHOW VARIABLES LIKE 'character_set_%'; -- 查看所有字符集编码项 character_set_client 客户端发送数据时所用的字符集 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 服务器处理这些数据时所用的字符集（服务器在将接收到的数据从客户端转换为内部表示时所使用的字符集） character_set_server 服务器使用的默认字符集 SET 变量名 = 变量值; SET character_set_client = utf8mb4; SET character_set_results = utf8mb4; SET character_set_connection = utf8mb4; SET NAMES utf8mb4; -- 相当于完成以上三个设置 -- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']; 查看所有字符集 SHOW COLLATION [LIKE 'pattern'] /* 查看所有校对集 */ CHARSET 字符集编码; /* 设置字符集编码 */ COLLATE 校对集编码; /* 设置校对集编码 */ 数据类型（列类型） 1. 数值类型 -- a. 整型 类型 字节 范围（有符号位） 无符号 tinyint 1字节 -128 ~ 127 0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 -2147483648 ~ 2147483647 bigint 8字节 int(M) M表示输出显示的总位数 - 默认存在符号位，unsigned 属性修改无符号 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数'123'，补填后为'00123' - 在满足要求的情况下，越小越好 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 -- b. 浮点型 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定显示总位数和小数位数。 float(M, D) double(M, D) M表示输出显示总位数，D表示输出显示小数位数。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 -- c. 定点数 decimal -- 可变长度 decimal(M, D) M也表示总位数，最大值为 65；D表示小数位数，最大值为 30。 eg. DECIMAL(10, 2)，则表示这个字段可以存储最多 10 位数字，其中 2 位是小数位。 保存一个精确的数值，将浮点数转换为字符串来保存，每9位数字保存为4个字节。 2. 字符串类型 -- a. char, varchar ---------- char(M) 定长字符串，速度快，但浪费空间 varchar(M) 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。（记录最大长度以及编码相关） 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 -- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 -- c. binary, varbinary ---------- 用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 3. 日期时间类型 一般用整型保存时间戳 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime YYYY-MM-DD hh:mm:ss timestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmss date YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDD time hh:mm:ss hhmmss hhmmss year YYYY YY YYYY YY 4. 枚举和集合 -- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set('男', '女', '无') ); insert into tab values ('男, 女'); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 -- 类型选择 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 列属性 /*列属性（列约束）*/ ------------------ 1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, 'val'); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, 'val'); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. COMMENT 注释 例：create table tab ( id int ) comment '注释内容'; 7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 /*建表规范*/ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 /*SELECT*/ ------------------ SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT a. select_expr -- 可以用 *表示所有字段。 select* from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT *FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT* FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT *FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT* FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3; c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。 g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 /*UNION*/ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 /*子查询*/ ------------------ - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select *from (select* from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select *from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select* from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 /*连接查询(join)*/ ------------------ 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; /*导入导出*/ ------------------ select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by '\\t' enclosed by '' escaped by '\\\\' terminated by 'string' -- 终止 enclosed by 'char' -- 包裹 escaped by 'char' -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE '/tmp/result.text' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '&quot;' LINES TERMINATED BY '\\n' FROM test_table; lines 控制行格式 默认：lines terminated by '\\n' terminated by 'string' -- 终止 /*INSERT*/ ------------------ select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …; /*DELETE*/ ------------------ DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除。where 指定删除的最多记录数。limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 /*TRUNCATE*/ ------------------ TRUNCATE [TABLE] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 /*备份与还原*/ ------------------ /*视图*/ ------------------ 什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 /*事务(transaction)*/ ------------------ 事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。 -- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 -- 事务提交 COMMIT; -- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 -- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 -- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 -- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。 -- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套 -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 -- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) /*锁表*/ 表锁定只用于防止其它客户端进行不正当地读取和写入 MyISAM 支持表锁，InnoDB 支持行锁 -- 锁定 LOCK TABLES tbl_name [AS alias] -- 解锁 UNLOCK TABLES /*触发器*/ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。 -- 创建触发器 CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构 -- 删除 DROP TRIGGER [schema_name.]trigger_name 可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new. -- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。 -- 字符连接函数 concat(str1,str2,...]) concat_ws(separator,str1,str2,...) -- 分支语句 if 条件 then 执行语句 elseif 条件 then 执行语句 else 执行语句 end if; -- 修改最外层语句结束符 delimiter 自定义结束符号 SQL语句 自定义结束符号 delimiter ; -- 修改回原来的分号 -- 语句块包裹 begin 语句块 end -- 特殊的执行 1. 只要添加记录，就会触发程序。 2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update 3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert /*SQL编程*/ ------------------ --// 局部变量 ---------- -- 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 -- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量） --// 全局变量 ---------- -- 定义、赋值 set 语句可以定义并为变量赋值。 set @var = value; 也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。 还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。 select @var:=20; select @v1:=id, @v2=name from t1 limit 1; select * from tbl_name where @var:=30; select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb; -- 自定义变量名 为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。 @var=10; - 变量被定义后，在整个会话周期都有效（登录到退出） --// 控制结构 ---------- -- if语句 if search_condition then statement_list [elseif search_condition then statement_list] ... [else statement_list] end if; -- case语句 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END -- while循环 [begin_label:] while search_condition do statement_list end while [end_label]; - 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 --// 内置函数 ---------- -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分 time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分 date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); --// 存储函数，自定义函数 ---------- -- 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。 -- 删除 DROP FUNCTION [IF EXISTS] function_name; -- 查看 SHOW FUNCTION STATUS LIKE 'partten' SHOW CREATE FUNCTION function_name; -- 修改 ALTER FUNCTION function_name 函数选项 --// 存储过程，自定义功能 ---------- -- 定义 存储存储过程 是一段代码（过程），存储在数据库中的sql组成。 一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。 而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。 -- 创建 CREATE PROCEDURE sp_name (参数列表) 过程体 参数列表：不同于函数的参数列表，需要指明参数类型 IN，表示输入型 OUT，表示输出型 INOUT，表示混合型 注意，没有返回值。 /*存储过程*/ ------------------ 存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。 调用：CALL 过程名 -- 注意 - 没有返回值。 - 只能单独调用，不可夹杂在其他语句中 -- 参数 IN|OUT|INOUT 参数名 数据类型 IN 输入：在调用过程中，将数据输入到过程体内部的参数 OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端 INOUT 输入输出：既可输入，也可输出 -- 语法 CREATE PROCEDURE 过程名 (参数列表) BEGIN 过程体 END /*用户和权限管理*/ ------------------ -- root密码重置 1. 停止MySQL服务 2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables 3. use mysql; 4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;; 5. FLUSH PRIVILEGES; 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES; -- 增加用户 CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 -- 删除用户 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.*TO 'pms'@'%' IDENTIFIED BY 'pms0817'; -- 查看权限 SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 -- 权限层级 -- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。 全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON*.*和 REVOKE ALL ON*.*只授予和撤销全局权限。 数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。 表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。 列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 /*表维护*/ -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... /*杂项*/ ------------------ 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /*注释内容*/ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\' 5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 7. 清除已有语句：\\c 备份与还原 备份：将数据的表结构和表内数据保存起来，利用 mysqldump 命令完成。 -- 导出 mysqldump [options] db_name [tables] mysqldump [options] ---database DB1 [DB2 DB3...] mysqldump [options] --all--database 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql) 5. 只导出数据库的结构，不包含数据(-d/--no-data) mysqldump -u用户名 -p密码 -d --add-drop-table 库名 &gt; 文件名 可以-w携带WHERE条件，例如: mysqldump -u用户名 -p密码 -w='age &gt; 30' 库名 表名 &gt; backup.sql -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 ","tags":[{"name":"MySQL","slug":"mysql","used":true,"link":"https://blog.qxxiao.eu.org/tag/mysql/"}],"title":"MySQL笔记","feature":"","link":"https://blog.qxxiao.eu.org/post/mysql-notes/","stats":{"text":"41 min read","time":2410000,"words":10287,"minutes":41},"date":"2022-03-10 00:47:45","dateFormat":"2022-03-10","isTop":false},{"content":"Markdown测试 1. 排版 粗体文本 斜体文本 这是一段错误的文本 高亮 行内代码 引用： This is a block with tow paragraphs. This is first paragraph. 无序列表*/+/-： 支持Vim 支持Emacs 其他 vscode atom 有序列表： 项目1 项目2 子项目1 子项目2 任务清单 一项任务(使用 - [ ] ) 一项完成的任务（使用 - [x] ) 各级标题： # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 2. 图片与链接 图片: 链接： 主页的链接 锚点/内部链接： 标题1. 排版 参考链接：(一个链接多次使用) (这里不支持) 文中写法[链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 &quot;链接标题&quot;。 This is [a link to Google][1] by using reference link. [1]:https://www.google.com &quot;Google&quot; 3. 代码高亮 示例： #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; return 0; } class Employee: empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 4. Markdown 扩展 表格 可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐 Item Value Qty Computer $1600 5 Phone $12 12 Pipe $1 234 html标签 &lt;font color=&quot;red&quot;&gt;这是一段文字。&lt;/font&gt; &lt;span style=&quot;background-color: skyblue&quot;&gt;这是一段文字。&lt;/span&gt; &lt;img src=&quot;https://pic.qxxiao.cn/itab.jpeg&quot; width=&quot;50px&quot; /&gt; &lt;!-- 表格 --&gt; &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是一段文字。 这是一段文字。 值班人员 星期一 星期二 星期三 李强 张明 王平 脚注 Leetcode[1]创建一个脚注。 使用^n自动增加数字。例如这里[2]创建一个脚注。 公式 使用Katex渲染 行内公式： E=mc2E=mc^2E=mc2 块公式： f(x1,xx,…,xn)=x12+x22+⋯+xn2f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 f(x1​,xx​,…,xn​)=x12​+x22​+⋯+xn2​ ∑k=0j−1γ^kjzk\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k} k=0∑j−1​γ​kj​zk​ V1×V2=∣ijk∂X∂u∂Y∂u0∂X∂v∂Y∂v0∣\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\ \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\ \\end{vmatrix} V1​×V2​=∣∣∣∣∣∣​i∂u∂X​∂v∂X​​j∂u∂Y​∂v∂Y​​k00​∣∣∣∣∣∣​ or: M(e1)∗M(e2)=M(e1)⋅[V(e220)V(e221)⋯V(e22w−1)]=[V(e1e220)V(e1e221)⋯V(e1e22w−1)]=M(e1e2)\\begin{aligned} M(e_1)*M(e_2) &amp;= M(e_1) \\cdot \\begin{bmatrix} V(e_22^0) &amp; V(e_22^1) &amp; \\cdots &amp; V(e_22^{w-1}) \\end{bmatrix} \\\\ &amp;= \\begin{bmatrix} V(e_1e_22^0) &amp; V(e_1e_22^1) &amp; \\cdots &amp; V(e_1e_22^{w-1}) \\end{bmatrix} \\\\ &amp;= M(e_1e_2) \\end{aligned}M(e1​)∗M(e2​)​=M(e1​)⋅[V(e2​20)​V(e2​21)​⋯​V(e2​2w−1)​]=[V(e1​e2​20)​V(e1​e2​21)​⋯​V(e1​e2​2w−1)​]=M(e1​e2​)​ 其他 水平线 (不支持，使用html标签) 下划线 &lt;u&gt;abcdef&lt;/u&gt; This is a underline sentence. 下划线 &lt;span style=&quot;border-bottom: 2px solid red;&quot;&gt;梯度场必是无旋场&lt;/span&gt; 梯度场必是无旋场 表情符号: :simle (不支持) :simle YAML Front Matter 可以编辑页面元数据 --- title: 'Markdown主题测试' date: 2022-04-12 tags: [markdown] published: true hideInList: false feature: isTop: false --- Markdown测试 &lt;!-- more --&gt; Table of Contents(TOC) 这里需要使用 @[TOC] 来生成 1. 排版 2. 图片与链接 3. 代码高亮 4. Markdown 扩展 表格 html标签 脚注 公式 其他 Leetcode是一个刷题网站。 ↩︎ hello world...... ↩︎ ","tags":[{"name":"Markdown","slug":"markdown","used":true,"link":"https://blog.qxxiao.eu.org/tag/markdown/"}],"title":"Markdown主题测试","feature":"","link":"https://blog.qxxiao.eu.org/post/markdown-test/","stats":{"text":"5 min read","time":269000,"words":903,"minutes":5},"date":"2022-01-06 23:22:18","dateFormat":"2022-01-06","isTop":false},{"content":"基于 Gridea 的 Rocky 主题使用记录，修改了部分样式，主要变更可以查看更新日志。部分参考引用博客参考，向这些作者表示感谢。 最近的更新：查看更新日志 header 修改 移动 RSS 到 footer 修改templates\\includes\\header.ejs，删除 RSS 内容 &lt;a href=&quot;&lt;%= themeConfig.domain %&gt;/atom.xml&quot; target=&quot;_blank&quot; class=&quot;py-2 md:py-1 px-4 mx-4 inline-flex transition font-semibold rounded dark:hover:bg-gray-600 hover:bg-gray-200&quot; &gt; RSS &lt;/a&gt; 将链接部分放置到 footer 中即可 添加友链页面 在config.json中加入 { ​ &quot;name&quot;: &quot;friends&quot;, ​ &quot;label&quot;: &quot;友链&quot;, ​ &quot;group&quot;: &quot;友链&quot;, ​ &quot;type&quot;: &quot;array&quot;, ​ &quot;value&quot;: [], ​ &quot;arrayItems&quot;: [ ​ { ​ &quot;label&quot;: &quot;名称&quot;, ​ &quot;name&quot;: &quot;siteName&quot;, ​ &quot;type&quot;: &quot;input&quot;, ​ &quot;value&quot;: &quot;&quot; ​ }, ​ { ​ &quot;label&quot;: &quot;链接&quot;, ​ &quot;name&quot;: &quot;siteLink&quot;, ​ &quot;type&quot;: &quot;input&quot;, ​ &quot;value&quot;: &quot;&quot; ​ }, ​ { ​ &quot;label&quot;: &quot;Logo&quot;, ​ &quot;name&quot;: &quot;siteLogo&quot;, ​ &quot;type&quot;: &quot;input&quot;, ​ &quot;value&quot;: &quot;&quot; ​ }, ​ { ​ &quot;label&quot;: &quot;描述&quot;, ​ &quot;name&quot;: &quot;siteDesc&quot;, ​ &quot;type&quot;: &quot;input&quot;, ​ &quot;value&quot;: &quot;&quot; ​ } ​ ], ​ &quot;note&quot;: &quot;&quot; } 然后在在 templates 文件夹中新建friends.ejs: &lt;html lang=&quot;en&quot;&gt; ​ &lt;head&gt; ​ &lt;%- include('./includes/head', { siteTitle: themeConfig.siteName }) %&gt; &lt;meta name=&quot;description&quot; content=&quot;&lt;%- themeConfig.siteDescription %&gt;&quot; /&gt; ​ &lt;!--&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= site.themeConfig.domain %&gt;/media/css/friends.css&quot;&gt;--&gt; ​ &lt;/head&gt; ​ &lt;body&gt; &lt;div class=&quot;antialiased flex flex-col min-h-screen&quot; id=&quot;app&quot;&gt; ​ &lt;%- include('./includes/header') %&gt; &lt;div class=&quot;max-w-4xl w-full mx-auto pt-32&quot;&gt; &lt;div class=&quot;bg-white dark:bg-gray-600 shadow-box rounded-lg text-gray-700 dark:text-gray-200&quot;&gt; &lt;div style=&quot;padding-left: 20px&quot;&gt; ​ &lt;br /&gt; &lt;p&gt;需要添加友链可在下方留言&lt;/p&gt; ​ &lt;br /&gt; ​ &lt;strong&gt;格式:&lt;/strong&gt; ​ &lt;br /&gt; ​ &lt;ul&gt; ​ &lt;li style=&quot;padding-left: 2rem&quot;&gt; ​ &lt;b&gt;网站名称&lt;/b&gt; ​ : eg. Nuo's Blog ​ &lt;/li&gt; ​ &lt;li style=&quot;padding-left: 2rem&quot;&gt; ​ &lt;b&gt;网站链接&lt;/b&gt; ​ : eg. https://qxxiao.cn ​ &lt;/li&gt; ​ &lt;li style=&quot;padding-left: 2rem&quot;&gt; ​ &lt;b&gt;头像链接&lt;/b&gt; ​ : eg. https://pic.qxxiao.cn/avatar.png ​ &lt;/li&gt; ​ &lt;li style=&quot;padding-left: 2rem&quot;&gt; ​ &lt;b&gt;网站描述&lt;/b&gt; ​ : eg. 温故而知新 ​ &lt;span style=&quot;color: #ff6b81&quot;&gt;console.log(😊);&lt;/span&gt; ​ &lt;/li&gt; ​ &lt;/ul&gt; ​ &lt;br /&gt; ​ &lt;/div&gt; ​ &lt;/div&gt; &lt;div class=&quot;friendbox&quot;&gt; ​ &lt;% if (site.customConfig.friends) { %&gt; &lt;% site.customConfig.friends.forEach(function(friend) { %&gt; &lt;div class=&quot;friend-box friendblock&quot;&gt; ​ &lt;img src=&quot;&lt;%= friend.siteLogo %&gt;&quot; class=&quot;friend-avatar&quot; /&gt; &lt;div class=&quot;flink-info&quot;&gt; ​ &lt;a href=&quot;&lt;%= friend.siteLink %&gt;&quot; target=&quot;_blank&quot;&gt;&lt;%= friend.siteName %&gt;&lt;/a&gt; ​ &lt;br /&gt; ​ &lt;%= friend.siteDesc %&gt; ​ &lt;/div&gt; ​ &lt;/div&gt; ​ &lt;% }); %&gt; &lt;% } %&gt; ​ &lt;/div&gt; ​ &lt;% if (typeof commentSetting !== 'undefined' &amp;&amp; commentSetting.showComment) { %&gt; &lt;% if ​ (commentSetting.commentPlatform === 'gitalk') { %&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; ​ &lt;% } %&gt; &lt;% if (commentSetting.commentPlatform === 'disqus') { %&gt; &lt;%- include('./includes/disqus') %&gt; &lt;% ​ } %&gt; &lt;% } %&gt; &lt;% if (site.customConfig.openValine) { %&gt; &lt;div id=&quot;vlaine-comment&quot;&gt;&lt;/div&gt; ​ &lt;% } %&gt; &lt;% if(site.customConfig.openTwikoo) { %&gt; &lt;div id=&quot;tcomment&quot;&gt;&lt;/div&gt; ​ &lt;% } %&gt; &lt;%- include('./includes/footer') %&gt; ​ &lt;/div&gt; ​ &lt;/div&gt; ​ &lt;% if (site.customConfig.openValine) { %&gt; &lt;%- include('./includes/valine') %&gt; &lt;% } %&gt; &lt;% if (typeof ​ commentSetting !== 'undefined' &amp;&amp; commentSetting.showComment) { %&gt; &lt;% if (commentSetting.commentPlatform === ​ 'gitalk') { %&gt; &lt;%- include('./includes/gitalk') %&gt; &lt;% } %&gt; &lt;% } %&gt; &lt;% if(site.customConfig.openTwikoo) { %&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/twikoo@1.2.0/dist/twikoo.all.min.js&quot;&gt;&lt;/script&gt; ​ &lt;link rel=&quot;stylesheet&quot; ​ href=&quot;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css&quot; ​ integrity=&quot;sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X&quot; ​ crossorigin=&quot;anonymous&quot; ​ /&gt; ​ &lt;script ​ defer ​ src=&quot;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js&quot; ​ integrity=&quot;sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4&quot; ​ crossorigin=&quot;anonymous&quot; ​ &gt;&lt;/script&gt; ​ &lt;script ​ defer ​ src=&quot;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js&quot; ​ integrity=&quot;sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa&quot; ​ crossorigin=&quot;anonymous&quot; ​ &gt;&lt;/script&gt; &lt;script&gt; ​ twikoo.init({ ​ envId: '&lt;%= site.customConfig.envId %&gt;', ​ el: '#tcomment', ​ katex: { ​ delimiters: [ ​ { left: '$$', right: '$$', display: true }, ​ { left: '$', right: '$', display: false }, ​ { left: '\\(', right: '\\)', display: false }, ​ { left: '\\[', right: '\\]', display: true }, ​ ], ​ throwOnError: false, ​ }, ​ }); ​ &lt;/script&gt; ​ &lt;% } %&gt; ​ &lt;/body&gt; &lt;/html&gt; 相关的css: @media screen and (min-width: 780px) { ​ .friendbox { ​ border-radius: 0.5rem; ​ margin: 20px 0px 50px 0px; ​ padding: 0px 55px 0px 55px; ​ } } @media (prefers-color-scheme: dark) { ​ .friendbox { ​ background-color: #444444; ​ } } .friend-box { ​ display: flex; ​ flex-direction: row; ​ justify-content: center; ​ width: 350px; ​ background-color: #faf9f7; ​ border: 1px solid rgba(0, 0, 0, 0.125); ​ border-radius: 0.25rem; ​ box-shadow: 0 6px 14px 0 rgb(0 0 0 / 4%); ​ margin: 10px 20px 10px 20px; } @media (prefers-color-scheme: dark) { ​ .friend-box { ​ background-color: #333333; ​ } } .friendblock { ​ display: inline-block; } .friend-box img.friend-avatar { ​ width: 70px; ​ height: 70px; ​ border-radius: 50%; ​ float: left; ​ margin: 15px; } .friend-box .flink-info { ​ height: auto; ​ overflow: hidden; ​ line-height: 25px; ​ margin: 20px; } 代码样式 增加行号显示，代码语言显示，复制选项；在post.ejs中添加对应文件： &lt;% if (site.customConfig.codeHighlight) { %&gt; ​ &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= site.themeConfig.domain %&gt;/media/css/prism&lt;%= `-${site.customConfig.hightlightTheme || 'atom-dark'}` %&gt;.css&quot; /&gt; ​ &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/line-numbers/prism-line-numbers.min.css&quot; rel=&quot;stylesheet&quot; /&gt; ​ &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/toolbar/prism-toolbar.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;% } %&gt; &lt;!-- Code Highlight --&gt; &lt;% if (site.customConfig.codeHighlight) { %&gt; &lt;script src=&quot;&lt;%= site.themeConfig.domain %&gt;/media/prism.js&quot;&gt;&lt;/script&gt; &lt;script&gt; ​ Prism.highlightAll() ​ &lt;/script&gt; &lt;script defer src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/line-numbers/prism-line-numbers.min.js&quot; &gt;&lt;/script&gt; &lt;script defer src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/toolbar/prism-toolbar.min.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/show-language/prism-show-language.min.js&quot; &gt;&lt;/script&gt; &lt;script defer src=&quot;https://cdn.bootcdn.net/ajax/libs/prism/1.19.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js&quot; &gt;&lt;/script&gt; &lt;% } %&gt; 在最后添加 &lt;!-- line number for code block --&gt; &lt;script&gt; var pres = document.getElementsByTagName(&quot;pre&quot;); for(var i = 0; i &lt; pres.length; i++){ ​ var pre = pres[i]; ​ if(pre.childNodes[0].nodeName == &quot;CODE&quot;){ ​ pre.setAttribute(&quot;class&quot;,&quot;line-numbers&quot;); ​ } } &lt;/script&gt; 参考 https://vlieo.com/tag/sx7g1O9Qg/ https://yyl125.top/ ","tags":[{"name":"Gridea","slug":"gridea","used":true,"link":"https://blog.qxxiao.eu.org/tag/gridea/"}],"title":"Rocky主题记录","feature":"https://pic.qxxiao.cn/20220412223634.png","link":"https://blog.qxxiao.eu.org/post/rocky-theme/","stats":{"text":"9 min read","time":514000,"words":1458,"minutes":9},"date":"2022-01-05 20:11:19","dateFormat":"2022-01-05","isTop":false},{"content":"矩阵的数量乘法 cA=c[a11a12a21a22]=[ca11ca12ca21ca22]cA = c\\left[\\begin{array}{lll} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{array}\\right]=\\left[\\begin{array}{lll} c a_{11} &amp; c a_{12} \\\\ c a_{21} &amp; c a_{22} \\end{array}\\right] cA=c[a11​a21​​a12​a22​​]=[ca11​ca21​​ca12​ca22​​] 矩阵与矩阵的乘法 举例的矩阵 A 和矩阵 B 的乘法运算： 左边矩阵的列数要和右边矩阵的行数相等 左边矩阵的行数决定了结果矩阵的行数；右边矩阵的列数决定了结果矩阵的列数 [a11a12a21a22a31a32]×[b11b12b13b21b22b23]=[a11b11+a12b21a11b12+a12b22a11b13+a12b23a21b11+a22b21a21b12+a22b22a21b13+a22b23a31b11+a32b21a31b12+a32b22a31b13+a32b23]\\begin{aligned} &amp;{\\left[\\begin{array}{ll} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\\\ a_{31} &amp; a_{32} \\end{array}\\right] \\times\\left[\\begin{array}{lll} b_{11} &amp; b_{12} &amp; b_{13} \\\\ b_{21} &amp; b_{22} &amp; b_{23} \\end{array}\\right]} \\\\ =&amp;\\left[\\begin{array}{lll} a_{11} b_{11}+a_{12} b_{21} &amp; a_{11} b_{12}+a_{12} b_{22} &amp; a_{11} b_{13}+a_{12} b_{23} \\\\ a_{21} b_{11}+a_{22} b_{21} &amp; a_{21} b_{12}+a_{22} b_{22} &amp; a_{21} b_{13}+a_{22} b_{23} \\\\ a_{31} b_{11}+a_{32} b_{21} &amp; a_{31} b_{12}+a_{32} b_{22} &amp; a_{31} b_{13}+a_{32} b_{23} \\end{array}\\right] \\end{aligned} =​⎣⎡​a11​a21​a31​​a12​a22​a32​​⎦⎤​×[b11​b21​​b12​b22​​b13​b23​​]⎣⎡​a11​b11​+a12​b21​a21​b11​+a22​b21​a31​b11​+a32​b21​​a11​b12​+a12​b22​a21​b12​+a22​b22​a31​b12​+a32​b22​​a11​b13​+a12​b23​a21​b13​+a22​b23​a31​b13​+a32​b23​​⎦⎤​​ 矩阵乘以向量的本质 矩阵与向量的乘法，一般而言写作矩阵 AAA 在左，列向量 xxx 在右的 AxAxAx 的形式，便于描述向量 xxx 的位置在矩阵 AAA 的作用下进行变换的过程。 [a11a12a21a22a31a32][x11x21]=[a11x11+a12x21a21x11+a22x21a31x11+a32x21]\\left[\\begin{array}{ll} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\\\ a_{31} &amp; a_{32} \\end{array}\\right]\\left[\\begin{array}{l} x_{11} \\\\ x_{21} \\end{array}\\right]=\\left[\\begin{array}{l} a_{11} x_{11}+a_{12} x_{21} \\\\ a_{21} x_{11}+a_{22} x_{21} \\\\ a_{31} x_{11}+a_{32} x_{21} \\end{array}\\right] ⎣⎡​a11​a21​a31​​a12​a22​a32​​⎦⎤​[x11​x21​​]=⎣⎡​a11​x11​+a12​x21​a21​x11​+a22​x21​a31​x11​+a32​x21​​⎦⎤​ 例子： [123456][45]=[1×4+2×53×4+4×55×4+6×5]=[143250]\\left[\\begin{array}{ll} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{array}\\right]\\left[\\begin{array}{l} 4 \\\\ 5 \\end{array}\\right]=\\left[\\begin{array}{l} 1 \\times 4+2 \\times 5 \\\\ 3 \\times 4+4 \\times 5 \\\\ 5 \\times 4+6 \\times 5 \\end{array}\\right]=\\left[\\begin{array}{l} 14 \\\\ 32 \\\\ 50 \\end{array}\\right] ⎣⎡​135​246​⎦⎤​[45​]=⎣⎡​1×4+2×53×4+4×55×4+6×5​⎦⎤​=⎣⎡​143250​⎦⎤​ 原始坐标/向量 (4,5)(4,5)(4,5) 经过矩阵的乘法转换，变换为 3 维坐标/向量 (14,32,50)(14,32,50)(14,32,50) 在特定矩阵的乘法作用下，原空间中的向量坐标，被映射到了目标空间中的新坐标，向量的空间位置(以及所在空间维数）发生了转化。 行角度 从行角度看矩阵 AAA 与列向量 xxx 的乘法，例如：Ax=[abcd][x1x2]=[ax1+bx2cx1+dx2]A x=\\left[\\begin{array}{ll}a &amp; b \\\\ c &amp; d\\end{array}\\right]\\left[\\begin{array}{l}x_1 \\\\ x_2\\end{array}\\right]=\\left[\\begin{array}{l}a x_1+b x_2 \\\\ c x_1+d x_2\\end{array}\\right]Ax=[ac​bd​][x1​x2​​]=[ax1​+bx2​cx1​+dx2​​] 按照乘法的定义，结果列向量的每一元素都是矩阵的行向量点乘该列向量： Ax=[row⁡1row⁡2]x=[row⁡1⋅xrow⁡2⋅x]A x=\\left[\\begin{array}{l}\\operatorname{row}_1 \\\\ \\operatorname{row}_2\\end{array}\\right] x=\\left[\\begin{array}{l}\\operatorname{row}_1 \\cdot x \\\\ \\operatorname{row}_2 \\cdot x\\end{array}\\right]Ax=[row1​row2​​]x=[row1​⋅xrow2​⋅x​] 列角度 矩阵 AAA 与向量 xxx 的乘法，可以看作是对矩阵 AAA 列向量进行线性组合的过程。 将 AAA 写作一组列变量形式计算： Ax=[col⁡1col⁡2…col⁡n][x1x2…xn]=x1col⁡1+x2col⁡2+…+xncol⁡nA x=\\left[\\begin{array}{llll} \\operatorname{col}_1 &amp; \\operatorname{col}_2 &amp; \\ldots &amp; \\operatorname{col}_n \\end{array}\\right]\\left[\\begin{array}{c} x_1 \\\\ x_2 \\\\ \\ldots \\\\ x_n \\end{array}\\right]=x_1 \\operatorname{col}_1+x_2 \\operatorname{col}_2+\\ldots+x_n \\operatorname{col}_n Ax=[col1​​col2​​…​coln​​]⎣⎢⎢⎡​x1​x2​…xn​​⎦⎥⎥⎤​=x1​col1​+x2​col2​+…+xn​coln​ 例子： Ax=[1234][35]=3[13]+5[24]A x=\\left[\\begin{array}{ll} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{array}\\right]\\left[\\begin{array}{l} 3 \\\\ 5 \\end{array}\\right]=3\\left[\\begin{array}{l} 1 \\\\ 3 \\end{array}\\right]+5\\left[\\begin{array}{l} 2 \\\\ 4 \\end{array}\\right] Ax=[13​24​][35​]=3[13​]+5[24​] 所得到的结果就是矩阵的第一个列向量乘以 x1=3x_1=3x1​=3 加上第二个列向量乘以 x2=5x_2=5x2​=5 一个矩阵和一个向量相乘的过程，对位于原矩阵各列的列向量重新进行线性组合的过程，而线性组合的各系数就是该向量的对应下标元素。 坐标变换 从列角度的变换的过程，就是坐标的变换。考虑 m×nm\\times nm×n 矩阵 AAA 和 nnn 维向量 xxx 的乘法： Ax=[a11a12…a1na21a22…a2n……am1am2…amn][x1x2…xn]=[a11a12…a1na21a22…a2n……am1am2…amn](x1[10…0]+x2[01…0]+⋯+xn[00…1])=x1[a11a21…am1]+x2[a12a22…am2]+…+xn[a1na2n…amn]\\begin{aligned} A x&amp;=\\left[\\begin{array}{cccc} a_{11} &amp; a_{12} &amp; \\ldots &amp; a_{1 n} \\\\ a_{21} &amp; a_{22} &amp; \\ldots &amp; a_{2 n} \\\\ \\ldots &amp; &amp; \\ldots &amp; \\\\ a_{m 1} &amp; a_{m 2} &amp; \\ldots &amp; a_{m n} \\end{array}\\right]\\left[\\begin{array}{c} x_1 \\\\ x_2 \\\\ \\ldots \\\\ x_n \\end{array}\\right]\\\\ &amp;=\\left[\\begin{array}{cccc} a_{11} &amp; a_{12} &amp; \\ldots &amp; a_{1 n} \\\\ a_{21} &amp; a_{22} &amp; \\ldots &amp; a_{2 n} \\\\ \\ldots &amp; &amp; \\ldots &amp; \\\\ a_{m 1} &amp; a_{m 2} &amp; \\ldots &amp; a_{m n} \\end{array}\\right]\\left(x_1\\left[\\begin{array}{c} 1 \\\\ 0 \\\\ \\ldots \\\\ 0 \\end{array}\\right]+x_2\\left[\\begin{array}{c} 0 \\\\ 1 \\\\ \\ldots \\\\ 0 \\end{array}\\right]+\\cdots+x_n\\left[\\begin{array}{c} 0 \\\\ 0 \\\\ \\ldots \\\\ 1 \\end{array}\\right] \\right)\\\\ &amp;=x_1\\left[\\begin{array}{c} a_{11} \\\\ a_{21} \\\\ \\ldots \\\\ a_{m 1} \\end{array}\\right]+x_2\\left[\\begin{array}{c} a_{12} \\\\ a_{22} \\\\ \\ldots \\\\ a_{m 2} \\end{array}\\right]+\\ldots+x_n\\left[\\begin{array}{c} a_{1 n} \\\\ a_{2 n} \\\\ \\ldots \\\\ a_{m n} \\end{array}\\right] \\end{aligned} Ax​=⎣⎢⎢⎡​a11​a21​…am1​​a12​a22​am2​​…………​a1n​a2n​amn​​⎦⎥⎥⎤​⎣⎢⎢⎡​x1​x2​…xn​​⎦⎥⎥⎤​=⎣⎢⎢⎡​a11​a21​…am1​​a12​a22​am2​​…………​a1n​a2n​amn​​⎦⎥⎥⎤​⎝⎜⎜⎛​x1​⎣⎢⎢⎡​10…0​⎦⎥⎥⎤​+x2​⎣⎢⎢⎡​01…0​⎦⎥⎥⎤​+⋯+xn​⎣⎢⎢⎡​00…1​⎦⎥⎥⎤​⎠⎟⎟⎞​=x1​⎣⎢⎢⎡​a11​a21​…am1​​⎦⎥⎥⎤​+x2​⎣⎢⎢⎡​a12​a22​…am2​​⎦⎥⎥⎤​+…+xn​⎣⎢⎢⎡​a1n​a2n​…amn​​⎦⎥⎥⎤​​ 经过乘法变换，nnn 维列向量 xxx 变换成了 nnn 个 mmm 维列向量线性组合的形式，其最终结果是一个 mmm 维的列向量。 可以看出：经过变换，将 xxx 维的向量空间映射到了矩阵 AAA 列向量张成的空间（秩=列向量组的秩） 说明： 当且仅当 n=mn=mn=m，且 nnn 个列向量线性无关的时候，它们才能称之为一组新的基底。 链接 https://www.zhihu.com/question/28623194 ","tags":[{"name":"LinearAlgebra","slug":"linearalgebra","used":true,"link":"https://blog.qxxiao.eu.org/tag/linearalgebra/"},{"name":"Math","slug":"math","used":true,"link":"https://blog.qxxiao.eu.org/tag/math/"}],"title":"矩阵的运算","feature":"","link":"https://blog.qxxiao.eu.org/post/矩阵的运算/","stats":{"text":"9 min read","time":484000,"words":1544,"minutes":9},"date":"2021-05-02 13:00:11","dateFormat":"2021-05-02","isTop":false},{"content":" 简单再生码，能够以较低成本简单快速地精确修复，编码效率接近23\\frac{2}{3}32​ Ⅰ. INTRODUCTION 编码的分布式存储系统中一个中心问题是在故障发生时保持系统编码表示，即维持系统的冗余。 网络编码：修复纠删码系统中的节点故障需要编码分组(coded packets)的网络内(in-network)组合。 在研究精确修复问题中，有几个指标可以优化：修复期间从现有磁盘读取的总信息量、网络中通信的总信息量（修复带宽）或每次修复所需访问的磁盘总数。 Ⅱ. SIMPLE REGENERATING CODES A. 编码构造 将文件 f\\mathbf{f}f，大小为 M=2kM=2kM=2k，划分为 2 部分 f=[f(1) f2], f(i)∈F1×k, i∈[1,2]\\mathbf{f}=[\\mathbf{f^{(1)}}\\ \\mathbf{f^{2}}],\\ \\mathbf{f}^{(i)} \\in \\mathbb{F}^{1 \\times k},\\ i \\in [1,2]f=[f(1) f2], f(i)∈F1×k, i∈[1,2]。编码过程分为两步： 编码过程 通过一个 (n,k)(n,k)(n,k) 的 MDS 编码将文件的两个部分（即 f(1) f2\\mathbf{f^{(1)}}\\ \\mathbf{f^{2}}f(1) f2）分别编码（因为每一个部分都有 kkk 个符号），记编码后编码块分别为长度为 nnn 的向量 x\\mathbf{x}x 和 y\\mathbf{y}y： (1)x=f(1)Gy=f(2)G\\mathbf{x}=\\mathbf{f}^{(1)}\\mathbf{G} \\\\ \\mathbf{y}=\\mathbf{f}^{(2)}\\mathbf{G} \\tag{1} x=f(1)Gy=f(2)G(1) 其中 G∈Fk×n\\mathbf{G} \\in \\mathbb{F}^{k\\times n}G∈Fk×n 是 (n,k)(n,k)(n,k) MDS 码生成矩阵，其最大距离性质保证了任意 x\\mathbf{x}x 或 y\\mathbf{y}y 的 kkk 个编码块都可以分别重建 f(1)\\mathbf{f^{(1)}}f(1) 或 f2\\mathbf{f^{2}}f2；最后通过异或生成 s\\mathbf{s}s : (2)s=x+y\\mathbf{s}=\\mathbf{x}+\\mathbf{y} \\tag{2} s=x+y(2) 上述的编码过程一共产生 2n+n=3n2n+n=3n2n+n=3n 个编码块（符号）。 块放置策略 目的：将 3n3n3n 个编码块放置到 nnn 个节点，则每个节点存储 3 个编码块。 方法：每个节点分别存储来自 x,y,s\\mathbf{x},\\mathbf{y},\\mathbf{s}x,y,s 的一个编码块，要求 3 个编码块下标都互不相同。对于 n≥2n \\geq 2n≥2 都可以采用如下的循环放置来实现： B. 纠删弹性和码率 可以容忍任意的 n−kn-kn−k 个故障，从两个分别的 MDS 编码过程得到。 (n,k)−SRC(n,k)-SRC(n,k)−SRC的编码效率(space efﬁciency) RRR 等于有用的存储信息总量与存储数据总量之比： (3)R=file sizestorage spent=2⋅k3⋅nR=\\frac{file \\ size}{storage \\ spent}=\\frac{2 \\cdot k}{3 \\cdot n} \\tag{3} R=storage spentfile size​=3⋅n2⋅k​(3) 并且上界是 23\\frac{2}{3}32​，mmm 固定时，R=23kk+m⟶k→∞23R=\\frac{2}{3}\\frac{k}{k+m} \\stackrel{k \\rightarrow \\infty}{\\longrightarrow} \\frac{2}{3}R=32​k+mk​⟶k→∞​32​。 C. 修复丢失块 由于丢失的每个块与存储在 2 个节点中的另外 2 个编码块为同一个索引，因此 SRC 能够轻松修复单个丢失的编码块或单个节点故障，通过通信这两个存活节点，可以通过简单的异或操作修复丢失的块。 修复单节点故障需要 2 倍丢失数据（6 个块）的修复带宽和磁盘读取，需要访问 d=min⁡(n−1,4)d=\\min{(n-1,4)}d=min(n−1,4) 个磁盘。 (4,2)-SRC 举例 举例 (n=4,k=2)−SRC(n=4,k=2)-SRC(n=4,k=2)−SRC，原始的数据对象划分为 f1,f2,f3,f4f_1,f_2,f_3,f_4f1​,f2​,f3​,f4​，分为 2 组，将 [f1 f2][f_1 \\ f_2][f1​ f2​] 编码成 [x1 x2 x3 x4][x_1 \\ x_2 \\ x_3 \\ x_4][x1​ x2​ x3​ x4​]；将 [f3 f4][f_3 \\ f_4][f3​ f4​] 编码成 [y1 y2 y3 y4][y_1 \\ y_2 \\ y_3 \\ y_4][y1​ y2​ y3​ y4​]，最后通过异或得到 [s1 s2 s3 s4][s_1 \\ s_2 \\ s_3 \\ s_4][s1​ s2​ s3​ s4​]，过程如下： Ⅲ. SIMULATIONS 使用云存储模拟器将所提出 SRCSRCSRC 码与 Replication 和 Reed-Solomon 码进行了比较。 主要的实验分析： 存储开销分析 n−k=4n-k=4n−k=4 的存储开销对比： 修复性能 测量修复故障节点时的吞吐量 3-副本的修复性能最好，其次是 SRC，而 RS 码的修复性能最差。（考虑修复需要访问的数据量） 在不同的 (n,k)(n,k)(n,k) 下，SRC 的修复性能保持不变，但随着 n 的增加，RS 码的修复性能变差；其主要优点之一：修复性能独立于 (n,k)(n,k)(n,k)。 此外，SRC 的修复吞吐量约为 500MB/s，约为 3-副本性能的 64%。 数据可靠性分析 使用一个简单的马尔可夫模型[3]来估计可靠性。为简单起见，故障仅发生在磁盘上，假定故障没有相关性。 SRCs 的可靠性远远高于 3-副本（10910^9109）。即使对于高码率(50，46)，SRC 也比 3-副本可靠几个数量级。受益于 SRC 的高修复速度。 RS 码呈现明显不同趋势。虽然(10，6)和(20，16)的可靠性高于 3-副本，但随着(n，k)的增长，RS 码的可靠性大大降低。因为它们的修复性能随着 k 的增加而迅速下降。 Ⅳ. CONCLUSIONS 提出了结构简单的 SRC，主要特点： (n,k)−SRC(n,k)-SRC(n,k)−SRC 可以容许任意 n−kn-kn−k 个节点故障，是 MDS 编码； 码率（编码效率）为 2k3n\\frac{2k}{3n}3n2k​ ，可以无限接近 23(k→∞)\\frac{2}{3}(k \\rightarrow \\infty)32​(k→∞) 修复单个节点很高效，得益于特定的块放置策略和编码过程中第二步的异或编码，可以实现精确修复；修复单个节点最多访问 min⁡{n−1,4}\\min\\{n-1, 4\\}min{n−1,4} 个磁盘（节点），修复带宽和访问的数据量都是丢失数据的2倍。 总体上是一个结构简单，易于实现的一类编码。 主要思想：两个 MDS 预编码用于针对任何 n−k=mn-k=mn−k=m 故障提供可靠性，而应用于 MDS 编码分组之上的 XOR 在单节点故障发生时提供有效精确修复。 附录（折衷） 上述将文件 f\\mathbf{f}f，大小为 M=2kM=2kM=2k，划分为 2 部分。一般 (n,k,f)−SRC(n,k,f)-SRC(n,k,f)−SRC，将数据分为 M=fkM=fkM=fk，划分为 fff 个部分，编码策略一样，共生成 (f+1)n(f+1)n(f+1)n 个编码块，每个节点存储 f+1f+1f+1 个块。分析： 编码效率(RRR) RSRC=file sizestorage spent=f⋅k(f+1)⋅nR_{SRC}=\\frac{file \\ size}{storage \\ spent}=\\frac{f \\cdot k}{(f+1)\\cdot n} RSRC​=storage spentfile size​=(f+1)⋅nf⋅k​ 编码效率是 (n,k)(n,k)(n,k) MDS 码的 ff+1\\frac{f}{f+1}f+1f​ 每个节点的存储(α\\alphaα) αSRC=f+1f⋅Mk\\alpha_{SRC}=\\frac{f+1}{f} \\cdot \\frac{M}{k} αSRC​=ff+1​⋅kM​ 单个节点的修复带宽(γ\\gammaγ) γSRC=f(f+1)=(f+1)Mk\\gamma_{SRC}=f(f+1)=(f+1)\\frac{M}{k} γSRC​=f(f+1)=(f+1)kM​ 单节点修复的磁盘访问个数(ddd) dSRC=min⁡(n−1,2f)d_{SRC}=\\min(n-1, 2f) dSRC​=min(n−1,2f) 参考论文 A. G. Dimakis, P. G. Godfrey, Y. Wu, M. J. Wainwright, and K. Ramchandran, “Network coding for distributed storage systems,” in IEEE Trans. on Inform. Theory, vol. 56, pp. 4539 – 4551, Sep. 2010. A. G. Dimakis, K. Ramchandran, Y. Wu, and C. Suh, “A survey on network codes for distributed storage,” in IEEE Proceedings, vol. 99, pp. 476 – 489, Mar. 2011. D. Ford, F. Labelle, F. I. Popovici, M. Stokely, V.-A. T. L. Barroso, C. Grimes, and S. Quinlan, “Availability in globally distributed storage systems,” in OSDI ’10: Proc. of the 9th Usenix Symposium on Operating Systems Design and Implementation, 2010. ","tags":[{"name":"EC","slug":"ec","used":true,"link":"https://blog.qxxiao.eu.org/tag/ec/"},{"name":"Paper","slug":"paper","used":true,"link":"https://blog.qxxiao.eu.org/tag/paper/"}],"title":"Simple Regenerating Codes: Network Coding for Cloud Storage","feature":"https://pic.qxxiao.cn/academic_paper.png","link":"https://blog.qxxiao.eu.org/post/simple-regenerating-codes-network-coding-for-cloud-storage/","stats":{"text":"9 min read","time":515000,"words":1914,"minutes":9},"date":"2021-04-20 16:29:40","dateFormat":"2021-04-20","isTop":false},{"content":" 说明: 对Jerasure-1.2版本重点接口和编码的理解和梳理，2.0版本类似。主要参考此版本的说明手册和源代码，可以再 这里 找到相关资料。 相关资料见 参考链接 原理分析 使用 schedule 代替 bit-matrix 参考Jerasure1.2手册$4.1；将稀疏位矩阵中的 1 用 5元组 来表示，通过确定的多个 5 元组表达式运算完成编码块共 m×wm \\times wm×w 个 packets 的编码计算。 notes: 编码时，数据元素和编码元素为二进制形式，数据块和编码块都分成了 w 个 packet，每次对 packet 的元素进行并行操作【 M(e1)∗V(e2)=V(e1e2)M(e_1)*V(e_2)=V(e_1e_2)M(e1​)∗V(e2​)=V(e1​e2​) 】。 代码分析 对 Cauthy 矩阵位矩阵的 计划表优化 做了分析。 回顾一下位矩阵的解码过程，与经典的 RS 等解码类似 下图使用生成矩阵｜分布矩阵生成校验块的过程，省略了数据块部分： 假设 D 1、C 1 失效，选取前 k 个没有失效的编码块对应的超行作为新的分布矩阵，其逆矩阵通常称作为解码矩阵 decoding matrix： 说明： Jerasure 中选取的 (kw)×(kw)(kw) \\times (kw)(kw)×(kw) 的分布式矩阵的 编码块对应的超行(w行) 顺序为 C2、D2、D3 对应的超行。前 k 个中失效的数据块用未失效的校验块替代，而将失效的数据块和失效的校验块放在 k 之后用于计划表的操作。这种方式能够同时解码出失效的检验块。 通常使用上图的逆矩阵的部分超行来解码出数据块，再重新编码恢复校验块也可以。 Jerasure 使用位矩阵生成计划表过程中的完整解码矩阵的构造：主要来自函数 erasure_generate_decoding_schedule 最后完整的解码矩阵由两部分构成，用于恢复数据块的超行，和用于恢复校验块的超行： 根据图中最后一步，选择失效的数据块对应的逆矩阵的超行，作为解码矩阵的第一部分； 第二部分由编码矩阵(生成矩阵)中失效块对应的超行运算得到： (1) 先复制编码矩阵中的对应的超行到最终的解码矩阵，将失效数据块对应的列置为 0 (2) 遍历编码矩阵的置为0的列(即置0的位置)的位置 i∈[0,w)i \\in [0,w)i∈[0,w)，如果为 1，解码矩阵的该行异或逆矩阵或者最终编码矩阵解出数据块超行的第 i 行。 说明：如果没有数据块失效，则直接复制解码矩阵中，与编码过程一样。Jerasure 中的解码都是通用的解码方法，将失效的数据块和失效的校验块都修复好。 例如：第一步后， 0 0 0 | 1 0 0 | 1 0 0 ==&gt; (2)只需要异或蓝色超行中第0行(只有一个1) 0 0 0 | 0 1 0 | 0 1 0 ==&gt; (2)只需要异或上图紫色超行中第1行 0 0 0 | 0 0 1 | 0 0 1 ==&gt; (2)只需要异或上图紫色超行中第2行 经过第二步后： 1 0 0 | 1 0 1 | 1 1 0 0 1 0 | 1 1 1 | 0 0 1 0 0 1 | 0 1 1 | 1 0 0 可以得到 C 1 的 3 个 packets 表达式： p1=C2p1⊕D2p1⊕D2p3⊕D3p1⊕D3p2p2=C2p2⊕D2p1⊕D2p2⊕D2p3⊕D3p3p3=C2p3⊕D2p2⊕D2p3⊕D3p1p_1 = C_2p_1 \\oplus D_2p_1 \\oplus D_2p_3 \\oplus D_3p_1 \\oplus D_3p_2 \\\\ p_2 = C_2p_2 \\oplus D_2p_1 \\oplus D_2p_2 \\oplus D_2p_3 \\oplus D_3p_3 \\\\ p_3 = C_2p_3 \\oplus D_2p_2 \\oplus D_2p_3 \\oplus D_3p_1 p1​=C2​p1​⊕D2​p1​⊕D2​p3​⊕D3​p1​⊕D3​p2​p2​=C2​p2​⊕D2​p1​⊕D2​p2​⊕D2​p3​⊕D3​p3​p3​=C2​p3​⊕D2​p2​⊕D2​p3​⊕D3​p1​ 将 C 2 替换掉： p1=D1p1⊕D2p1⊕D3p1p2=D1p2⊕D2p2⊕D3p2p3=D1p3⊕D2p3⊕D3p3p_1 = D_1p_1 \\oplus D_2p_1 \\oplus D_3p_1 \\\\ p_2 = D_1p_2 \\oplus D_2p_2 \\oplus D_3p_2 \\\\ p_3 = D_1p_3 \\oplus D_2p_3 \\oplus D_3p_3 p1​=D1​p1​⊕D2​p1​⊕D3​p1​p2​=D1​p2​⊕D2​p2​⊕D3​p2​p3​=D1​p3​⊕D2​p3​⊕D3​p3​ 由此可以看出，恢复校验块的策略是对的。证明思路：由于完整的解码矩阵相乘的编码块与 编码的k个数据块 有区别，我们取超行中的一行 1*(kw)来看，记作 b=(b1 b2…bk)b=(b_1\\ b_2…b_k)b=(b1​ b2​…bk​) ，则根据编码得到该超行编码块中的第 iii 个 packet 为 pi=(b1 b2...bk)⋅[p1 p2...pk]Tp_i = (b1\\ b_2...b_k) \\cdot [p^1\\ p^2 ... p^k]^T pi​=(b1 b2​...bk​)⋅[p1 p2...pk]T 假如第一个数据块失效，将对应的 packets 用解码矩阵中的超行与幸存的前 k 个编码块点积代替。记幸存的前 kkk 个编码块为 pc,p2…pkp^c,p^2…p^kpc,p2…pk ，即 C1,D2…DkC_1,D_2…D_kC1​,D2​…Dk​ ；aia_iai​ 是用到的失效数据块再解码解码矩阵的超行中的第 iii 行： pi=(b1 b2...bk)⋅[(a1(pc,p2...pk)…aw(pc,p2...pk));...;pk]T=b11a1(pc,p2...pk)+...+b1waw(pc,p2...pk)+b2p2+b3p3+...+bkpk=(b11a1+...+b1waw)pc+(b11a1+...+b1waw+b2)p2+...+(b11a1+...+b1waw+bk)pkp_i = (b1\\ b_2...b_k) \\cdot [(a_1(p^c,p^2...p^k) \\dots a_w(p^c,p^2...p^k));...;p^k]^T \\\\ =b_{11}a_1(p^c,p^2...p^k)+...+b_{1w}a_w(p^c,p^2...p^k)+ \\\\ b_2p^2+b_3p^3+...+b_kp^k \\\\ =(b_{11}a_1+...+b_{1w}a_w)p^c+(b_{11}a_1+...+b_{1w}a_w+b_2)p^2+...+(b_{11}a_1+...+b_{1w}a_w+b_k)p^k pi​=(b1 b2​...bk​)⋅[(a1​(pc,p2...pk)…aw​(pc,p2...pk));...;pk]T=b11​a1​(pc,p2...pk)+...+b1w​aw​(pc,p2...pk)+b2​p2+b3​p3+...+bk​pk=(b11​a1​+...+b1w​aw​)pc+(b11​a1​+...+b1w​aw​+b2​)p2+...+(b11​a1​+...+b1w​aw​+bk​)pk 很容易得出结论。 ::: danger 说明 上述过程是将修复数据块和校验块同时修复，来构造完整的解码矩阵，主要目的是生成统一的计划表(都是对同样的 kkk 个编码块的 kwkwkw 个 packetspacketspackets 做操作) ::: 使用与测试 主要供上层调用的 接口函数，是 MDS 编码的接口；部分源代码和注释在线阅读参考 编码 常规有限域内的编码函数 jerasure_matrix_encode(int k, int m, int w, int matrix, char **data_ptrs, char **coding_ptrs, int size) 二进制矩阵下编码函数 jerasure_bitmatrix_encode(int k, int m, int w, int *bitmatrix, char **data_ptrs, char **coding_ptrs, int size, int packetsize) 使用位矩阵转换得到的 schedule 的编码函数（效率比直接使用二进制矩阵高，需要自己先调用 dumb 或 smart 两个计划表生成函数将位矩阵（通常是编码矩阵和解码矩阵）生成 schedule） void jerasure_schedule_encode(int k, int m, int w, int **schedule, char **data_ptrs, char **coding_ptrs, int size, int packetsize) 解码 常规有限域内的解码函数 jerasure_matrix_decode(int k, int m, int w, int *matrix, int row_k_ones, int *erasures, char **data_ptrs, char **coding_ptrs, int size) 二进制矩阵下的解码函数 jerasure_bitmatrix_decode(int k, int m, int w, int *bitmatrix, int row_k_ones, int *erasures,char **data_ptrs, char **coding_ptrs, int size, int packetsize) 使用解码矩阵（二进制）转换得到的 schedule 的解码函数（内部自动生成计划表，一步完成所有的解码操作，所有称作 lazy） int jerasure_schedule_decode_lazy(int k, int m, int w, int *bitmatrix, int *erasures,char **data_ptrs, char **coding_ptrs, int size, int packetsize,int smart) 上面一个函数关于 m=2 的优化，需要先生成所有可能（任意的 1｜2 个失效）的计划表 int jerasure_schedule_decode_cache(int k, int m, int w, int ***scache, int *erasures,char **data_ptrs, char **coding_ptrs, int size, int packetsize) 工具函数 生成奇偶校验的函数 【灵活的】有限域向量与编码块做点积、【灵活的】二进制超行(w*kw)与编码块(kw 个 packets)做点积，用于通常的编码函数 jerasure_matrix_encode | jerasure_bitmatrix_encode 有限域矩阵求逆｜判断可逆、二进制矩阵求你｜判断可逆、矩阵乘法、矩阵转位矩阵 返回通常的 有限域｜二进制解码矩阵（前 k 个有效块 对应的行|超行 的逆矩阵），用于常规的解码函数 jerasure_matrix_decode | jerasure_bitmatrix_decode 调试和统计 打印矩阵 void jerasure_print_matrix(int *m, int rows, int cols, int w) void jerasure_print_bitmatrix(int *m, int rows, int cols, int w) 统计运算 void jerasure_get_stats(double *fill_in) notes jerasure_schedule_decode_lazyjerasure\\_schedule\\_decode\\_lazyjerasure_schedule_decode_lazy 生成解码矩阵的过程，求逆矩阵是 O(n3)O(n^3)O(n3) 级别 参考链接 Jerasure: A Library in C/C++ Facilitating Erasure Coding for Storage Applications. Version 1.2 【1】的翻译 探秘 Jerasure 博客-JErasure库的相关学习 部分源代码和注释在线阅读参考 ","tags":[{"name":"EC","slug":"ec","used":true,"link":"https://blog.qxxiao.eu.org/tag/ec/"}],"title":"Jerasure-1.2","feature":"","link":"https://blog.qxxiao.eu.org/post/Jerasure-1.2/","stats":{"text":"9 min read","time":535000,"words":2059,"minutes":9},"date":"2021-04-11 15:31:10","dateFormat":"2021-04-11","isTop":false}]}
      